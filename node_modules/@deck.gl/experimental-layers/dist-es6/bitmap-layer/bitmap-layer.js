// Copyright (c) 2015 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
import { Layer } from '@deck.gl/core';
import GL from 'luma.gl/constants';
import { Model, Geometry, loadTextures } from 'luma.gl';
import BITMAP_VERTEX_SHADER from './bitmap-layer-vertex';
import BITMAP_FRAGMENT_SHADER from './bitmap-layer-fragment'; // Note: needs to match vertex shader

const MAX_BITMAPS = 11;
const defaultProps = {
  images: [],
  desaturate: 0,
  blendMode: null,
  // More context: because of the blending mode we're using for ground imagery,
  // alpha is not effective when blending the bitmap layers with the base map.
  // Instead we need to manually dim/blend rgb values with a background color.
  transparentColor: [0, 0, 0, 0],
  tintColor: [255, 255, 255],
  // accessors
  getCenter: x => x.center,
  getRotation: x => x.rotation
};
/*
 * @class
 * @param {object} props
 * @param {number} props.transparentColor - color to interpret transparency to
 * @param {number} props.tintColor - color bias
 */

export default class BitmapLayer extends Layer {
  initializeState() {
    const gl = this.context.gl;
    this.setState({
      model: this.getModel(gl)
    });
    const attributeManager = this.state.attributeManager;
    attributeManager.addInstanced({
      instanceCenter: {
        size: 3,
        update: this.calculateInstanceCenters
      },
      instanceRotation: {
        size: 3,
        update: this.calculateInstanceRotations
      },
      instanceBitmapIndex: {
        size: 1,
        update: this.calculateInstanceBitmapIndex
      }
    });
  }

  updateState({
    props,
    oldProps
  }) {
    if (props.images !== oldProps.images) {
      let changed = !oldProps.images || props.images.length !== oldProps.images.length;

      if (!changed) {
        for (let i = 0; i < props.images.length; ++i) {
          changed = changed || props.images[i] !== oldProps.images[i];
        }
      }

      if (changed) {
        this.loadMapImagesToTextures();
      }
    }

    const desaturate = props.desaturate;
    this.state.model.setUniforms({
      desaturate
    });
  }

  getModel(gl) {
    // Two triangles making up a square to render the bitmap texture on
    const verts = [[1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0]];
    const positions = [];
    const texCoords = [];
    verts.forEach(vertex => {
      // geometry: unit square centered on origin
      positions.push(vertex[0] / 2, vertex[1] / 2, vertex[2] / 2); // texture: unit square with bottom left in origin

      texCoords.push(vertex[0] / 2 + 0.5, -vertex[1] / 2 + 0.5);
    });
    const model = new Model(gl, {
      id: this.props.id,
      vs: BITMAP_VERTEX_SHADER,
      fs: BITMAP_FRAGMENT_SHADER,
      shaderCache: this.context.shaderCache,
      geometry: new Geometry({
        drawMode: GL.TRIANGLES,
        vertexCount: 6,
        attributes: {
          positions: new Float32Array(positions),
          texCoords: new Float32Array(texCoords)
        }
      }),
      isInstanced: true
    });
    return model;
  }

  draw({
    uniforms
  }) {
    const _this$props = this.props,
          transparentColor = _this$props.transparentColor,
          tintColor = _this$props.tintColor; // TODO fix zFighting
    // Render the image

    this.state.model.render(Object.assign({}, uniforms, {
      transparentColor,
      tintColor
    }));
  }

  loadMapImagesToTextures() {
    const model = this.state.model;
    const images = this.props.images;

    for (let i = 0; i < Math.min(images.length, MAX_BITMAPS); i++) {
      loadTextures(this.context.gl, {
        urls: [images[i]]
      }).then(([texture]) => {
        return model.setUniforms({
          [`uBitmap${i}`]: texture
        });
      });
    }
  }

  getBitmapIndex(point) {
    const url = point.imageUrl;
    const idx = Math.max(this.props.images.indexOf(url), 0);
    return idx >= MAX_BITMAPS ? 0 : idx;
  }

  calculateInstanceCenters(attribute, props) {
    const _this$props2 = this.props,
          data = _this$props2.data,
          getCenter = _this$props2.getCenter;
    const value = attribute.value,
          size = attribute.size;
    let i = 0;

    for (const point of data) {
      const center = getCenter(point);
      value[i + 0] = center[0] || 0;
      value[i + 1] = center[1] || 0;
      value[i + 2] = center[2] || 0;
      i += size;
    }
  }

  calculateInstanceRotations(attribute, props) {
    const _this$props3 = this.props,
          data = _this$props3.data,
          getRotation = _this$props3.getRotation;
    const value = attribute.value,
          size = attribute.size;
    let i = 0;

    for (const point of data) {
      const rotation = getRotation(point);
      value[i + 0] = rotation[0] || 0;
      value[i + 1] = rotation[1] || 0;
      value[i + 2] = rotation[2] || 0;
      i += size;
    }
  }

  calculateInstanceBitmapIndex(attribute) {
    const data = this.props.data;
    const value = attribute.value,
          size = attribute.size;
    let i = 0;

    for (const point of data) {
      const bitmapIndex = Number.isFinite(point.bitmapIndex) ? point.bitmapIndex : this.getBitmapIndex(point);
      value[i] = bitmapIndex;
      i += size;
    }
  }

}
BitmapLayer.layerName = 'BitmapLayer';
BitmapLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9iaXRtYXAtbGF5ZXIvYml0bWFwLWxheWVyLmpzIl0sIm5hbWVzIjpbIkxheWVyIiwiR0wiLCJNb2RlbCIsIkdlb21ldHJ5IiwibG9hZFRleHR1cmVzIiwiQklUTUFQX1ZFUlRFWF9TSEFERVIiLCJCSVRNQVBfRlJBR01FTlRfU0hBREVSIiwiTUFYX0JJVE1BUFMiLCJkZWZhdWx0UHJvcHMiLCJpbWFnZXMiLCJkZXNhdHVyYXRlIiwiYmxlbmRNb2RlIiwidHJhbnNwYXJlbnRDb2xvciIsInRpbnRDb2xvciIsImdldENlbnRlciIsIngiLCJjZW50ZXIiLCJnZXRSb3RhdGlvbiIsInJvdGF0aW9uIiwiQml0bWFwTGF5ZXIiLCJpbml0aWFsaXplU3RhdGUiLCJnbCIsImNvbnRleHQiLCJzZXRTdGF0ZSIsIm1vZGVsIiwiZ2V0TW9kZWwiLCJhdHRyaWJ1dGVNYW5hZ2VyIiwic3RhdGUiLCJhZGRJbnN0YW5jZWQiLCJpbnN0YW5jZUNlbnRlciIsInNpemUiLCJ1cGRhdGUiLCJjYWxjdWxhdGVJbnN0YW5jZUNlbnRlcnMiLCJpbnN0YW5jZVJvdGF0aW9uIiwiY2FsY3VsYXRlSW5zdGFuY2VSb3RhdGlvbnMiLCJpbnN0YW5jZUJpdG1hcEluZGV4IiwiY2FsY3VsYXRlSW5zdGFuY2VCaXRtYXBJbmRleCIsInVwZGF0ZVN0YXRlIiwicHJvcHMiLCJvbGRQcm9wcyIsImNoYW5nZWQiLCJsZW5ndGgiLCJpIiwibG9hZE1hcEltYWdlc1RvVGV4dHVyZXMiLCJzZXRVbmlmb3JtcyIsInZlcnRzIiwicG9zaXRpb25zIiwidGV4Q29vcmRzIiwiZm9yRWFjaCIsInZlcnRleCIsInB1c2giLCJpZCIsInZzIiwiZnMiLCJzaGFkZXJDYWNoZSIsImdlb21ldHJ5IiwiZHJhd01vZGUiLCJUUklBTkdMRVMiLCJ2ZXJ0ZXhDb3VudCIsImF0dHJpYnV0ZXMiLCJGbG9hdDMyQXJyYXkiLCJpc0luc3RhbmNlZCIsImRyYXciLCJ1bmlmb3JtcyIsInJlbmRlciIsIk9iamVjdCIsImFzc2lnbiIsIk1hdGgiLCJtaW4iLCJ1cmxzIiwidGhlbiIsInRleHR1cmUiLCJnZXRCaXRtYXBJbmRleCIsInBvaW50IiwidXJsIiwiaW1hZ2VVcmwiLCJpZHgiLCJtYXgiLCJpbmRleE9mIiwiYXR0cmlidXRlIiwiZGF0YSIsInZhbHVlIiwiYml0bWFwSW5kZXgiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImxheWVyTmFtZSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSxTQUFRQSxLQUFSLFFBQW9CLGVBQXBCO0FBQ0EsT0FBT0MsRUFBUCxNQUFlLG1CQUFmO0FBQ0EsU0FBUUMsS0FBUixFQUFlQyxRQUFmLEVBQXlCQyxZQUF6QixRQUE0QyxTQUE1QztBQUVBLE9BQU9DLG9CQUFQLE1BQWlDLHVCQUFqQztBQUNBLE9BQU9DLHNCQUFQLE1BQW1DLHlCQUFuQyxDLENBRUE7O0FBQ0EsTUFBTUMsV0FBVyxHQUFHLEVBQXBCO0FBRUEsTUFBTUMsWUFBWSxHQUFHO0FBQ25CQyxFQUFBQSxNQUFNLEVBQUUsRUFEVztBQUduQkMsRUFBQUEsVUFBVSxFQUFFLENBSE87QUFJbkJDLEVBQUFBLFNBQVMsRUFBRSxJQUpRO0FBS25CO0FBQ0E7QUFDQTtBQUNBQyxFQUFBQSxnQkFBZ0IsRUFBRSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FSQztBQVNuQkMsRUFBQUEsU0FBUyxFQUFFLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFYLENBVFE7QUFVbkI7QUFDQUMsRUFBQUEsU0FBUyxFQUFFQyxDQUFDLElBQUlBLENBQUMsQ0FBQ0MsTUFYQztBQVluQkMsRUFBQUEsV0FBVyxFQUFFRixDQUFDLElBQUlBLENBQUMsQ0FBQ0c7QUFaRCxDQUFyQjtBQWVBOzs7Ozs7O0FBTUEsZUFBZSxNQUFNQyxXQUFOLFNBQTBCbkIsS0FB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bi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge0xheWVyfSBmcm9tICdAZGVjay5nbC9jb3JlJztcbmltcG9ydCBHTCBmcm9tICdsdW1hLmdsL2NvbnN0YW50cyc7XG5pbXBvcnQge01vZGVsLCBHZW9tZXRyeSwgbG9hZFRleHR1cmVzfSBmcm9tICdsdW1hLmdsJztcblxuaW1wb3J0IEJJVE1BUF9WRVJURVhfU0hBREVSIGZyb20gJy4vYml0bWFwLWxheWVyLXZlcnRleCc7XG5pbXBvcnQgQklUTUFQX0ZSQUdNRU5UX1NIQURFUiBmcm9tICcuL2JpdG1hcC1sYXllci1mcmFnbWVudCc7XG5cbi8vIE5vdGU6IG5lZWRzIHRvIG1hdGNoIHZlcnRleCBzaGFkZXJcbmNvbnN0IE1BWF9CSVRNQVBTID0gMTE7XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgaW1hZ2VzOiBbXSxcblxuICBkZXNhdHVyYXRlOiAwLFxuICBibGVuZE1vZGU6IG51bGwsXG4gIC8vIE1vcmUgY29udGV4dDogYmVjYXVzZSBvZiB0aGUgYmxlbmRpbmcgbW9kZSB3ZSdyZSB1c2luZyBmb3IgZ3JvdW5kIGltYWdlcnksXG4gIC8vIGFscGhhIGlzIG5vdCBlZmZlY3RpdmUgd2hlbiBibGVuZGluZyB0aGUgYml0bWFwIGxheWVycyB3aXRoIHRoZSBiYXNlIG1hcC5cbiAgLy8gSW5zdGVhZCB3ZSBuZWVkIHRvIG1hbnVhbGx5IGRpbS9ibGVuZCByZ2IgdmFsdWVzIHdpdGggYSBiYWNrZ3JvdW5kIGNvbG9yLlxuICB0cmFuc3BhcmVudENvbG9yOiBbMCwgMCwgMCwgMF0sXG4gIHRpbnRDb2xvcjogWzI1NSwgMjU1LCAyNTVdLFxuICAvLyBhY2Nlc3NvcnNcbiAgZ2V0Q2VudGVyOiB4ID0+IHguY2VudGVyLFxuICBnZXRSb3RhdGlvbjogeCA9PiB4LnJvdGF0aW9uXG59O1xuXG4vKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBwcm9wcy50cmFuc3BhcmVudENvbG9yIC0gY29sb3IgdG8gaW50ZXJwcmV0IHRyYW5zcGFyZW5jeSB0b1xuICogQHBhcmFtIHtudW1iZXJ9IHByb3BzLnRpbnRDb2xvciAtIGNvbG9yIGJpYXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQml0bWFwTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuICAgIHRoaXMuc2V0U3RhdGUoe21vZGVsOiB0aGlzLmdldE1vZGVsKGdsKX0pO1xuXG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICBpbnN0YW5jZUNlbnRlcjoge3NpemU6IDMsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZUNlbnRlcnN9LFxuICAgICAgaW5zdGFuY2VSb3RhdGlvbjoge3NpemU6IDMsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVJvdGF0aW9uc30sXG4gICAgICBpbnN0YW5jZUJpdG1hcEluZGV4OiB7c2l6ZTogMSwgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlQml0bWFwSW5kZXh9XG4gICAgfSk7XG4gIH1cblxuICB1cGRhdGVTdGF0ZSh7cHJvcHMsIG9sZFByb3BzfSkge1xuICAgIGlmIChwcm9wcy5pbWFnZXMgIT09IG9sZFByb3BzLmltYWdlcykge1xuICAgICAgbGV0IGNoYW5nZWQgPSAhb2xkUHJvcHMuaW1hZ2VzIHx8IHByb3BzLmltYWdlcy5sZW5ndGggIT09IG9sZFByb3BzLmltYWdlcy5sZW5ndGg7XG4gICAgICBpZiAoIWNoYW5nZWQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wcy5pbWFnZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCBwcm9wcy5pbWFnZXNbaV0gIT09IG9sZFByb3BzLmltYWdlc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5sb2FkTWFwSW1hZ2VzVG9UZXh0dXJlcygpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7ZGVzYXR1cmF0ZX0gPSBwcm9wcztcbiAgICB0aGlzLnN0YXRlLm1vZGVsLnNldFVuaWZvcm1zKHtkZXNhdHVyYXRlfSk7XG4gIH1cblxuICBnZXRNb2RlbChnbCkge1xuICAgIC8vIFR3byB0cmlhbmdsZXMgbWFraW5nIHVwIGEgc3F1YXJlIHRvIHJlbmRlciB0aGUgYml0bWFwIHRleHR1cmUgb25cbiAgICBjb25zdCB2ZXJ0cyA9IFtbMSwgMSwgMF0sIFstMSwgMSwgMF0sIFsxLCAtMSwgMF0sIFstMSwgMSwgMF0sIFsxLCAtMSwgMF0sIFstMSwgLTEsIDBdXTtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBbXTtcbiAgICBjb25zdCB0ZXhDb29yZHMgPSBbXTtcbiAgICB2ZXJ0cy5mb3JFYWNoKHZlcnRleCA9PiB7XG4gICAgICAvLyBnZW9tZXRyeTogdW5pdCBzcXVhcmUgY2VudGVyZWQgb24gb3JpZ2luXG4gICAgICBwb3NpdGlvbnMucHVzaCh2ZXJ0ZXhbMF0gLyAyLCB2ZXJ0ZXhbMV0gLyAyLCB2ZXJ0ZXhbMl0gLyAyKTtcbiAgICAgIC8vIHRleHR1cmU6IHVuaXQgc3F1YXJlIHdpdGggYm90dG9tIGxlZnQgaW4gb3JpZ2luXG4gICAgICB0ZXhDb29yZHMucHVzaCh2ZXJ0ZXhbMF0gLyAyICsgMC41LCAtdmVydGV4WzFdIC8gMiArIDAuNSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBtb2RlbCA9IG5ldyBNb2RlbChnbCwge1xuICAgICAgaWQ6IHRoaXMucHJvcHMuaWQsXG4gICAgICB2czogQklUTUFQX1ZFUlRFWF9TSEFERVIsXG4gICAgICBmczogQklUTUFQX0ZSQUdNRU5UX1NIQURFUixcbiAgICAgIHNoYWRlckNhY2hlOiB0aGlzLmNvbnRleHQuc2hhZGVyQ2FjaGUsXG4gICAgICBnZW9tZXRyeTogbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgZHJhd01vZGU6IEdMLlRSSUFOR0xFUyxcbiAgICAgICAgdmVydGV4Q291bnQ6IDYsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICBwb3NpdGlvbnM6IG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25zKSxcbiAgICAgICAgICB0ZXhDb29yZHM6IG5ldyBGbG9hdDMyQXJyYXkodGV4Q29vcmRzKVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIGlzSW5zdGFuY2VkOiB0cnVlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cblxuICBkcmF3KHt1bmlmb3Jtc30pIHtcbiAgICBjb25zdCB7dHJhbnNwYXJlbnRDb2xvciwgdGludENvbG9yfSA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyBUT0RPIGZpeCB6RmlnaHRpbmdcblxuICAgIC8vIFJlbmRlciB0aGUgaW1hZ2VcbiAgICB0aGlzLnN0YXRlLm1vZGVsLnJlbmRlcihcbiAgICAgIE9iamVjdC5hc3NpZ24oe30sIHVuaWZvcm1zLCB7XG4gICAgICAgIHRyYW5zcGFyZW50Q29sb3IsXG4gICAgICAgIHRpbnRDb2xvclxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgbG9hZE1hcEltYWdlc1RvVGV4dHVyZXMoKSB7XG4gICAgY29uc3Qge21vZGVsfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qge2ltYWdlc30gPSB0aGlzLnByb3BzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5taW4oaW1hZ2VzLmxlbmd0aCwgTUFYX0JJVE1BUFMpOyBpKyspIHtcbiAgICAgIGxvYWRUZXh0dXJlcyh0aGlzLmNvbnRleHQuZ2wsIHtcbiAgICAgICAgdXJsczogW2ltYWdlc1tpXV1cbiAgICAgIH0pLnRoZW4oKFt0ZXh0dXJlXSkgPT4ge1xuICAgICAgICByZXR1cm4gbW9kZWwuc2V0VW5pZm9ybXMoe1tgdUJpdG1hcCR7aX1gXTogdGV4dHVyZX0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0Qml0bWFwSW5kZXgocG9pbnQpIHtcbiAgICBjb25zdCB1cmwgPSBwb2ludC5pbWFnZVVybDtcbiAgICBjb25zdCBpZHggPSBNYXRoLm1heCh0aGlzLnByb3BzLmltYWdlcy5pbmRleE9mKHVybCksIDApO1xuICAgIHJldHVybiBpZHggPj0gTUFYX0JJVE1BUFMgPyAwIDogaWR4O1xuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VDZW50ZXJzKGF0dHJpYnV0ZSwgcHJvcHMpIHtcbiAgICBjb25zdCB7ZGF0YSwgZ2V0Q2VudGVyfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3ZhbHVlLCBzaXplfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBwb2ludCBvZiBkYXRhKSB7XG4gICAgICBjb25zdCBjZW50ZXIgPSBnZXRDZW50ZXIocG9pbnQpO1xuXG4gICAgICB2YWx1ZVtpICsgMF0gPSBjZW50ZXJbMF0gfHwgMDtcbiAgICAgIHZhbHVlW2kgKyAxXSA9IGNlbnRlclsxXSB8fCAwO1xuICAgICAgdmFsdWVbaSArIDJdID0gY2VudGVyWzJdIHx8IDA7XG5cbiAgICAgIGkgKz0gc2l6ZTtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVJvdGF0aW9ucyhhdHRyaWJ1dGUsIHByb3BzKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldFJvdGF0aW9ufSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3ZhbHVlLCBzaXplfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBwb2ludCBvZiBkYXRhKSB7XG4gICAgICBjb25zdCByb3RhdGlvbiA9IGdldFJvdGF0aW9uKHBvaW50KTtcblxuICAgICAgdmFsdWVbaSArIDBdID0gcm90YXRpb25bMF0gfHwgMDtcbiAgICAgIHZhbHVlW2kgKyAxXSA9IHJvdGF0aW9uWzFdIHx8IDA7XG4gICAgICB2YWx1ZVtpICsgMl0gPSByb3RhdGlvblsyXSB8fCAwO1xuXG4gICAgICBpICs9IHNpemU7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VCaXRtYXBJbmRleChhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7ZGF0YX0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHt2YWx1ZSwgc2l6ZX0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3QgcG9pbnQgb2YgZGF0YSkge1xuICAgICAgY29uc3QgYml0bWFwSW5kZXggPSBOdW1iZXIuaXNGaW5pdGUocG9pbnQuYml0bWFwSW5kZXgpXG4gICAgICAgID8gcG9pbnQuYml0bWFwSW5kZXhcbiAgICAgICAgOiB0aGlzLmdldEJpdG1hcEluZGV4KHBvaW50KTtcbiAgICAgIHZhbHVlW2ldID0gYml0bWFwSW5kZXg7XG4gICAgICBpICs9IHNpemU7XG4gICAgfVxuICB9XG59XG5cbkJpdG1hcExheWVyLmxheWVyTmFtZSA9ICdCaXRtYXBMYXllcic7XG5CaXRtYXBMYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4iXX0=