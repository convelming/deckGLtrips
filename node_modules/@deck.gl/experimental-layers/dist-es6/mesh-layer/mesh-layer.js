// Note: This file will either be moved back to deck.gl or reformatted to web-monorepo standards
// Disabling lint temporarily to facilitate copying code in and out of this repo

/* eslint-disable */
// Copyright (c) 2015 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
import { Layer, COORDINATE_SYSTEM } from '@deck.gl/core';
import GL from 'luma.gl/constants';
import { Model, Geometry, loadTextures, Texture2D, fp64 } from 'luma.gl';
const fp64LowPart = fp64.fp64LowPart;
import vs from './mesh-layer-vertex.glsl';
import fs from './mesh-layer-fragment.glsl';
import assert from 'assert';
const RADIAN_PER_DEGREE = Math.PI / 180;
/*
 * Load image data into luma.gl Texture2D objects
 * @param {WebGLContext} gl
 * @param {String|Texture2D|HTMLImageElement|Uint8ClampedArray} src - source of image data
 *   can be url string, Texture2D object, HTMLImageElement or pixel array
 * @returns {Promise} resolves to an object with name -> texture mapping
 */

function getTexture(gl, src, opts) {
  if (typeof src === 'string') {
    // Url, load the image
    return loadTextures(gl, Object.assign({
      urls: [src]
    }, opts)).then(textures => textures[0]).catch(error => {
      throw new Error(`Could not load texture from ${src}: ${error}`);
    });
  }

  return new Promise(resolve => resolve(getTextureFromData(gl, src, opts)));
}
/*
 * Convert image data into texture
 * @returns {Texture2D} texture
 */


function getTextureFromData(gl, data, opts) {
  if (data instanceof Texture2D) {
    return data;
  }

  return new Texture2D(gl, Object.assign({
    data
  }, opts));
}

function validateGeometryAttributes(attributes) {
  assert(attributes.positions && attributes.normals && attributes.texCoords);
}
/*
 * Convert mesh data into geometry
 * @returns {Geometry} geometry
 */


function getGeometry(data) {
  if (data instanceof Geometry) {
    validateGeometryAttributes(data.attributes);
    return data;
  } else if (data.positions) {
    validateGeometryAttributes(data);
    return new Geometry({
      attributes: data
    });
  }

  throw Error('Invalid mesh');
}

const DEFAULT_COLOR = [0, 0, 0, 255];
const defaultProps = {
  mesh: null,
  texture: null,
  sizeScale: 1,
  // TODO - parameters should be merged, not completely overridden
  parameters: {
    depthTest: true,
    depthFunc: GL.LEQUAL
  },
  fp64: false,
  // Optional settings for 'lighting' shader module
  lightSettings: {},
  getPosition: x => x.position,
  getColor: x => x.color || DEFAULT_COLOR,
  // yaw, pitch and roll are in degrees
  // https://en.wikipedia.org/wiki/Euler_angles
  getYaw: x => x.yaw || x.angle || 0,
  getPitch: x => x.pitch || 0,
  getRoll: x => x.roll || 0
};
export default class MeshLayer extends Layer {
  getShaders() {
    const projectModule = this.use64bitProjection() ? 'project64' : 'project32';
    return {
      vs,
      fs,
      modules: [projectModule, 'lighting', 'picking']
    };
  }

  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: {
        size: 3,
        accessor: 'getPosition',
        update: this.calculateInstancePositions
      },
      instancePositions64xy: {
        size: 2,
        accessor: 'getPosition',
        update: this.calculateInstancePositions64xyLow
      },
      instanceRotations: {
        size: 3,
        accessor: ['getYaw', 'getPitch', 'getRoll'],
        update: this.calculateInstanceRotations
      },
      instanceColors: {
        size: 4,
        accessor: 'getColor',
        update: this.calculateInstanceColors
      }
    });
    this.setState({
      // Avoid luma.gl's missing uniform warning
      // TODO - add feature to luma.gl to specify ignored uniforms?
      emptyTexture: new Texture2D(this.context.gl, {
        data: new Uint8Array(4),
        width: 1,
        height: 1
      })
    });
  }

  updateState({
    props,
    oldProps,
    changeFlags
  }) {
    const attributeManager = this.getAttributeManager(); // super.updateState({props, oldProps, changeFlags});

    if (changeFlags.dataChanged) {
      attributeManager.invalidateAll();
    }

    this._updateFP64(props, oldProps);

    if (props.texture !== oldProps.texture) {
      this.setTexture(props.texture);
    }
  }

  _updateFP64(props, oldProps) {
    if (props.fp64 !== oldProps.fp64) {
      if (this.state.model) {
        this.state.model.delete();
      }

      this.setState({
        model: this.getModel(this.context.gl)
      });
      this.setTexture(this.state.texture);
      const attributeManager = this.getAttributeManager();
      attributeManager.invalidateAll();
    }
  }

  draw({
    uniforms
  }) {
    const sizeScale = this.props.sizeScale;
    this.state.model.render(Object.assign({}, uniforms, {
      sizeScale
    }));
  }

  getModel(gl) {
    return new Model(gl, Object.assign({}, this.getShaders(), {
      id: this.props.id,
      geometry: getGeometry(this.props.mesh),
      isInstanced: true,
      shaderCache: this.context.shaderCache
    }));
  }

  setTexture(src) {
    const gl = this.context.gl;
    const _this$state = this.state,
          model = _this$state.model,
          emptyTexture = _this$state.emptyTexture;

    if (src) {
      getTexture(gl, src).then(texture => {
        model.setUniforms({
          sampler: texture,
          hasTexture: 1
        });
        this.setState({
          texture
        });
      });
    } else {
      // reset
      this.state.model.setUniforms({
        sampler: emptyTexture,
        hasTexture: 0
      });
      this.setState({
        texture: null
      });
    }
  }

  calculateInstancePositions(attribute) {
    const _this$props = this.props,
          data = _this$props.data,
          getPosition = _this$props.getPosition;
    const value = attribute.value,
          size = attribute.size;
    let i = 0;

    for (const point of data) {
      const position = getPosition(point);
      value[i] = position[0];
      value[i + 1] = position[1];
      value[i + 2] = position[2] || 0;
      i += size;
    }
  }

  calculateInstancePositions64xyLow(attribute) {
    const isFP64 = this.use64bitPositions();
    attribute.constant = !isFP64;

    if (!isFP64) {
      attribute.value = new Float32Array(2);
      return;
    }

    const _this$props2 = this.props,
          data = _this$props2.data,
          getPosition = _this$props2.getPosition;
    const value = attribute.value;
    let i = 0;

    for (const point of data) {
      const position = getPosition(point);
      value[i++] = fp64LowPart(position[0]);
      value[i++] = fp64LowPart(position[1]);
    }
  } // yaw(z), pitch(y) and roll(x) in radians


  calculateInstanceRotations(attribute) {
    const _this$props3 = this.props,
          data = _this$props3.data,
          getYaw = _this$props3.getYaw,
          getPitch = _this$props3.getPitch,
          getRoll = _this$props3.getRoll;
    const value = attribute.value,
          size = attribute.size;
    let i = 0;

    for (const point of data) {
      value[i++] = getRoll(point) * RADIAN_PER_DEGREE;
      value[i++] = getPitch(point) * RADIAN_PER_DEGREE;
      value[i++] = getYaw(point) * RADIAN_PER_DEGREE;
    }
  }

  calculateInstanceColors(attribute) {
    const _this$props4 = this.props,
          data = _this$props4.data,
          getColor = _this$props4.getColor;
    const value = attribute.value;
    let i = 0;

    for (const point of data) {
      const color = getColor(point) || DEFAULT_COLOR;
      value[i++] = color[0];
      value[i++] = color[1];
      value[i++] = color[2];
      value[i++] = isNaN(color[3]) ? 255 : color[3];
    }
  }

}
MeshLayer.layerName = 'MeshLayer';
MeshLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tZXNoLWxheWVyL21lc2gtbGF5ZXIuanMiXSwibmFtZXMiOlsiTGF5ZXIiLCJDT09SRElOQVRFX1NZU1RFTSIsIkdMIiwiTW9kZWwiLCJHZW9tZXRyeSIsImxvYWRUZXh0dXJlcyIsIlRleHR1cmUyRCIsImZwNjQiLCJmcDY0TG93UGFydCIsInZzIiwiZnMiLCJhc3NlcnQiLCJSQURJQU5fUEVSX0RFR1JFRSIsIk1hdGgiLCJQSSIsImdldFRleHR1cmUiLCJnbCIsInNyYyIsIm9wdHMiLCJPYmplY3QiLCJhc3NpZ24iLCJ1cmxzIiwidGhlbiIsInRleHR1cmVzIiwiY2F0Y2giLCJlcnJvciIsIkVycm9yIiwiUHJvbWlzZSIsInJlc29sdmUiLCJnZXRUZXh0dXJlRnJvbURhdGEiLCJkYXRhIiwidmFsaWRhdGVHZW9tZXRyeUF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzIiwicG9zaXRpb25zIiwibm9ybWFscyIsInRleENvb3JkcyIsImdldEdlb21ldHJ5IiwiREVGQVVMVF9DT0xPUiIsImRlZmF1bHRQcm9wcyIsIm1lc2giLCJ0ZXh0dXJlIiwic2l6ZVNjYWxlIiwicGFyYW1ldGVycyIsImRlcHRoVGVzdCIsImRlcHRoRnVuYyIsIkxFUVVBTCIsImxpZ2h0U2V0dGluZ3MiLCJnZXRQb3NpdGlvbiIsIngiLCJwb3NpdGlvbiIsImdldENvbG9yIiwiY29sb3IiLCJnZXRZYXciLCJ5YXciLCJhbmdsZSIsImdldFBpdGNoIiwicGl0Y2giLCJnZXRSb2xsIiwicm9sbCIsIk1lc2hMYXllciIsImdldFNoYWRlcnMiLCJwcm9qZWN0TW9kdWxlIiwidXNlNjRiaXRQcm9qZWN0aW9uIiwibW9kdWxlcyIsImluaXRpYWxpemVTdGF0ZSIsImF0dHJpYnV0ZU1hbmFnZXIiLCJnZXRBdHRyaWJ1dGVNYW5hZ2VyIiwiYWRkSW5zdGFuY2VkIiwiaW5zdGFuY2VQb3NpdGlvbnMiLCJzaXplIiwiYWNjZXNzb3IiLCJ1cGRhdGUiLCJjYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9ucyIsImluc3RhbmNlUG9zaXRpb25zNjR4eSIsImNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zNjR4eUxvdyIsImluc3RhbmNlUm90YXRpb25zIiwiY2FsY3VsYXRlSW5zdGFuY2VSb3RhdGlvbnMiLCJpbnN0YW5jZUNvbG9ycyIsImNhbGN1bGF0ZUluc3RhbmNlQ29sb3JzIiwic2V0U3RhdGUiLCJlbXB0eVRleHR1cmUiLCJjb250ZXh0IiwiVWludDhBcnJheSIsIndpZHRoIiwiaGVpZ2h0IiwidXBkYXRlU3RhdGUiLCJwcm9wcyIsIm9sZFByb3BzIiwiY2hhbmdlRmxhZ3MiLCJkYXRhQ2hhbmdlZCIsImludmFsaWRhdGVBbGwiLCJfdXBkYXRlRlA2NCIsInNldFRleHR1cmUiLCJzdGF0ZSIsIm1vZGVsIiwiZGVsZXRlIiwiZ2V0TW9kZWwiLCJkcmF3IiwidW5pZm9ybXMiLCJyZW5kZXIiLCJpZCIsImdlb21ldHJ5IiwiaXNJbnN0YW5jZWQiLCJzaGFkZXJDYWNoZSIsInNldFVuaWZvcm1zIiwic2FtcGxlciIsImhhc1RleHR1cmUiLCJhdHRyaWJ1dGUiLCJ2YWx1ZSIsImkiLCJwb2ludCIsImlzRlA2NCIsInVzZTY0Yml0UG9zaXRpb25zIiwiY29uc3RhbnQiLCJGbG9hdDMyQXJyYXkiLCJpc05hTiIsImxheWVyTmFtZSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsU0FBUUEsS0FBUixFQUFlQyxpQkFBZixRQUF1QyxlQUF2QztBQUNBLE9BQU9DLEVBQVAsTUFBZSxtQkFBZjtBQUNBLFNBQVFDLEtBQVIsRUFBZUMsUUFBZixFQUF5QkMsWUFBekIsRUFBdUNDLFNBQXZDLEVBQWtEQyxJQUFsRCxRQUE2RCxTQUE3RDtNQUNPQyxXLEdBQWVELEksQ0FBZkMsVztBQUVQLE9BQU9DLEVBQVAsTUFBZSwwQkFB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S0FBRCxDQUFSLElBQW1CekUsYUFBakM7QUFDQXVFLE1BQUFBLEtBQUssQ0FBQ0MsQ0FBQyxFQUFGLENBQUwsR0FBYTFELEtBQUssQ0FBQyxDQUFELENBQWxCO0FBQ0F5RCxNQUFBQSxLQUFLLENBQUNDLENBQUMsRUFBRixDQUFMLEdBQWExRCxLQUFLLENBQUMsQ0FBRCxDQUFsQjtBQUNBeUQsTUFBQUEsS0FBSyxDQUFDQyxDQUFDLEVBQUYsQ0FBTCxHQUFhMUQsS0FBSyxDQUFDLENBQUQsQ0FBbEI7QUFDQXlELE1BQUFBLEtBQUssQ0FBQ0MsQ0FBQyxFQUFGLENBQUwsR0FBYU0sS0FBSyxDQUFDaEUsS0FBSyxDQUFDLENBQUQsQ0FBTixDQUFMLEdBQWtCLEdBQWxCLEdBQXdCQSxLQUFLLENBQUMsQ0FBRCxDQUExQztBQUNEO0FBQ0Y7O0FBakswQztBQW9LN0NRLFNBQVMsQ0FBQ3lELFNBQVYsR0FBc0IsV0FBdEI7QUFDQXpELFNBQVMsQ0FBQ3JCLFlBQVYsR0FBeUJBLFlBQXpCIiwic291cmNlc0NvbnRlbnQiOlsiLy8gTm90ZTogVGhpcyBmaWxlIHdpbGwgZWl0aGVyIGJlIG1vdmVkIGJhY2sgdG8gZGVjay5nbCBvciByZWZvcm1hdHRlZCB0byB3ZWItbW9ub3JlcG8gc3RhbmRhcmRzXG4vLyBEaXNhYmxpbmcgbGludCB0ZW1wb3JhcmlseSB0byBmYWNpbGl0YXRlIGNvcHlpbmcgY29kZSBpbiBhbmQgb3V0IG9mIHRoaXMgcmVwb1xuLyogZXNsaW50LWRpc2FibGUgKi9cblxuLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtMYXllciwgQ09PUkRJTkFURV9TWVNURU19IGZyb20gJ0BkZWNrLmdsL2NvcmUnO1xuaW1wb3J0IEdMIGZyb20gJ2x1bWEuZ2wvY29uc3RhbnRzJztcbmltcG9ydCB7TW9kZWwsIEdlb21ldHJ5LCBsb2FkVGV4dHVyZXMsIFRleHR1cmUyRCwgZnA2NH0gZnJvbSAnbHVtYS5nbCc7XG5jb25zdCB7ZnA2NExvd1BhcnR9ID0gZnA2NDtcblxuaW1wb3J0IHZzIGZyb20gJy4vbWVzaC1sYXllci12ZXJ0ZXguZ2xzbCc7XG5pbXBvcnQgZnMgZnJvbSAnLi9tZXNoLWxheWVyLWZyYWdtZW50Lmdsc2wnO1xuXG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmNvbnN0IFJBRElBTl9QRVJfREVHUkVFID0gTWF0aC5QSSAvIDE4MDtcblxuLypcbiAqIExvYWQgaW1hZ2UgZGF0YSBpbnRvIGx1bWEuZ2wgVGV4dHVyZTJEIG9iamVjdHNcbiAqIEBwYXJhbSB7V2ViR0xDb250ZXh0fSBnbFxuICogQHBhcmFtIHtTdHJpbmd8VGV4dHVyZTJEfEhUTUxJbWFnZUVsZW1lbnR8VWludDhDbGFtcGVkQXJyYXl9IHNyYyAtIHNvdXJjZSBvZiBpbWFnZSBkYXRhXG4gKiAgIGNhbiBiZSB1cmwgc3RyaW5nLCBUZXh0dXJlMkQgb2JqZWN0LCBIVE1MSW1hZ2VFbGVtZW50IG9yIHBpeGVsIGFycmF5XG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gcmVzb2x2ZXMgdG8gYW4gb2JqZWN0IHdpdGggbmFtZSAtPiB0ZXh0dXJlIG1hcHBpbmdcbiAqL1xuZnVuY3Rpb24gZ2V0VGV4dHVyZShnbCwgc3JjLCBvcHRzKSB7XG4gIGlmICh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJykge1xuICAgIC8vIFVybCwgbG9hZCB0aGUgaW1hZ2VcbiAgICByZXR1cm4gbG9hZFRleHR1cmVzKGdsLCBPYmplY3QuYXNzaWduKHt1cmxzOiBbc3JjXX0sIG9wdHMpKVxuICAgICAgLnRoZW4odGV4dHVyZXMgPT4gdGV4dHVyZXNbMF0pXG4gICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBsb2FkIHRleHR1cmUgZnJvbSAke3NyY306ICR7ZXJyb3J9YCk7XG4gICAgICB9KTtcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiByZXNvbHZlKGdldFRleHR1cmVGcm9tRGF0YShnbCwgc3JjLCBvcHRzKSkpO1xufVxuXG4vKlxuICogQ29udmVydCBpbWFnZSBkYXRhIGludG8gdGV4dHVyZVxuICogQHJldHVybnMge1RleHR1cmUyRH0gdGV4dHVyZVxuICovXG5mdW5jdGlvbiBnZXRUZXh0dXJlRnJvbURhdGEoZ2wsIGRhdGEsIG9wdHMpIHtcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBUZXh0dXJlMkQpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICByZXR1cm4gbmV3IFRleHR1cmUyRChnbCwgT2JqZWN0LmFzc2lnbih7ZGF0YX0sIG9wdHMpKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVHZW9tZXRyeUF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICBhc3NlcnQoYXR0cmlidXRlcy5wb3NpdGlvbnMgJiYgYXR0cmlidXRlcy5ub3JtYWxzICYmIGF0dHJpYnV0ZXMudGV4Q29vcmRzKTtcbn1cblxuLypcbiAqIENvbnZlcnQgbWVzaCBkYXRhIGludG8gZ2VvbWV0cnlcbiAqIEByZXR1cm5zIHtHZW9tZXRyeX0gZ2VvbWV0cnlcbiAqL1xuZnVuY3Rpb24gZ2V0R2VvbWV0cnkoZGF0YSkge1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIEdlb21ldHJ5KSB7XG4gICAgdmFsaWRhdGVHZW9tZXRyeUF0dHJpYnV0ZXMoZGF0YS5hdHRyaWJ1dGVzKTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfSBlbHNlIGlmIChkYXRhLnBvc2l0aW9ucykge1xuICAgIHZhbGlkYXRlR2VvbWV0cnlBdHRyaWJ1dGVzKGRhdGEpO1xuICAgIHJldHVybiBuZXcgR2VvbWV0cnkoe1xuICAgICAgYXR0cmlidXRlczogZGF0YVxuICAgIH0pO1xuICB9XG4gIHRocm93IEVycm9yKCdJbnZhbGlkIG1lc2gnKTtcbn1cblxuY29uc3QgREVGQVVMVF9DT0xPUiA9IFswLCAwLCAwLCAyNTVdO1xuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBtZXNoOiBudWxsLFxuICB0ZXh0dXJlOiBudWxsLFxuICBzaXplU2NhbGU6IDEsXG5cbiAgLy8gVE9ETyAtIHBhcmFtZXRlcnMgc2hvdWxkIGJlIG1lcmdlZCwgbm90IGNvbXBsZXRlbHkgb3ZlcnJpZGRlblxuICBwYXJhbWV0ZXJzOiB7XG4gICAgZGVwdGhUZXN0OiB0cnVlLFxuICAgIGRlcHRoRnVuYzogR0wuTEVRVUFMXG4gIH0sXG4gIGZwNjQ6IGZhbHNlLFxuICAvLyBPcHRpb25hbCBzZXR0aW5ncyBmb3IgJ2xpZ2h0aW5nJyBzaGFkZXIgbW9kdWxlXG4gIGxpZ2h0U2V0dGluZ3M6IHt9LFxuXG4gIGdldFBvc2l0aW9uOiB4ID0+IHgucG9zaXRpb24sXG4gIGdldENvbG9yOiB4ID0+IHguY29sb3IgfHwgREVGQVVMVF9DT0xPUixcblxuICAvLyB5YXcsIHBpdGNoIGFuZCByb2xsIGFyZSBpbiBkZWdyZWVzXG4gIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V1bGVyX2FuZ2xlc1xuICBnZXRZYXc6IHggPT4geC55YXcgfHwgeC5hbmdsZSB8fCAwLFxuICBnZXRQaXRjaDogeCA9PiB4LnBpdGNoIHx8IDAsXG4gIGdldFJvbGw6IHggPT4geC5yb2xsIHx8IDBcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lc2hMYXllciBleHRlbmRzIExheWVyIHtcbiAgZ2V0U2hhZGVycygpIHtcbiAgICBjb25zdCBwcm9qZWN0TW9kdWxlID0gdGhpcy51c2U2NGJpdFByb2plY3Rpb24oKSA/ICdwcm9qZWN0NjQnIDogJ3Byb2plY3QzMic7XG4gICAgcmV0dXJuIHt2cywgZnMsIG1vZHVsZXM6IFtwcm9qZWN0TW9kdWxlLCAnbGlnaHRpbmcnLCAncGlja2luZyddfTtcbiAgfVxuXG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVNYW5hZ2VyID0gdGhpcy5nZXRBdHRyaWJ1dGVNYW5hZ2VyKCk7XG4gICAgYXR0cmlidXRlTWFuYWdlci5hZGRJbnN0YW5jZWQoe1xuICAgICAgaW5zdGFuY2VQb3NpdGlvbnM6IHtcbiAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgYWNjZXNzb3I6ICdnZXRQb3NpdGlvbicsXG4gICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9uc1xuICAgICAgfSxcbiAgICAgIGluc3RhbmNlUG9zaXRpb25zNjR4eToge1xuICAgICAgICBzaXplOiAyLFxuICAgICAgICBhY2Nlc3NvcjogJ2dldFBvc2l0aW9uJyxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zNjR4eUxvd1xuICAgICAgfSxcbiAgICAgIGluc3RhbmNlUm90YXRpb25zOiB7XG4gICAgICAgIHNpemU6IDMsXG4gICAgICAgIGFjY2Vzc29yOiBbJ2dldFlhdycsICdnZXRQaXRjaCcsICdnZXRSb2xsJ10sXG4gICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVJvdGF0aW9uc1xuICAgICAgfSxcbiAgICAgIGluc3RhbmNlQ29sb3JzOiB7c2l6ZTogNCwgYWNjZXNzb3I6ICdnZXRDb2xvcicsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZUNvbG9yc31cbiAgICB9KTtcblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgLy8gQXZvaWQgbHVtYS5nbCdzIG1pc3NpbmcgdW5pZm9ybSB3YXJuaW5nXG4gICAgICAvLyBUT0RPIC0gYWRkIGZlYXR1cmUgdG8gbHVtYS5nbCB0byBzcGVjaWZ5IGlnbm9yZWQgdW5pZm9ybXM/XG4gICAgICBlbXB0eVRleHR1cmU6IG5ldyBUZXh0dXJlMkQodGhpcy5jb250ZXh0LmdsLCB7XG4gICAgICAgIGRhdGE6IG5ldyBVaW50OEFycmF5KDQpLFxuICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgaGVpZ2h0OiAxXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG5cbiAgdXBkYXRlU3RhdGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KSB7XG4gICAgY29uc3QgYXR0cmlidXRlTWFuYWdlciA9IHRoaXMuZ2V0QXR0cmlidXRlTWFuYWdlcigpO1xuXG4gICAgLy8gc3VwZXIudXBkYXRlU3RhdGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KTtcbiAgICBpZiAoY2hhbmdlRmxhZ3MuZGF0YUNoYW5nZWQpIHtcbiAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZUFsbCgpO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUZQNjQocHJvcHMsIG9sZFByb3BzKTtcblxuICAgIGlmIChwcm9wcy50ZXh0dXJlICE9PSBvbGRQcm9wcy50ZXh0dXJlKSB7XG4gICAgICB0aGlzLnNldFRleHR1cmUocHJvcHMudGV4dHVyZSk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZUZQNjQocHJvcHMsIG9sZFByb3BzKSB7XG4gICAgaWYgKHByb3BzLmZwNjQgIT09IG9sZFByb3BzLmZwNjQpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLm1vZGVsKSB7XG4gICAgICAgIHRoaXMuc3RhdGUubW9kZWwuZGVsZXRlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoe21vZGVsOiB0aGlzLmdldE1vZGVsKHRoaXMuY29udGV4dC5nbCl9KTtcblxuICAgICAgdGhpcy5zZXRUZXh0dXJlKHRoaXMuc3RhdGUudGV4dHVyZSk7XG5cbiAgICAgIGNvbnN0IGF0dHJpYnV0ZU1hbmFnZXIgPSB0aGlzLmdldEF0dHJpYnV0ZU1hbmFnZXIoKTtcbiAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZUFsbCgpO1xuICAgIH1cbiAgfVxuXG4gIGRyYXcoe3VuaWZvcm1zfSkge1xuICAgIGNvbnN0IHtzaXplU2NhbGV9ID0gdGhpcy5wcm9wcztcblxuICAgIHRoaXMuc3RhdGUubW9kZWwucmVuZGVyKFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwgdW5pZm9ybXMsIHtcbiAgICAgICAgc2l6ZVNjYWxlXG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBnZXRNb2RlbChnbCkge1xuICAgIHJldHVybiBuZXcgTW9kZWwoXG4gICAgICBnbCxcbiAgICAgIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZ2V0U2hhZGVycygpLCB7XG4gICAgICAgIGlkOiB0aGlzLnByb3BzLmlkLFxuICAgICAgICBnZW9tZXRyeTogZ2V0R2VvbWV0cnkodGhpcy5wcm9wcy5tZXNoKSxcbiAgICAgICAgaXNJbnN0YW5jZWQ6IHRydWUsXG4gICAgICAgIHNoYWRlckNhY2hlOiB0aGlzLmNvbnRleHQuc2hhZGVyQ2FjaGVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHNldFRleHR1cmUoc3JjKSB7XG4gICAgY29uc3Qge2dsfSA9IHRoaXMuY29udGV4dDtcbiAgICBjb25zdCB7bW9kZWwsIGVtcHR5VGV4dHVyZX0gPSB0aGlzLnN0YXRlO1xuXG4gICAgaWYgKHNyYykge1xuICAgICAgZ2V0VGV4dHVyZShnbCwgc3JjKS50aGVuKHRleHR1cmUgPT4ge1xuICAgICAgICBtb2RlbC5zZXRVbmlmb3Jtcyh7c2FtcGxlcjogdGV4dHVyZSwgaGFzVGV4dHVyZTogMX0pO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHt0ZXh0dXJlfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVzZXRcbiAgICAgIHRoaXMuc3RhdGUubW9kZWwuc2V0VW5pZm9ybXMoe3NhbXBsZXI6IGVtcHR5VGV4dHVyZSwgaGFzVGV4dHVyZTogMH0pO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7dGV4dHVyZTogbnVsbH0pO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhLCBnZXRQb3NpdGlvbn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHt2YWx1ZSwgc2l6ZX0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3QgcG9pbnQgb2YgZGF0YSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRQb3NpdGlvbihwb2ludCk7XG4gICAgICB2YWx1ZVtpXSA9IHBvc2l0aW9uWzBdO1xuICAgICAgdmFsdWVbaSArIDFdID0gcG9zaXRpb25bMV07XG4gICAgICB2YWx1ZVtpICsgMl0gPSBwb3NpdGlvblsyXSB8fCAwO1xuICAgICAgaSArPSBzaXplO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zNjR4eUxvdyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCBpc0ZQNjQgPSB0aGlzLnVzZTY0Yml0UG9zaXRpb25zKCk7XG4gICAgYXR0cmlidXRlLmNvbnN0YW50ID0gIWlzRlA2NDtcblxuICAgIGlmICghaXNGUDY0KSB7XG4gICAgICBhdHRyaWJ1dGUudmFsdWUgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtkYXRhLCBnZXRQb3NpdGlvbn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHt2YWx1ZX0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3QgcG9pbnQgb2YgZGF0YSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRQb3NpdGlvbihwb2ludCk7XG4gICAgICB2YWx1ZVtpKytdID0gZnA2NExvd1BhcnQocG9zaXRpb25bMF0pO1xuICAgICAgdmFsdWVbaSsrXSA9IGZwNjRMb3dQYXJ0KHBvc2l0aW9uWzFdKTtcbiAgICB9XG4gIH1cblxuICAvLyB5YXcoeiksIHBpdGNoKHkpIGFuZCByb2xsKHgpIGluIHJhZGlhbnNcbiAgY2FsY3VsYXRlSW5zdGFuY2VSb3RhdGlvbnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldFlhdywgZ2V0UGl0Y2gsIGdldFJvbGx9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmFsdWUsIHNpemV9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IHBvaW50IG9mIGRhdGEpIHtcbiAgICAgIHZhbHVlW2krK10gPSBnZXRSb2xsKHBvaW50KSAqIFJBRElBTl9QRVJfREVHUkVFO1xuICAgICAgdmFsdWVbaSsrXSA9IGdldFBpdGNoKHBvaW50KSAqIFJBRElBTl9QRVJfREVHUkVFO1xuICAgICAgdmFsdWVbaSsrXSA9IGdldFlhdyhwb2ludCkgKiBSQURJQU5fUEVSX0RFR1JFRTtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZUNvbG9ycyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7ZGF0YSwgZ2V0Q29sb3J9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmFsdWV9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IHBvaW50IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gZ2V0Q29sb3IocG9pbnQpIHx8IERFRkFVTFRfQ09MT1I7XG4gICAgICB2YWx1ZVtpKytdID0gY29sb3JbMF07XG4gICAgICB2YWx1ZVtpKytdID0gY29sb3JbMV07XG4gICAgICB2YWx1ZVtpKytdID0gY29sb3JbMl07XG4gICAgICB2YWx1ZVtpKytdID0gaXNOYU4oY29sb3JbM10pID8gMjU1IDogY29sb3JbM107XG4gICAgfVxuICB9XG59XG5cbk1lc2hMYXllci5sYXllck5hbWUgPSAnTWVzaExheWVyJztcbk1lc2hMYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4iXX0=