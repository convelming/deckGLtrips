function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

import { CompositeLayer, COORDINATE_SYSTEM } from '@deck.gl/core';
import { ScatterplotLayer } from '@deck.gl/layers';
import PathOutlineLayer from '../path-outline-layer/path-outline-layer';
import MeshLayer from '../mesh-layer/mesh-layer';
import Arrow2DGeometry from './arrow-2d-geometry';
import createPathMarkers from './create-path-markers';
import { getClosestPointOnPolyline } from './polyline';
const DISTANCE_FOR_MULTI_ARROWS = 0.1;
const ARROW_HEAD_SIZE = 0.2;
const ARROW_TAIL_WIDTH = 0.05; // const ARROW_CENTER_ADJUST = -0.8;

const DEFAULT_MARKER_LAYER = MeshLayer;
const DEFAULT_MARKER_LAYER_PROPS = {
  mesh: new Arrow2DGeometry({
    headSize: ARROW_HEAD_SIZE,
    tailWidth: ARROW_TAIL_WIDTH
  })
};
const defaultProps = Object.assign({}, PathOutlineLayer.defaultProps, {
  MarkerLayer: DEFAULT_MARKER_LAYER,
  markerLayerProps: DEFAULT_MARKER_LAYER_PROPS,
  sizeScale: 100,
  fp64: false,
  hightlightIndex: -1,
  highlightPoint: null,
  getPath: x => x.path,
  getColor: x => x.color,
  getMarkerColor: x => [0, 0, 0, 255],
  getDirection: x => x.direction,
  getMarkerPercentages: (object, {
    lineLength
  }) => lineLength > DISTANCE_FOR_MULTI_ARROWS ? [0.25, 0.5, 0.75] : [0.5]
});
export default class PathMarkerLayer extends CompositeLayer {
  initializeState() {
    this.state = {
      markers: [],
      mesh: new Arrow2DGeometry({
        headSize: ARROW_HEAD_SIZE,
        tailWidth: ARROW_TAIL_WIDTH
      }),
      closestPoint: null
    };
  }

  projectFlat(xyz, viewport, coordinateSystem, coordinateOrigin) {
    if (coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS) {
      const _viewport$metersToLng = viewport.metersToLngLatDelta(xyz),
            _viewport$metersToLng2 = _slicedToArray(_viewport$metersToLng, 2),
            dx = _viewport$metersToLng2[0],
            dy = _viewport$metersToLng2[1];

      const _coordinateOrigin = _slicedToArray(coordinateOrigin, 2),
            x = _coordinateOrigin[0],
            y = _coordinateOrigin[1];

      return viewport.projectFlat([x + dx, dy + y]);
    } else if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS) {
      const _xyz = _slicedToArray(xyz, 2),
            dx = _xyz[0],
            dy = _xyz[1];

      const _coordinateOrigin2 = _slicedToArray(coordinateOrigin, 2),
            x = _coordinateOrigin2[0],
            y = _coordinateOrigin2[1];

      return viewport.projectFlat([x + dx, dy + y]);
    }

    return viewport.projectFlat(xyz);
  }

  updateState({
    props,
    oldProps,
    changeFlags
  }) {
    if (changeFlags.dataChanged || changeFlags.updateTriggersChanged) {
      const _this$props = this.props,
            data = _this$props.data,
            getPath = _this$props.getPath,
            getDirection = _this$props.getDirection,
            getMarkerColor = _this$props.getMarkerColor,
            getMarkerPercentages = _this$props.getMarkerPercentages,
            coordinateSystem = _this$props.coordinateSystem,
            coordinateOrigin = _this$props.coordinateOrigin;
      const viewport = this.context.viewport;

      const projectFlat = o => this.projectFlat(o, viewport, coordinateSystem, coordinateOrigin);

      this.state.markers = createPathMarkers({
        data,
        getPath,
        getDirection,
        getColor: getMarkerColor,
        getMarkerPercentages,
        projectFlat
      });

      this._recalculateClosestPoint();
    }

    if (changeFlags.propsChanged) {
      if (props.point !== oldProps.point) {
        this._recalculateClosestPoint();
      }
    }
  }

  _recalculateClosestPoint() {
    const _this$props2 = this.props,
          highlightPoint = _this$props2.highlightPoint,
          highlightIndex = _this$props2.highlightIndex;

    if (highlightPoint && highlightIndex >= 0) {
      const object = this.props.data[highlightIndex];
      const points = this.props.getPath(object);

      const _getClosestPointOnPol = getClosestPointOnPolyline({
        points,
        p: highlightPoint
      }),
            point = _getClosestPointOnPol.point;

      this.state.closestPoints = [{
        position: point
      }];
    } else {
      this.state.closestPoints = [];
    }
  }

  getPickingInfo({
    info
  }) {
    return Object.assign(info, {
      // override object with picked feature
      object: info.object && info.object.path || info.object
    });
  }

  renderLayers() {
    return [new PathOutlineLayer(this.props, this.getSubLayerProps({
      id: 'paths',
      // Note: data has to be passed explicitly like this to avoid being empty
      data: this.props.data
    })), new this.props.MarkerLayer(this.getSubLayerProps(Object.assign({}, this.props.markerLayerProps, {
      id: 'markers',
      data: this.state.markers,
      sizeScale: this.props.sizeScale,
      fp64: this.props.fp64,
      pickable: false,
      parameters: {
        blend: false,
        depthTest: false
      }
    }))), this.state.closestPoints && new ScatterplotLayer({
      id: `${this.props.id}-highlight`,
      data: this.state.closestPoints,
      fp64: this.props.fp64
    })];
  }

}
PathMarkerLayer.layerName = 'PathMarkerLayer';
PathMarkerLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wYXRoLW1hcmtlci1sYXllci9wYXRoLW1hcmtlci1sYXllci5qcyJdLCJuYW1lcyI6WyJDb21wb3NpdGVMYXllciIsIkNPT1JESU5BVEVfU1lTVEVNIiwiU2NhdHRlcnBsb3RMYXllciIsIlBhdGhPdXRsaW5lTGF5ZXIiLCJNZXNoTGF5ZXIiLCJBcnJvdzJER2VvbWV0cnkiLCJjcmVhdGVQYXRoTWFya2VycyIsImdldENsb3Nlc3RQb2ludE9uUG9seWxpbmUiLCJESVNUQU5DRV9GT1JfTVVMVElfQVJST1dTIiwiQVJST1dfSEVBRF9TSVpFIiwiQVJST1dfVEFJTF9XSURUSCIsIkRFRkFVTFRfTUFSS0VSX0xBWUVSIiwiREVGQVVMVF9NQVJLRVJfTEFZRVJfUFJPUFMiLCJtZXNoIiwiaGVhZFNpemUiLCJ0YWlsV2lkdGgiLCJkZWZhdWx0UHJvcHMiLCJPYmplY3QiLCJhc3NpZ24iLCJNYXJrZXJMYXllciIsIm1hcmtlckxheWVyUHJvcHMiLCJzaXplU2NhbGUiLCJmcDY0IiwiaGlnaHRsaWdodEluZGV4IiwiaGlnaGxpZ2h0UG9pbnQiLCJnZXRQYXRoIiwieCIsInBhdGgiLCJnZXRDb2xvciIsImNvbG9yIiwiZ2V0TWFya2VyQ29sb3IiLCJnZXREaXJlY3Rpb24iLCJkaXJlY3Rpb24iLCJnZXRNYXJrZXJQZXJjZW50YWdlcyIsIm9iamVjdCIsImxpbmVMZW5ndGgiLCJQYXRoTWFya2VyTGF5ZXIiLCJpbml0aWFsaXplU3RhdGUiLCJzdGF0ZSIsIm1hcmtlcnMiLCJjbG9zZXN0UG9pbnQiLCJwcm9qZWN0RmxhdCIsInh5eiIsInZpZXdwb3J0IiwiY29vcmRpbmF0ZVN5c3RlbSIsImNvb3JkaW5hdGVPcmlnaW4iLCJNRVRFUl9PRkZTRVRTIiwibWV0ZXJzVG9MbmdMYXREZWx0YSIsImR4IiwiZHkiLCJ5IiwiTE5HTEFUX09GRlNFVFMiLCJ1cGRhdGVTdGF0ZSIsInByb3BzIiwib2xkUHJvcHMiLCJjaGFuZ2VGbGFncyIsImRhdGFDaGFuZ2VkIiwidXBkYXRlVHJpZ2dlcnNDaGFuZ2VkIiwiZGF0YSIsImNvbnRleHQiLCJvIiwiX3JlY2FsY3VsYXRlQ2xvc2VzdFBvaW50IiwicHJvcHNDaGFuZ2VkIiwicG9pbnQiLCJoaWdobGlnaHRJbmRleCIsInBvaW50cyIsInAiLCJjbG9zZXN0UG9pbnRzIiwicG9zaXRpb24iLCJnZXRQaWNraW5nSW5mbyIsImluZm8iLCJyZW5kZXJMYXllcnMiLCJnZXRTdWJMYXllclByb3BzIiwiaWQiLCJwaWNrYWJsZSIsInBhcmFtZXRlcnMiLCJibGVuZCIsImRlcHRoVGVzdCIsImxheWVyTmFtZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxTQUFRQSxjQUFSLEVBQXdCQyxpQkFBeEIsUUFBZ0QsZUFBaEQ7QUFDQSxTQUFRQyxnQkFBUixRQUErQixpQkFBL0I7QUFDQSxPQUFPQyxnQkFBUCxNQUE2QiwwQ0FBN0I7QUFDQSxPQUFPQyxTQUFQLE1BQXNCLDBCQUF0QjtBQUNBLE9BQU9DLGVBQVAsTUFBNEIscUJBQTVCO0FBRUEsT0FBT0MsaUJBQVAsTUFBOEIsdUJBQTlCO0FBQ0EsU0FBUUMseUJBQVIsUUFBd0MsWUFBeEM7QUFFQSxNQUFNQyx5QkFBeUIsR0FBRyxHQUFsQztBQUNBLE1BQU1DLGVBQWUsR0FBRyxHQUF4QjtBQUNBLE1BQU1DLGdCQUFnQixHQUFHLElBQXpCLEMsQ0FDQTs7QUFFQSxNQUFNQyxvQkFBb0IsR0FBR1AsU0FBN0I7QUFFQSxNQUFNUSwwQkFBMEIsR0FBRztBQUNqQ0MsRUFBQUEsSUFBSSxFQUFFLElBQUlSLGVBQUosQ0FBb0I7QUFBQ1MsSUFBQUEsUUFBUSxFQUFFTCxlQUFYO0FBQTRCTSxJQUFBQSxTQUFTLEVBQUVMO0FBQXZDLEdBQXBCO0FBRDJCLENBQW5DO0FBSUEsTUFBTU0sWUFBWSxHQUFHQyxNQUFNLENBQUNDLE1BQVAsQ0FBYyxFQUFkLEVBQWtCZixnQkFBZ0IsQ0FBQ2EsWUFBbkMsRUFBaUQ7QUFDcEVHLEVBQUFBLFdBQVcsRUFBRVIsb0JBRHVEO0FBRXBFUyxFQUFBQSxn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QUFBQSxJQUFJLEVBQUUsS0FBSytCLEtBQUwsQ0FBVy9CLElBSjRCO0FBSzdDb0QsTUFBQUEsUUFBUSxFQUFFLEtBTG1DO0FBTTdDQyxNQUFBQSxVQUFVLEVBQUU7QUFDVkMsUUFBQUEsS0FBSyxFQUFFLEtBREc7QUFFVkMsUUFBQUEsU0FBUyxFQUFFO0FBRkQ7QUFOaUMsS0FBL0MsQ0FERixDQURGLENBVEssRUF3QkwsS0FBS3ZDLEtBQUwsQ0FBVzZCLGFBQVgsSUFDRSxJQUFJakUsZ0JBQUosQ0FBcUI7QUFDbkJ1RSxNQUFBQSxFQUFFLEVBQUcsR0FBRSxLQUFLcEIsS0FBTCxDQUFXb0IsRUFBRyxZQURGO0FBRW5CZixNQUFBQSxJQUFJLEVBQUUsS0FBS3BCLEtBQUwsQ0FBVzZCLGFBRkU7QUFHbkI3QyxNQUFBQSxJQUFJLEVBQUUsS0FBSytCLEtBQUwsQ0FBVy9CO0FBSEUsS0FBckIsQ0F6QkcsQ0FBUDtBQStCRDs7QUE1R3lEO0FBK0c1RGMsZUFBZSxDQUFDMEMsU0FBaEIsR0FBNEIsaUJBQTVCO0FBQ0ExQyxlQUFlLENBQUNwQixZQUFoQixHQUErQkEsWUFBL0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0NvbXBvc2l0ZUxheWVyLCBDT09SRElOQVRFX1NZU1RFTX0gZnJvbSAnQGRlY2suZ2wvY29yZSc7XG5pbXBvcnQge1NjYXR0ZXJwbG90TGF5ZXJ9IGZyb20gJ0BkZWNrLmdsL2xheWVycyc7XG5pbXBvcnQgUGF0aE91dGxpbmVMYXllciBmcm9tICcuLi9wYXRoLW91dGxpbmUtbGF5ZXIvcGF0aC1vdXRsaW5lLWxheWVyJztcbmltcG9ydCBNZXNoTGF5ZXIgZnJvbSAnLi4vbWVzaC1sYXllci9tZXNoLWxheWVyJztcbmltcG9ydCBBcnJvdzJER2VvbWV0cnkgZnJvbSAnLi9hcnJvdy0yZC1nZW9tZXRyeSc7XG5cbmltcG9ydCBjcmVhdGVQYXRoTWFya2VycyBmcm9tICcuL2NyZWF0ZS1wYXRoLW1hcmtlcnMnO1xuaW1wb3J0IHtnZXRDbG9zZXN0UG9pbnRPblBvbHlsaW5lfSBmcm9tICcuL3BvbHlsaW5lJztcblxuY29uc3QgRElTVEFOQ0VfRk9SX01VTFRJX0FSUk9XUyA9IDAuMTtcbmNvbnN0IEFSUk9XX0hFQURfU0laRSA9IDAuMjtcbmNvbnN0IEFSUk9XX1RBSUxfV0lEVEggPSAwLjA1O1xuLy8gY29uc3QgQVJST1dfQ0VOVEVSX0FESlVTVCA9IC0wLjg7XG5cbmNvbnN0IERFRkFVTFRfTUFSS0VSX0xBWUVSID0gTWVzaExheWVyO1xuXG5jb25zdCBERUZBVUxUX01BUktFUl9MQVlFUl9QUk9QUyA9IHtcbiAgbWVzaDogbmV3IEFycm93MkRHZW9tZXRyeSh7aGVhZFNpemU6IEFSUk9XX0hFQURfU0laRSwgdGFpbFdpZHRoOiBBUlJPV19UQUlMX1dJRFRIfSlcbn07XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIFBhdGhPdXRsaW5lTGF5ZXIuZGVmYXVsdFByb3BzLCB7XG4gIE1hcmtlckxheWVyOiBERUZBVUxUX01BUktFUl9MQVlFUixcbiAgbWFya2VyTGF5ZXJQcm9wczogREVGQVVMVF9NQVJLRVJfTEFZRVJfUFJPUFMsXG5cbiAgc2l6ZVNjYWxlOiAxMDAsXG4gIGZwNjQ6IGZhbHNlLFxuXG4gIGhpZ2h0bGlnaHRJbmRleDogLTEsXG4gIGhpZ2hsaWdodFBvaW50OiBudWxsLFxuXG4gIGdldFBhdGg6IHggPT4geC5wYXRoLFxuICBnZXRDb2xvcjogeCA9PiB4LmNvbG9yLFxuICBnZXRNYXJrZXJDb2xvcjogeCA9PiBbMCwgMCwgMCwgMjU1XSxcbiAgZ2V0RGlyZWN0aW9uOiB4ID0+IHguZGlyZWN0aW9uLFxuICBnZXRNYXJrZXJQZXJjZW50YWdlczogKG9iamVjdCwge2xpbmVMZW5ndGh9KSA9PlxuICAgIGxpbmVMZW5ndGggPiBESVNUQU5DRV9GT1JfTVVMVElfQVJST1dTID8gWzAuMjUsIDAuNSwgMC43NV0gOiBbMC41XVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhdGhNYXJrZXJMYXllciBleHRlbmRzIENvbXBvc2l0ZUxheWVyIHtcbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBtYXJrZXJzOiBbXSxcbiAgICAgIG1lc2g6IG5ldyBBcnJvdzJER2VvbWV0cnkoe2hlYWRTaXplOiBBUlJPV19IRUFEX1NJWkUsIHRhaWxXaWR0aDogQVJST1dfVEFJTF9XSURUSH0pLFxuICAgICAgY2xvc2VzdFBvaW50OiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIHByb2plY3RGbGF0KHh5eiwgdmlld3BvcnQsIGNvb3JkaW5hdGVTeXN0ZW0sIGNvb3JkaW5hdGVPcmlnaW4pIHtcbiAgICBpZiAoY29vcmRpbmF0ZVN5c3RlbSA9PT0gQ09PUkRJTkFURV9TWVNURU0uTUVURVJfT0ZGU0VUUykge1xuICAgICAgY29uc3QgW2R4LCBkeV0gPSB2aWV3cG9ydC5tZXRlcnNUb0xuZ0xhdERlbHRhKHh5eik7XG4gICAgICBjb25zdCBbeCwgeV0gPSBjb29yZGluYXRlT3JpZ2luO1xuICAgICAgcmV0dXJuIHZpZXdwb3J0LnByb2plY3RGbGF0KFt4ICsgZHgsIGR5ICsgeV0pO1xuICAgIH0gZWxzZSBpZiAoY29vcmRpbmF0ZVN5c3RlbSA9PT0gQ09PUkRJTkFURV9TWVNURU0uTE5HTEFUX09GRlNFVFMpIHtcbiAgICAgIGNvbnN0IFtkeCwgZHldID0geHl6O1xuICAgICAgY29uc3QgW3gsIHldID0gY29vcmRpbmF0ZU9yaWdpbjtcbiAgICAgIHJldHVybiB2aWV3cG9ydC5wcm9qZWN0RmxhdChbeCArIGR4LCBkeSArIHldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmlld3BvcnQucHJvamVjdEZsYXQoeHl6KTtcbiAgfVxuXG4gIHVwZGF0ZVN0YXRlKHtwcm9wcywgb2xkUHJvcHMsIGNoYW5nZUZsYWdzfSkge1xuICAgIGlmIChjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCB8fCBjaGFuZ2VGbGFncy51cGRhdGVUcmlnZ2Vyc0NoYW5nZWQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgZ2V0UGF0aCxcbiAgICAgICAgZ2V0RGlyZWN0aW9uLFxuICAgICAgICBnZXRNYXJrZXJDb2xvcixcbiAgICAgICAgZ2V0TWFya2VyUGVyY2VudGFnZXMsXG4gICAgICAgIGNvb3JkaW5hdGVTeXN0ZW0sXG4gICAgICAgIGNvb3JkaW5hdGVPcmlnaW5cbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgY29uc3Qge3ZpZXdwb3J0fSA9IHRoaXMuY29udGV4dDtcbiAgICAgIGNvbnN0IHByb2plY3RGbGF0ID0gbyA9PiB0aGlzLnByb2plY3RGbGF0KG8sIHZpZXdwb3J0LCBjb29yZGluYXRlU3lzdGVtLCBjb29yZGluYXRlT3JpZ2luKTtcbiAgICAgIHRoaXMuc3RhdGUubWFya2VycyA9IGNyZWF0ZVBhdGhNYXJrZXJzKHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgZ2V0UGF0aCxcbiAgICAgICAgZ2V0RGlyZWN0aW9uLFxuICAgICAgICBnZXRDb2xvcjogZ2V0TWFya2VyQ29sb3IsXG4gICAgICAgIGdldE1hcmtlclBlcmNlbnRhZ2VzLFxuICAgICAgICBwcm9qZWN0RmxhdFxuICAgICAgfSk7XG4gICAgICB0aGlzLl9yZWNhbGN1bGF0ZUNsb3Nlc3RQb2ludCgpO1xuICAgIH1cbiAgICBpZiAoY2hhbmdlRmxhZ3MucHJvcHNDaGFuZ2VkKSB7XG4gICAgICBpZiAocHJvcHMucG9pbnQgIT09IG9sZFByb3BzLnBvaW50KSB7XG4gICAgICAgIHRoaXMuX3JlY2FsY3VsYXRlQ2xvc2VzdFBvaW50KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3JlY2FsY3VsYXRlQ2xvc2VzdFBvaW50KCkge1xuICAgIGNvbnN0IHtoaWdobGlnaHRQb2ludCwgaGlnaGxpZ2h0SW5kZXh9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoaGlnaGxpZ2h0UG9pbnQgJiYgaGlnaGxpZ2h0SW5kZXggPj0gMCkge1xuICAgICAgY29uc3Qgb2JqZWN0ID0gdGhpcy5wcm9wcy5kYXRhW2hpZ2hsaWdodEluZGV4XTtcbiAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucHJvcHMuZ2V0UGF0aChvYmplY3QpO1xuICAgICAgY29uc3Qge3BvaW50fSA9IGdldENsb3Nlc3RQb2ludE9uUG9seWxpbmUoe3BvaW50cywgcDogaGlnaGxpZ2h0UG9pbnR9KTtcbiAgICAgIHRoaXMuc3RhdGUuY2xvc2VzdFBvaW50cyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHBvc2l0aW9uOiBwb2ludFxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlLmNsb3Nlc3RQb2ludHMgPSBbXTtcbiAgICB9XG4gIH1cblxuICBnZXRQaWNraW5nSW5mbyh7aW5mb30pIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihpbmZvLCB7XG4gICAgICAvLyBvdmVycmlkZSBvYmplY3Qgd2l0aCBwaWNrZWQgZmVhdHVyZVxuICAgICAgb2JqZWN0OiAoaW5mby5vYmplY3QgJiYgaW5mby5vYmplY3QucGF0aCkgfHwgaW5mby5vYmplY3RcbiAgICB9KTtcbiAgfVxuXG4gIHJlbmRlckxheWVycygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFBhdGhPdXRsaW5lTGF5ZXIoXG4gICAgICAgIHRoaXMucHJvcHMsXG4gICAgICAgIHRoaXMuZ2V0U3ViTGF5ZXJQcm9wcyh7XG4gICAgICAgICAgaWQ6ICdwYXRocycsXG4gICAgICAgICAgLy8gTm90ZTogZGF0YSBoYXMgdG8gYmUgcGFzc2VkIGV4cGxpY2l0bHkgbGlrZSB0aGlzIHRvIGF2b2lkIGJlaW5nIGVtcHR5XG4gICAgICAgICAgZGF0YTogdGhpcy5wcm9wcy5kYXRhXG4gICAgICAgIH0pXG4gICAgICApLFxuICAgICAgbmV3IHRoaXMucHJvcHMuTWFya2VyTGF5ZXIoXG4gICAgICAgIHRoaXMuZ2V0U3ViTGF5ZXJQcm9wcyhcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLm1hcmtlckxheWVyUHJvcHMsIHtcbiAgICAgICAgICAgIGlkOiAnbWFya2VycycsXG4gICAgICAgICAgICBkYXRhOiB0aGlzLnN0YXRlLm1hcmtlcnMsXG4gICAgICAgICAgICBzaXplU2NhbGU6IHRoaXMucHJvcHMuc2l6ZVNjYWxlLFxuICAgICAgICAgICAgZnA2NDogdGhpcy5wcm9wcy5mcDY0LFxuICAgICAgICAgICAgcGlja2FibGU6IGZhbHNlLFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICBibGVuZDogZmFsc2UsXG4gICAgICAgICAgICAgIGRlcHRoVGVzdDogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApLFxuICAgICAgdGhpcy5zdGF0ZS5jbG9zZXN0UG9pbnRzICYmXG4gICAgICAgIG5ldyBTY2F0dGVycGxvdExheWVyKHtcbiAgICAgICAgICBpZDogYCR7dGhpcy5wcm9wcy5pZH0taGlnaGxpZ2h0YCxcbiAgICAgICAgICBkYXRhOiB0aGlzLnN0YXRlLmNsb3Nlc3RQb2ludHMsXG4gICAgICAgICAgZnA2NDogdGhpcy5wcm9wcy5mcDY0XG4gICAgICAgIH0pXG4gICAgXTtcbiAgfVxufVxuXG5QYXRoTWFya2VyTGF5ZXIubGF5ZXJOYW1lID0gJ1BhdGhNYXJrZXJMYXllcic7XG5QYXRoTWFya2VyTGF5ZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuIl19