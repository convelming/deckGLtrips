import { Layer } from '@deck.gl/core';
import { Model, Geometry } from 'luma.gl';
import tripsVertex from './trips-layer-vertex.glsl';
import tripsFragment from './trips-layer-fragment.glsl';
const defaultProps = {
  trailLength: 120,
  currentTime: 0,
  getPath: d => d.path,
  getColor: d => d.color
};
export default class TripsLayer extends Layer {
  initializeState() {
    const gl = this.context.gl;
    const attributeManager = this.getAttributeManager();
    const model = this.getModel(gl);
    attributeManager.add({
      indices: {
        size: 1,
        update: this.calculateIndices,
        isIndexed: true
      },
      positions: {
        size: 3,
        update: this.calculatePositions
      },
      colors: {
        size: 3,
        accessor: 'getColor',
        update: this.calculateColors
      }
    });
    gl.getExtension('OES_element_index_uint');
    this.setState({
      model
    });
  }

  updateState({
    props,
    changeFlags: {
      dataChanged
    }
  }) {
    if (dataChanged) {
      this.countVertices(props.data);
      this.state.attributeManager.invalidateAll();
    }
  }

  getModel(gl) {
    return new Model(gl, {
      id: this.props.id,
      vs: tripsVertex,
      fs: tripsFragment,
      geometry: new Geometry({
        id: this.props.id,
        drawMode: 'LINES'
      }),
      vertexCount: 0,
      isIndexed: true,
      // TODO-state-management: onBeforeRender can go to settings, onAfterRender, we should
      // move this settings of corresponding draw.
      onBeforeRender: () => {
        gl.enable(gl.BLEND);
        gl.enable(gl.POLYGON_OFFSET_FILL);
        gl.polygonOffset(2.0, 1.0);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
        gl.blendEquation(gl.FUNC_ADD);
      },
      onAfterRender: () => {
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.disable(gl.POLYGON_OFFSET_FILL);
      }
    });
  }

  countVertices(data) {
    if (!data) {
      return;
    }

    const getPath = this.props.getPath;
    let vertexCount = 0;
    const pathLengths = data.reduce((acc, d) => {
      const l = getPath(d).length;
      vertexCount += l;
      return [...acc, l];
    }, []);
    this.setState({
      pathLengths,
      vertexCount
    });
  }

  draw({
    uniforms
  }) {
    const _this$props = this.props,
          trailLength = _this$props.trailLength,
          currentTime = _this$props.currentTime;
    this.state.model.render(Object.assign({}, uniforms, {
      trailLength,
      currentTime
    }));
  }

  calculateIndices(attribute) {
    const _this$state = this.state,
          pathLengths = _this$state.pathLengths,
          vertexCount = _this$state.vertexCount;
    const indicesCount = (vertexCount - pathLengths.length) * 2;
    const indices = new Uint32Array(indicesCount);
    let offset = 0;
    let index = 0;

    for (let i = 0; i < pathLengths.length; i++) {
      const l = pathLengths[i];
      indices[index++] = offset;

      for (let j = 1; j < l - 1; j++) {
        indices[index++] = j + offset;
        indices[index++] = j + offset;
      }

      indices[index++] = offset + l - 1;
      offset += l;
    }

    attribute.value = indices;
    this.state.model.setVertexCount(indicesCount);
  }

  calculatePositions(attribute) {
    const _this$props2 = this.props,
          data = _this$props2.data,
          getPath = _this$props2.getPath;
    const vertexCount = this.state.vertexCount;
    const positions = new Float32Array(vertexCount * 3);
    let index = 0;

    for (let i = 0; i < data.length; i++) {
      const path = getPath(data[i]);

      for (let j = 0; j < path.length; j++) {
        const pt = path[j];
        positions[index++] = pt[0];
        positions[index++] = pt[1];
        positions[index++] = pt[2];
      }
    }

    attribute.value = positions;
  }

  calculateColors(attribute) {
    const _this$props3 = this.props,
          data = _this$props3.data,
          getColor = _this$props3.getColor;
    const _this$state2 = this.state,
          pathLengths = _this$state2.pathLengths,
          vertexCount = _this$state2.vertexCount;
    const colors = new Float32Array(vertexCount * 3);
    let index = 0;

    for (let i = 0; i < data.length; i++) {
      const color = getColor(data[i]);
      const l = pathLengths[i];

      for (let j = 0; j < l; j++) {
        colors[index++] = color[0];
        colors[index++] = color[1];
        colors[index++] = color[2];
      }
    }

    attribute.value = colors;
  }

}
TripsLayer.layerName = 'TripsLayer';
TripsLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90cmlwcy1sYXllci90cmlwcy1sYXllci5qcyJdLCJuYW1lcyI6WyJMYXllciIsIk1vZGVsIiwiR2VvbWV0cnkiLCJ0cmlwc1ZlcnRleCIsInRyaXBzRnJhZ21lbnQiLCJkZWZhdWx0UHJvcHMiLCJ0cmFpbExlbmd0aCIsImN1cnJlbnRUaW1lIiwiZ2V0UGF0aCIsImQiLCJwYXRoIiwiZ2V0Q29sb3IiLCJjb2xvciIsIlRyaXBzTGF5ZXIiLCJpbml0aWFsaXplU3RhdGUiLCJnbCIsImNvbnRleHQiLCJhdHRyaWJ1dGVNYW5hZ2VyIiwiZ2V0QXR0cmlidXRlTWFuYWdlciIsIm1vZGVsIiwiZ2V0TW9kZWwiLCJhZGQiLCJpbmRpY2VzIiwic2l6ZSIsInVwZGF0ZSIsImNhbGN1bGF0ZUluZGljZXMiLCJpc0luZGV4ZWQiLCJwb3NpdGlvbnMiLCJjYWxjdWxhdGVQb3NpdGlvbnMiLCJjb2xvcnMiLCJhY2Nlc3NvciIsImNhbGN1bGF0ZUNvbG9ycyIsImdldEV4dGVuc2lvbiIsInNldFN0YXRlIiwidXBkYXRlU3RhdGUiLCJwcm9wcyIsImNoYW5nZUZsYWdzIiwiZGF0YUNoYW5nZWQiLCJjb3VudFZlcnRpY2VzIiwiZGF0YSIsInN0YXRlIiwiaW52YWxpZGF0ZUFsbCIsImlkIiwidnMiLCJmcyIsImdlb21ldHJ5IiwiZHJhd01vZGUiLCJ2ZXJ0ZXhDb3VudCIsIm9uQmVmb3JlUmVuZGVyIiwiZW5hYmxlIiwiQkxFTkQiLCJQT0xZR09OX09GRlNFVF9GSUxMIiwicG9seWdvbk9mZnNldCIsImJsZW5kRnVuYyIsIlNSQ19BTFBIQSIsIk9ORSIsImJsZW5kRXF1YXRpb24iLCJGVU5DX0FERCIsIm9uQWZ0ZXJSZW5kZXIiLCJPTkVfTUlOVVNfU1JDX0FMUEhBIiwiZGlzYWJsZSIsInBhdGhMZW5ndGhzIiwicmVkdWNlIiwiYWNjIiwibCIsImxlbmd0aCIsImRyYXciLCJ1bmlmb3JtcyIsInJlbmRlciIsIk9iamVjdCIsImFzc2lnbiIsImF0dHJpYnV0ZSIsImluZGljZXNDb3VudCIsIlVpbnQzMkFycmF5Iiwib2Zmc2V0IiwiaW5kZXgiLCJpIiwiaiIsInZhbHVlIiwic2V0VmVydGV4Q291bnQiLCJGbG9hdDMyQXJyYXkiLCJwdCIsImxheWVyTmFtZSJdLCJtYXBwaW5ncyI6IkFBQUEsU0FBUUEsS0FBUixRQUFvQixlQUFwQjtBQUVBLFNBQVFDLEtBQVIsRUFBZUMsUUFBZixRQUE4QixTQUE5QjtBQUVBLE9BQU9DLFdBQVAsTUFBd0IsMkJBQXhCO0FBQ0EsT0FBT0MsYUFBUCxNQUEwQiw2QkFBMUI7QUFFQSxNQUFNQyxZQUFZLEdBQUc7QUFDbkJDLEVBQUFBLFdBQVcsRUFBRSxHQURNO0FBRW5CQyxFQUFBQSxXQUFXLEVBQUUsQ0FGTTtBQUduQkMsRUFBQUEsT0FBTyxFQUFFQyxDQUFDLElBQUlBLENBQUMsQ0FBQ0MsSUFIRztBQUluQkMsRUFBQUEsUUFBUSxFQUFFRixDQUFDLElBQUlBLENBQUMsQ0FBQ0c7QUFKRSxDQUFyQjtBQU9BLGVBQWUsTUFBTUMsVUFBTixTQUF5QmIsS0FBekIsQ0FBK0I7QUFDNUNjLEVBQUFBLGVBQWUsR0FBRztBQUFBLFVBQ1RDLEVBRFMsR0FDSCxLQUFLQyxPQURGLENBQ1RELEVBRFM7QUFFaEIsVUFBTUUsZ0JBQWdCLEdBQUcsS0FBS0MsbUJBQUwsRUFBekI7QUFFQSxVQUFNQyxLQUFLLEdBQUcsS0FBS0MsUUFBTCxDQUFjTCxFQUFkLENBQWQ7QUFFQUUsSUFBQUEsZ0JBQWdCLENBQUNJLEdBQWpCLENBQXFCO0FBQ25CQyxNQUFBQSxPQUFPLEVBQUU7QUFBQ0MsUUFBQUEsSUFBSSxFQUFFLENBQVA7QUFBVUMsUUFBQUEsTUFBTSxFQUFFLEtBQUtDLGdCQUF2QjtBQUF5Q0MsUUFBQUEsU0FBUyxFQUFFO0FBQXBELE9BRFU7QUFFbkJDLE1BQUFBLFNBQVMsRUFBRTtBQUFDSixRQUFBQSxJQUFJLEVBQUUsQ0FBUDtBQUFVQyxRQUFBQSxNQUFNLEVBQUUsS0FBS0k7QUFBdkIsT0FGUTtBQUduQkMsTUFBQUEsTUFBTSxFQUFF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QixRQUFBQSxNQUFNLENBQUM4QyxLQUFLLEVBQU4sQ0FBTixHQUFrQi9ELEtBQUssQ0FBQyxDQUFELENBQXZCO0FBQ0Q7QUFDRjs7QUFDRDJELElBQUFBLFNBQVMsQ0FBQ08sS0FBVixHQUFrQmpELE1BQWxCO0FBQ0Q7O0FBcEkyQztBQXVJOUNoQixVQUFVLENBQUNxRSxTQUFYLEdBQXVCLFlBQXZCO0FBQ0FyRSxVQUFVLENBQUNSLFlBQVgsR0FBMEJBLFlBQTFCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtMYXllcn0gZnJvbSAnQGRlY2suZ2wvY29yZSc7XG5cbmltcG9ydCB7TW9kZWwsIEdlb21ldHJ5fSBmcm9tICdsdW1hLmdsJztcblxuaW1wb3J0IHRyaXBzVmVydGV4IGZyb20gJy4vdHJpcHMtbGF5ZXItdmVydGV4Lmdsc2wnO1xuaW1wb3J0IHRyaXBzRnJhZ21lbnQgZnJvbSAnLi90cmlwcy1sYXllci1mcmFnbWVudC5nbHNsJztcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICB0cmFpbExlbmd0aDogMTIwLFxuICBjdXJyZW50VGltZTogMCxcbiAgZ2V0UGF0aDogZCA9PiBkLnBhdGgsXG4gIGdldENvbG9yOiBkID0+IGQuY29sb3Jcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyaXBzTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuICAgIGNvbnN0IGF0dHJpYnV0ZU1hbmFnZXIgPSB0aGlzLmdldEF0dHJpYnV0ZU1hbmFnZXIoKTtcblxuICAgIGNvbnN0IG1vZGVsID0gdGhpcy5nZXRNb2RlbChnbCk7XG5cbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZCh7XG4gICAgICBpbmRpY2VzOiB7c2l6ZTogMSwgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluZGljZXMsIGlzSW5kZXhlZDogdHJ1ZX0sXG4gICAgICBwb3NpdGlvbnM6IHtzaXplOiAzLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlUG9zaXRpb25zfSxcbiAgICAgIGNvbG9yczoge3NpemU6IDMsIGFjY2Vzc29yOiAnZ2V0Q29sb3InLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlQ29sb3JzfVxuICAgIH0pO1xuXG4gICAgZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfZWxlbWVudF9pbmRleF91aW50Jyk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7bW9kZWx9KTtcbiAgfVxuXG4gIHVwZGF0ZVN0YXRlKHtwcm9wcywgY2hhbmdlRmxhZ3M6IHtkYXRhQ2hhbmdlZH19KSB7XG4gICAgaWYgKGRhdGFDaGFuZ2VkKSB7XG4gICAgICB0aGlzLmNvdW50VmVydGljZXMocHJvcHMuZGF0YSk7XG4gICAgICB0aGlzLnN0YXRlLmF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZUFsbCgpO1xuICAgIH1cbiAgfVxuXG4gIGdldE1vZGVsKGdsKSB7XG4gICAgcmV0dXJuIG5ldyBNb2RlbChnbCwge1xuICAgICAgaWQ6IHRoaXMucHJvcHMuaWQsXG4gICAgICB2czogdHJpcHNWZXJ0ZXgsXG4gICAgICBmczogdHJpcHNGcmFnbWVudCxcbiAgICAgIGdlb21ldHJ5OiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICBpZDogdGhpcy5wcm9wcy5pZCxcbiAgICAgICAgZHJhd01vZGU6ICdMSU5FUydcbiAgICAgIH0pLFxuICAgICAgdmVydGV4Q291bnQ6IDAsXG4gICAgICBpc0luZGV4ZWQ6IHRydWUsXG4gICAgICAvLyBUT0RPLXN0YXRlLW1hbmFnZW1lbnQ6IG9uQmVmb3JlUmVuZGVyIGNhbiBnbyB0byBzZXR0aW5ncywgb25BZnRlclJlbmRlciwgd2Ugc2hvdWxkXG4gICAgICAvLyBtb3ZlIHRoaXMgc2V0dGluZ3Mgb2YgY29ycmVzcG9uZGluZyBkcmF3LlxuICAgICAgb25CZWZvcmVSZW5kZXI6ICgpID0+IHtcbiAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgZ2wuZW5hYmxlKGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwpO1xuICAgICAgICBnbC5wb2x5Z29uT2Zmc2V0KDIuMCwgMS4wKTtcbiAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FKTtcbiAgICAgICAgZ2wuYmxlbmRFcXVhdGlvbihnbC5GVU5DX0FERCk7XG4gICAgICB9LFxuICAgICAgb25BZnRlclJlbmRlcjogKCkgPT4ge1xuICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcbiAgICAgICAgZ2wuZGlzYWJsZShnbC5QT0xZR09OX09GRlNFVF9GSUxMKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvdW50VmVydGljZXMoZGF0YSkge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtnZXRQYXRofSA9IHRoaXMucHJvcHM7XG4gICAgbGV0IHZlcnRleENvdW50ID0gMDtcbiAgICBjb25zdCBwYXRoTGVuZ3RocyA9IGRhdGEucmVkdWNlKChhY2MsIGQpID0+IHtcbiAgICAgIGNvbnN0IGwgPSBnZXRQYXRoKGQpLmxlbmd0aDtcbiAgICAgIHZlcnRleENvdW50ICs9IGw7XG4gICAgICByZXR1cm4gWy4uLmFjYywgbF07XG4gICAgfSwgW10pO1xuICAgIHRoaXMuc2V0U3RhdGUoe3BhdGhMZW5ndGhzLCB2ZXJ0ZXhDb3VudH0pO1xuICB9XG5cbiAgZHJhdyh7dW5pZm9ybXN9KSB7XG4gICAgY29uc3Qge3RyYWlsTGVuZ3RoLCBjdXJyZW50VGltZX0gPSB0aGlzLnByb3BzO1xuICAgIHRoaXMuc3RhdGUubW9kZWwucmVuZGVyKFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwgdW5pZm9ybXMsIHtcbiAgICAgICAgdHJhaWxMZW5ndGgsXG4gICAgICAgIGN1cnJlbnRUaW1lXG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBjYWxjdWxhdGVJbmRpY2VzKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtwYXRoTGVuZ3RocywgdmVydGV4Q291bnR9ID0gdGhpcy5zdGF0ZTtcblxuICAgIGNvbnN0IGluZGljZXNDb3VudCA9ICh2ZXJ0ZXhDb3VudCAtIHBhdGhMZW5ndGhzLmxlbmd0aCkgKiAyO1xuICAgIGNvbnN0IGluZGljZXMgPSBuZXcgVWludDMyQXJyYXkoaW5kaWNlc0NvdW50KTtcblxuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoTGVuZ3Rocy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbCA9IHBhdGhMZW5ndGhzW2ldO1xuICAgICAgaW5kaWNlc1tpbmRleCsrXSA9IG9mZnNldDtcbiAgICAgIGZvciAobGV0IGogPSAxOyBqIDwgbCAtIDE7IGorKykge1xuICAgICAgICBpbmRpY2VzW2luZGV4KytdID0gaiArIG9mZnNldDtcbiAgICAgICAgaW5kaWNlc1tpbmRleCsrXSA9IGogKyBvZmZzZXQ7XG4gICAgICB9XG4gICAgICBpbmRpY2VzW2luZGV4KytdID0gb2Zmc2V0ICsgbCAtIDE7XG4gICAgICBvZmZzZXQgKz0gbDtcbiAgICB9XG4gICAgYXR0cmlidXRlLnZhbHVlID0gaW5kaWNlcztcbiAgICB0aGlzLnN0YXRlLm1vZGVsLnNldFZlcnRleENvdW50KGluZGljZXNDb3VudCk7XG4gIH1cblxuICBjYWxjdWxhdGVQb3NpdGlvbnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldFBhdGh9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmVydGV4Q291bnR9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KHZlcnRleENvdW50ICogMyk7XG5cbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGF0aCA9IGdldFBhdGgoZGF0YVtpXSk7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBhdGgubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3QgcHQgPSBwYXRoW2pdO1xuICAgICAgICBwb3NpdGlvbnNbaW5kZXgrK10gPSBwdFswXTtcbiAgICAgICAgcG9zaXRpb25zW2luZGV4KytdID0gcHRbMV07XG4gICAgICAgIHBvc2l0aW9uc1tpbmRleCsrXSA9IHB0WzJdO1xuICAgICAgfVxuICAgIH1cbiAgICBhdHRyaWJ1dGUudmFsdWUgPSBwb3NpdGlvbnM7XG4gIH1cblxuICBjYWxjdWxhdGVDb2xvcnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldENvbG9yfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3BhdGhMZW5ndGhzLCB2ZXJ0ZXhDb3VudH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkodmVydGV4Q291bnQgKiAzKTtcblxuICAgIGxldCBpbmRleCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjb2xvciA9IGdldENvbG9yKGRhdGFbaV0pO1xuICAgICAgY29uc3QgbCA9IHBhdGhMZW5ndGhzW2ldO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsOyBqKyspIHtcbiAgICAgICAgY29sb3JzW2luZGV4KytdID0gY29sb3JbMF07XG4gICAgICAgIGNvbG9yc1tpbmRleCsrXSA9IGNvbG9yWzFdO1xuICAgICAgICBjb2xvcnNbaW5kZXgrK10gPSBjb2xvclsyXTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXR0cmlidXRlLnZhbHVlID0gY29sb3JzO1xuICB9XG59XG5cblRyaXBzTGF5ZXIubGF5ZXJOYW1lID0gJ1RyaXBzTGF5ZXInO1xuVHJpcHNMYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4iXX0=