// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
import { Layer } from '@deck.gl/core';
import GL from 'luma.gl/constants';
import { Model, CubeGeometry, fp64 } from 'luma.gl';
const fp64LowPart = fp64.fp64LowPart;
import vs from './gpu-grid-cell-layer-vertex.glsl';
import fs from './gpu-grid-cell-layer-fragment.glsl';
const DEFAULT_MINCOLOR = [0, 0, 0, 255];
const DEFAULT_MAXCOLOR = [0, 255, 0, 255];
const AGGREGATION_DATA_UBO_INDEX = 0;
const defaultProps = {
  cellSize: {
    type: 'number',
    min: 0,
    max: 20,
    value: 20
  },
  coverage: {
    type: 'number',
    min: 0,
    max: 1,
    value: 1
  },
  elevationScale: {
    type: 'number',
    min: 0,
    value: 1
  },
  extruded: true,
  fp64: false,
  pickable: false,
  // TODO: add picking support (read from aggregated texture)
  minColor: DEFAULT_MINCOLOR,
  maxColor: DEFAULT_MAXCOLOR,
  lightSettings: {}
};
export default class GPUGridCellLayer extends Layer {
  getShaders() {
    return {
      vs,
      fs,
      modules: ['project32', 'lighting', 'picking', 'fp64']
    };
  }

  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instanceCounts: {
        size: 4,
        update: this.calculateInstanceCounts,
        noAlloc: true
      }
    });
  }

  updateState({
    props,
    oldProps,
    changeFlags
  }) {
    super.updateState({
      props,
      oldProps,
      changeFlags
    }); // Re-generate model if geometry changed

    if (props.fp64 !== oldProps.fp64) {
      const gl = this.context.gl;

      if (this.state.model) {
        this.state.model.delete();
      }

      const model = this._getModel(gl);

      this._setupUniformBuffer(model);

      this.setState({
        model
      });
      this.state.attributeManager.invalidate('instanceCounts');
    }

    if (props.countsBuffer !== oldProps.countsBuffer) {
      this.state.attributeManager.invalidate('instanceCounts');
    }
  }

  _getModel(gl) {
    return new Model(gl, Object.assign({}, this.getShaders(), {
      id: this.props.id,
      geometry: new CubeGeometry(),
      isInstanced: true,
      shaderCache: this.context.shaderCache
    }));
  }

  draw({
    uniforms
  }) {
    const _this$props = this.props,
          cellSize = _this$props.cellSize,
          extruded = _this$props.extruded,
          elevationScale = _this$props.elevationScale,
          coverage = _this$props.coverage,
          gridSize = _this$props.gridSize,
          gridOrigin = _this$props.gridOrigin,
          gridOffset = _this$props.gridOffset,
          minColor = _this$props.minColor,
          maxColor = _this$props.maxColor,
          maxCountBuffer = _this$props.maxCountBuffer;
    const gridOriginLow = [fp64LowPart(gridOrigin[0]), fp64LowPart(gridOrigin[1])];
    const gridOffsetLow = [fp64LowPart(gridOffset[0]), fp64LowPart(gridOffset[1])];
    maxCountBuffer.bind({
      target: GL.UNIFORM_BUFFER,
      index: AGGREGATION_DATA_UBO_INDEX
    });
    this.state.model.render(Object.assign({}, uniforms, {
      cellSize,
      extruded,
      elevationScale,
      coverage,
      gridSize,
      gridOrigin,
      gridOriginLow,
      gridOffset,
      gridOffsetLow,
      minColor,
      maxColor
    }));
    maxCountBuffer.unbind({
      target: GL.UNIFORM_BUFFER,
      index: AGGREGATION_DATA_UBO_INDEX
    });
  }

  calculateInstanceCounts(attribute) {
    const countsBuffer = this.props.countsBuffer;
    attribute.update({
      buffer: countsBuffer
    });
  }

  _setupUniformBuffer(model) {
    const gl = this.context.gl;
    const programHandle = model.program.handle;
    const uniformBlockIndex = gl.getUniformBlockIndex(programHandle, 'AggregationData');
    gl.uniformBlockBinding(programHandle, uniformBlockIndex, AGGREGATION_DATA_UBO_INDEX);
  }

}
GPUGridCellLayer.layerName = 'GridCellLayer';
GPUGridCellLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ncHUtZ3JpZC1sYXllci9ncHUtZ3JpZC1jZWxsLWxheWVyLmpzIl0sIm5hbWVzIjpbIkxheWVyIiwiR0wiLCJNb2RlbCIsIkN1YmVHZW9tZXRyeSIsImZwNjQiLCJmcDY0TG93UGFydCIsInZzIiwiZnMiLCJERUZBVUxUX01JTkNPTE9SIiwiREVGQVVMVF9NQVhDT0xPUiIsIkFHR1JFR0FUSU9OX0RBVEFfVUJPX0lOREVYIiwiZGVmYXVsdFByb3BzIiwiY2VsbFNpemUiLCJ0eXBlIiwibWluIiwibWF4IiwidmFsdWUiLCJjb3ZlcmFnZSIsImVsZXZhdGlvblNjYWxlIiwiZXh0cnVkZWQiLCJwaWNrYWJsZSIsIm1pbkNvbG9yIiwibWF4Q29sb3IiLCJsaWdodFNldHRpbmdzIiwiR1BVR3JpZENlbGxMYXllciIsImdldFNoYWRlcnMiLCJtb2R1bGVzIiwiaW5pdGlhbGl6ZVN0YXRlIiwiYXR0cmlidXRlTWFuYWdlciIsImdldEF0dHJpYnV0ZU1hbmFnZXIiLCJhZGRJbnN0YW5jZWQiLCJpbnN0YW5jZUNvdW50cyIsInNpemUiLCJ1cGRhdGUiLCJjYWxjdWxhdGVJbnN0YW5jZUNvdW50cyIsIm5vQWxsb2MiLCJ1cGRhdGVTdGF0ZSIsInByb3BzIiwib2xkUHJvcHMiLCJjaGFuZ2VGbGFncyIsImdsIiwiY29udGV4dCIsInN0YXRlIiwibW9kZWwiLCJkZWxldGUiLCJfZ2V0TW9kZWwiLCJfc2V0dXBVbmlmb3JtQnVmZmVyIiwic2V0U3RhdGUiLCJpbnZhbGlkYXRlIiwiY291bnRzQnVmZmVyIiwiT2JqZWN0IiwiYXNzaWduIiwiaWQiLCJnZW9tZXRyeSIsImlzSW5zdGFuY2VkIiwic2hhZGVyQ2FjaGUiLCJkcmF3IiwidW5pZm9ybXMiLCJncmlkU2l6ZSIsImdyaWRPcmlnaW4iLCJncmlkT2Zmc2V0IiwibWF4Q291bnRCdWZmZXIiLCJncmlkT3JpZ2luTG93IiwiZ3JpZE9mZnNldExvdyIsImJpbmQiLCJ0YXJnZXQiLCJVTklGT1JNX0JVRkZFUiIsImluZGV4IiwicmVuZGVyIiwidW5iaW5kIiwiYXR0cmlidXRlIiwiYnVmZmVyIiwicHJvZ3JhbUhhbmRsZSIsInByb2dyYW0iLCJoYW5kbGUiLCJ1bmlmb3JtQmxvY2tJbmRleCIsImdldFVuaWZvcm1CbG9ja0luZGV4IiwidW5pZm9ybUJsb2NrQmluZGluZyIsImxheWVyTmFtZSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSxTQUFRQSxLQUFSLFFBQW9CLGVBQXBCO0FBQ0EsT0FBT0MsRUFBUCxNQUFlLG1CQUFmO0FBQ0EsU0FBUUMsS0FBUixFQUFlQyxZQUFmLEVBQTZCQyxJQUE3QixRQUF3QyxTQUF4QztNQUNPQyxXLEdBQWVELEksQ0FBZkMsVztBQUVQLE9BQU9DLEVBQVAsTUFBZSxtQ0FBZjtBQUNBLE9BQU9DLEVBQVAsTUFBZSxxQ0FBZjtBQUVBLE1BQU1DLGdCQUFnQixHQUFHLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsR0FBVixDQUF6QjtBQUNBLE1BQU1DLGdCQUFnQixHQUFHLENBQUMsQ0FBRCxFQUFJLEdBQUosRUFBUyxDQUFULEVBQVksR0FBWixDQUF6QjtBQUNBLE1BQU1DLDBCQUEwQixHQUFHLENBQW5DO0FBRUEsTUFBTUMsWUFBWSxHQUFHO0FBQ25CQyxFQUFBQSxRQUFRLEVBQUU7QUFBQ0MsSUFBQUEsSUFBSSxFQUFFLFFBQVA7QUFBaUJDLElBQUFBLEdBQUcsRUFBRSxDQUF0QjtBQUF5QkMsSUFBQUEsR0FBRyxFQUFFLEVBQTlCO0FBQWtDQyxJQUFBQSxLQUFLLEVBQUU7QUFBekMsR0FEUztBQUVuQkMsRUFBQUEsUUFBUSxFQUFFO0FBQUNKLElBQUFBLElBQUksRUFBRSxRQUFQO0FBQWlCQyxJQUFBQSxHQUFHLEVBQUUsQ0FBdEI7QUFBeUJDLElBQUFBLEdBQUcsRUFBRSxDQUE5QjtBQUFpQ0Ms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QVQwQjtBQVUxQjFDLE1BQUFBLFFBVjBCO0FBVzFCQyxNQUFBQTtBQVgwQixLQUE1QixDQURGO0FBZUF1QyxJQUFBQSxjQUFjLENBQUNRLE1BQWYsQ0FBc0I7QUFBQ0osTUFBQUEsTUFBTSxFQUFFaEUsRUFBRSxDQUFDaUUsY0FBWjtBQUE0QkMsTUFBQUEsS0FBSyxFQUFFekQ7QUFBbkMsS0FBdEI7QUFDRDs7QUFFRHdCLEVBQUFBLHVCQUF1QixDQUFDb0MsU0FBRCxFQUFZO0FBQUEsVUFDMUJyQixZQUQwQixHQUNWLEtBQUtaLEtBREssQ0FDMUJZLFlBRDBCO0FBRWpDcUIsSUFBQUEsU0FBUyxDQUFDckMsTUFBVixDQUFpQjtBQUNmc0MsTUFBQUEsTUFBTSxFQUFFdEI7QUFETyxLQUFqQjtBQUdEOztBQUVESCxFQUFBQSxtQkFBbUIsQ0FBQ0gsS0FBRCxFQUFRO0FBQ3pCLFVBQU1ILEVBQUUsR0FBRyxLQUFLQyxPQUFMLENBQWFELEVBQXhCO0FBQ0EsVUFBTWdDLGFBQWEsR0FBRzdCLEtBQUssQ0FBQzhCLE9BQU4sQ0FBY0MsTUFBcEM7QUFFQSxVQUFNQyxpQkFBaUIsR0FBR25DLEVBQUUsQ0FBQ29DLG9CQUFILENBQXdCSixhQUF4QixFQUF1QyxpQkFBdkMsQ0FBMUI7QUFDQWhDLElBQUFBLEVBQUUsQ0FBQ3FDLG1CQUFILENBQXVCTCxhQUF2QixFQUFzQ0csaUJBQXRDLEVBQXlEakUsMEJBQXpEO0FBQ0Q7O0FBL0ZpRDtBQWtHcERjLGdCQUFnQixDQUFDc0QsU0FBakIsR0FBNkIsZUFBN0I7QUFDQXRELGdCQUFnQixDQUFDYixZQUFqQixHQUFnQ0EsWUFBaEMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtMYXllcn0gZnJvbSAnQGRlY2suZ2wvY29yZSc7XG5pbXBvcnQgR0wgZnJvbSAnbHVtYS5nbC9jb25zdGFudHMnO1xuaW1wb3J0IHtNb2RlbCwgQ3ViZUdlb21ldHJ5LCBmcDY0fSBmcm9tICdsdW1hLmdsJztcbmNvbnN0IHtmcDY0TG93UGFydH0gPSBmcDY0O1xuXG5pbXBvcnQgdnMgZnJvbSAnLi9ncHUtZ3JpZC1jZWxsLWxheWVyLXZlcnRleC5nbHNsJztcbmltcG9ydCBmcyBmcm9tICcuL2dwdS1ncmlkLWNlbGwtbGF5ZXItZnJhZ21lbnQuZ2xzbCc7XG5cbmNvbnN0IERFRkFVTFRfTUlOQ09MT1IgPSBbMCwgMCwgMCwgMjU1XTtcbmNvbnN0IERFRkFVTFRfTUFYQ09MT1IgPSBbMCwgMjU1LCAwLCAyNTVdO1xuY29uc3QgQUdHUkVHQVRJT05fREFUQV9VQk9fSU5ERVggPSAwO1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIGNlbGxTaXplOiB7dHlwZTogJ251bWJlcicsIG1pbjogMCwgbWF4OiAyMCwgdmFsdWU6IDIwfSxcbiAgY292ZXJhZ2U6IHt0eXBlOiAnbnVtYmVyJywgbWluOiAwLCBtYXg6IDEsIHZhbHVlOiAxfSxcbiAgZWxldmF0aW9uU2NhbGU6IHt0eXBlOiAnbnVtYmVyJywgbWluOiAwLCB2YWx1ZTogMX0sXG4gIGV4dHJ1ZGVkOiB0cnVlLFxuICBmcDY0OiBmYWxzZSxcbiAgcGlja2FibGU6IGZhbHNlLCAvLyBUT0RPOiBhZGQgcGlja2luZyBzdXBwb3J0IChyZWFkIGZyb20gYWdncmVnYXRlZCB0ZXh0dXJlKVxuXG4gIG1pbkNvbG9yOiBERUZBVUxUX01JTkNPTE9SLFxuICBtYXhDb2xvcjogREVGQVVMVF9NQVhDT0xPUixcblxuICBsaWdodFNldHRpbmdzOiB7fVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR1BVR3JpZENlbGxMYXllciBleHRlbmRzIExheWVyIHtcbiAgZ2V0U2hhZGVycygpIHtcbiAgICByZXR1cm4ge3ZzLCBmcywgbW9kdWxlczogWydwcm9qZWN0MzInLCAnbGlnaHRpbmcnLCAncGlja2luZycsICdmcDY0J119O1xuICB9XG5cbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZU1hbmFnZXIgPSB0aGlzLmdldEF0dHJpYnV0ZU1hbmFnZXIoKTtcbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICBpbnN0YW5jZUNvdW50czoge1xuICAgICAgICBzaXplOiA0LFxuICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VDb3VudHMsXG4gICAgICAgIG5vQWxsb2M6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZVN0YXRlKHtwcm9wcywgb2xkUHJvcHMsIGNoYW5nZUZsYWdzfSkge1xuICAgIHN1cGVyLnVwZGF0ZVN0YXRlKHtwcm9wcywgb2xkUHJvcHMsIGNoYW5nZUZsYWdzfSk7XG4gICAgLy8gUmUtZ2VuZXJhdGUgbW9kZWwgaWYgZ2VvbWV0cnkgY2hhbmdlZFxuICAgIGlmIChwcm9wcy5mcDY0ICE9PSBvbGRQcm9wcy5mcDY0KSB7XG4gICAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgaWYgKHRoaXMuc3RhdGUubW9kZWwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5tb2RlbC5kZWxldGUoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fZ2V0TW9kZWwoZ2wpO1xuICAgICAgdGhpcy5fc2V0dXBVbmlmb3JtQnVmZmVyKG1vZGVsKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe21vZGVsfSk7XG4gICAgICB0aGlzLnN0YXRlLmF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZSgnaW5zdGFuY2VDb3VudHMnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmNvdW50c0J1ZmZlciAhPT0gb2xkUHJvcHMuY291bnRzQnVmZmVyKSB7XG4gICAgICB0aGlzLnN0YXRlLmF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZSgnaW5zdGFuY2VDb3VudHMnKTtcbiAgICB9XG4gIH1cblxuICBfZ2V0TW9kZWwoZ2wpIHtcbiAgICByZXR1cm4gbmV3IE1vZGVsKFxuICAgICAgZ2wsXG4gICAgICBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmdldFNoYWRlcnMoKSwge1xuICAgICAgICBpZDogdGhpcy5wcm9wcy5pZCxcbiAgICAgICAgZ2VvbWV0cnk6IG5ldyBDdWJlR2VvbWV0cnkoKSxcbiAgICAgICAgaXNJbnN0YW5jZWQ6IHRydWUsXG4gICAgICAgIHNoYWRlckNhY2hlOiB0aGlzLmNvbnRleHQuc2hhZGVyQ2FjaGVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIGRyYXcoe3VuaWZvcm1zfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNlbGxTaXplLFxuICAgICAgZXh0cnVkZWQsXG4gICAgICBlbGV2YXRpb25TY2FsZSxcbiAgICAgIGNvdmVyYWdlLFxuICAgICAgZ3JpZFNpemUsXG4gICAgICBncmlkT3JpZ2luLFxuICAgICAgZ3JpZE9mZnNldCxcbiAgICAgIG1pbkNvbG9yLFxuICAgICAgbWF4Q29sb3IsXG4gICAgICBtYXhDb3VudEJ1ZmZlclxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgZ3JpZE9yaWdpbkxvdyA9IFtmcDY0TG93UGFydChncmlkT3JpZ2luWzBdKSwgZnA2NExvd1BhcnQoZ3JpZE9yaWdpblsxXSldO1xuICAgIGNvbnN0IGdyaWRPZmZzZXRMb3cgPSBbZnA2NExvd1BhcnQoZ3JpZE9mZnNldFswXSksIGZwNjRMb3dQYXJ0KGdyaWRPZmZzZXRbMV0pXTtcblxuICAgIG1heENvdW50QnVmZmVyLmJpbmQoe3RhcmdldDogR0wuVU5JRk9STV9CVUZGRVIsIGluZGV4OiBBR0dSRUdBVElPTl9EQVRBX1VCT19JTkRFWH0pO1xuICAgIHRoaXMuc3RhdGUubW9kZWwucmVuZGVyKFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwgdW5pZm9ybXMsIHtcbiAgICAgICAgY2VsbFNpemUsXG4gICAgICAgIGV4dHJ1ZGVkLFxuICAgICAgICBlbGV2YXRpb25TY2FsZSxcbiAgICAgICAgY292ZXJhZ2UsXG4gICAgICAgIGdyaWRTaXplLFxuICAgICAgICBncmlkT3JpZ2luLFxuICAgICAgICBncmlkT3JpZ2luTG93LFxuICAgICAgICBncmlkT2Zmc2V0LFxuICAgICAgICBncmlkT2Zmc2V0TG93LFxuICAgICAgICBtaW5Db2xvcixcbiAgICAgICAgbWF4Q29sb3JcbiAgICAgIH0pXG4gICAgKTtcbiAgICBtYXhDb3VudEJ1ZmZlci51bmJpbmQoe3RhcmdldDogR0wuVU5JRk9STV9CVUZGRVIsIGluZGV4OiBBR0dSRUdBVElPTl9EQVRBX1VCT19JTkRFWH0pO1xuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VDb3VudHMoYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2NvdW50c0J1ZmZlcn0gPSB0aGlzLnByb3BzO1xuICAgIGF0dHJpYnV0ZS51cGRhdGUoe1xuICAgICAgYnVmZmVyOiBjb3VudHNCdWZmZXJcbiAgICB9KTtcbiAgfVxuXG4gIF9zZXR1cFVuaWZvcm1CdWZmZXIobW9kZWwpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuY29udGV4dC5nbDtcbiAgICBjb25zdCBwcm9ncmFtSGFuZGxlID0gbW9kZWwucHJvZ3JhbS5oYW5kbGU7XG5cbiAgICBjb25zdCB1bmlmb3JtQmxvY2tJbmRleCA9IGdsLmdldFVuaWZvcm1CbG9ja0luZGV4KHByb2dyYW1IYW5kbGUsICdBZ2dyZWdhdGlvbkRhdGEnKTtcbiAgICBnbC51bmlmb3JtQmxvY2tCaW5kaW5nKHByb2dyYW1IYW5kbGUsIHVuaWZvcm1CbG9ja0luZGV4LCBBR0dSRUdBVElPTl9EQVRBX1VCT19JTkRFWCk7XG4gIH1cbn1cblxuR1BVR3JpZENlbGxMYXllci5sYXllck5hbWUgPSAnR3JpZENlbGxMYXllcic7XG5HUFVHcmlkQ2VsbExheWVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbiJdfQ==