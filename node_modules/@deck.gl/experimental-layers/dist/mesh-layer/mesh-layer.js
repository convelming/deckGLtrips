"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@deck.gl/core");

var _constants = _interopRequireDefault(require("luma.gl/constants"));

var _luma = require("luma.gl");

var _meshLayerVertex = _interopRequireDefault(require("./mesh-layer-vertex.glsl"));

var _meshLayerFragment = _interopRequireDefault(require("./mesh-layer-fragment.glsl"));

var _assert = _interopRequireDefault(require("assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var fp64LowPart = _luma.fp64.fp64LowPart;
var RADIAN_PER_DEGREE = Math.PI / 180;
/*
 * Load image data into luma.gl Texture2D objects
 * @param {WebGLContext} gl
 * @param {String|Texture2D|HTMLImageElement|Uint8ClampedArray} src - source of image data
 *   can be url string, Texture2D object, HTMLImageElement or pixel array
 * @returns {Promise} resolves to an object with name -> texture mapping
 */

function getTexture(gl, src, opts) {
  if (typeof src === 'string') {
    // Url, load the image
    return (0, _luma.loadTextures)(gl, Object.assign({
      urls: [src]
    }, opts)).then(function (textures) {
      return textures[0];
    }).catch(function (error) {
      throw new Error("Could not load texture from ".concat(src, ": ").concat(error));
    });
  }

  return new Promise(function (resolve) {
    return resolve(getTextureFromData(gl, src, opts));
  });
}
/*
 * Convert image data into texture
 * @returns {Texture2D} texture
 */


function getTextureFromData(gl, data, opts) {
  if (data instanceof _luma.Texture2D) {
    return data;
  }

  return new _luma.Texture2D(gl, Object.assign({
    data: data
  }, opts));
}

function validateGeometryAttributes(attributes) {
  (0, _assert.default)(attributes.positions && attributes.normals && attributes.texCoords);
}
/*
 * Convert mesh data into geometry
 * @returns {Geometry} geometry
 */


function getGeometry(data) {
  if (data instanceof _luma.Geometry) {
    validateGeometryAttributes(data.attributes);
    return data;
  } else if (data.positions) {
    validateGeometryAttributes(data);
    return new _luma.Geometry({
      attributes: data
    });
  }

  throw Error('Invalid mesh');
}

var DEFAULT_COLOR = [0, 0, 0, 255];
var defaultProps = {
  mesh: null,
  texture: null,
  sizeScale: 1,
  // TODO - parameters should be merged, not completely overridden
  parameters: {
    depthTest: true,
    depthFunc: _constants.default.LEQUAL
  },
  fp64: false,
  // Optional settings for 'lighting' shader module
  lightSettings: {},
  getPosition: function getPosition(x) {
    return x.position;
  },
  getColor: function getColor(x) {
    return x.color || DEFAULT_COLOR;
  },
  // yaw, pitch and roll are in degrees
  // https://en.wikipedia.org/wiki/Euler_angles
  getYaw: function getYaw(x) {
    return x.yaw || x.angle || 0;
  },
  getPitch: function getPitch(x) {
    return x.pitch || 0;
  },
  getRoll: function getRoll(x) {
    return x.roll || 0;
  }
};

var MeshLayer =
/*#__PURE__*/
function (_Layer) {
  _inherits(MeshLayer, _Layer);

  function MeshLayer() {
    _classCallCheck(this, MeshLayer);

    return _possibleConstructorReturn(this, _getPrototypeOf(MeshLayer).apply(this, arguments));
  }

  _createClass(MeshLayer, [{
    key: "getShaders",
    value: function getShaders() {
      var projectModule = this.use64bitProjection() ? 'project64' : 'project32';
      return {
        vs: _meshLayerVertex.default,
        fs: _meshLayerFragment.default,
        modules: [projectModule, 'lighting', 'picking']
      };
    }
  }, {
    key: "initializeState",
    value: function initializeState() {
      var attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instancePositions: {
          size: 3,
          accessor: 'getPosition',
          update: this.calculateInstancePositions
        },
        instancePositions64xy: {
          size: 2,
          accessor: 'getPosition',
          update: this.calculateInstancePositions64xyLow
        },
        instanceRotations: {
          size: 3,
          accessor: ['getYaw', 'getPitch', 'getRoll'],
          update: this.calculateInstanceRotations
        },
        instanceColors: {
          size: 4,
          accessor: 'getColor',
          update: this.calculateInstanceColors
        }
      });
      this.setState({
        // Avoid luma.gl's missing uniform warning
        // TODO - add feature to luma.gl to specify ignored uniforms?
        emptyTexture: new _luma.Texture2D(this.context.gl, {
          data: new Uint8Array(4),
          width: 1,
          height: 1
        })
      });
    }
  }, {
    key: "updateState",
    value: function updateState(_ref) {
      var props = _ref.props,
          oldProps = _ref.oldProps,
          changeFlags = _ref.changeFlags;
      var attributeManager = this.getAttributeManager(); // super.updateState({props, oldProps, changeFlags});

      if (changeFlags.dataChanged) {
        attributeManager.invalidateAll();
      }

      this._updateFP64(props, oldProps);

      if (props.texture !== oldProps.texture) {
        this.setTexture(props.texture);
      }
    }
  }, {
    key: "_updateFP64",
    value: function _updateFP64(props, oldProps) {
      if (props.fp64 !== oldProps.fp64) {
        if (this.state.model) {
          this.state.model.delete();
        }

        this.setState({
          model: this.getModel(this.context.gl)
        });
        this.setTexture(this.state.texture);
        var attributeManager = this.getAttributeManager();
        attributeManager.invalidateAll();
      }
    }
  }, {
    key: "draw",
    value: function draw(_ref2) {
      var uniforms = _ref2.uniforms;
      var sizeScale = this.props.sizeScale;
      this.state.model.render(Object.assign({}, uniforms, {
        sizeScale: sizeScale
      }));
    }
  }, {
    key: "getModel",
    value: function getModel(gl) {
      return new _luma.Model(gl, Object.assign({}, this.getShaders(), {
        id: this.props.id,
        geometry: getGeometry(this.props.mesh),
        isInstanced: true,
        shaderCache: this.context.shaderCache
      }));
    }
  }, {
    key: "setTexture",
    value: function setTexture(src) {
      var _this = this;

      var gl = this.context.gl;
      var _this$state = this.state,
          model = _this$state.model,
          emptyTexture = _this$state.emptyTexture;

      if (src) {
        getTexture(gl, src).then(function (texture) {
          model.setUniforms({
            sampler: texture,
            hasTexture: 1
          });

          _this.setState({
            texture: texture
          });
        });
      } else {
        // reset
        this.state.model.setUniforms({
          sampler: emptyTexture,
          hasTexture: 0
        });
        this.setState({
          texture: null
        });
      }
    }
  }, {
    key: "calculateInstancePositions",
    value: function calculateInstancePositions(attribute) {
      var _this$props = this.props,
          data = _this$props.data,
          getPosition = _this$props.getPosition;
      var value = attribute.value,
          size = attribute.size;
      var i = 0;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var point = _step.value;
          var position = getPosition(point);
          value[i] = position[0];
          value[i + 1] = position[1];
          value[i + 2] = position[2] || 0;
          i += size;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "calculateInstancePositions64xyLow",
    value: function calculateInstancePositions64xyLow(attribute) {
      var isFP64 = this.use64bitPositions();
      attribute.constant = !isFP64;

      if (!isFP64) {
        attribute.value = new Float32Array(2);
        return;
      }

      var _this$props2 = this.props,
          data = _this$props2.data,
          getPosition = _this$props2.getPosition;
      var value = attribute.value;
      var i = 0;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = data[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var point = _step2.value;
          var position = getPosition(point);
          value[i++] = fp64LowPart(position[0]);
          value[i++] = fp64LowPart(position[1]);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    } // yaw(z), pitch(y) and roll(x) in radians

  }, {
    key: "calculateInstanceRotations",
    value: function calculateInstanceRotations(attribute) {
      var _this$props3 = this.props,
          data = _this$props3.data,
          getYaw = _this$props3.getYaw,
          getPitch = _this$props3.getPitch,
          getRoll = _this$props3.getRoll;
      var value = attribute.value,
          size = attribute.size;
      var i = 0;
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = data[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var point = _step3.value;
          value[i++] = getRoll(point) * RADIAN_PER_DEGREE;
          value[i++] = getPitch(point) * RADIAN_PER_DEGREE;
          value[i++] = getYaw(point) * RADIAN_PER_DEGREE;
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
  }, {
    key: "calculateInstanceColors",
    value: function calculateInstanceColors(attribute) {
      var _this$props4 = this.props,
          data = _this$props4.data,
          getColor = _this$props4.getColor;
      var value = attribute.value;
      var i = 0;
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = data[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var point = _step4.value;
          var color = getColor(point) || DEFAULT_COLOR;
          value[i++] = color[0];
          value[i++] = color[1];
          value[i++] = color[2];
          value[i++] = isNaN(color[3]) ? 255 : color[3];
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }
  }]);

  return MeshLayer;
}(_core.Layer);

exports.default = MeshLayer;
MeshLayer.layerName = 'MeshLayer';
MeshLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tZXNoLWxheWVyL21lc2gtbGF5ZXIuanMiXSwibmFtZXMiOlsiZnA2NExvd1BhcnQiLCJmcDY0IiwiUkFESUFOX1BFUl9ERUdSRUUiLCJNYXRoIiwiUEkiLCJnZXRUZXh0dXJlIiwiZ2wiLCJzcmMiLCJvcHRzIiwiT2JqZWN0IiwiYXNzaWduIiwidXJscyIsInRoZW4iLCJ0ZXh0dXJlcyIsImNhdGNoIiwiZXJyb3IiLCJFcnJvciIsIlByb21pc2UiLCJyZXNvbHZlIiwiZ2V0VGV4dHVyZUZyb21EYXRhIiwiZGF0YSIsIlRleHR1cmUyRCIsInZhbGlkYXRlR2VvbWV0cnlBdHRyaWJ1dGVzIiwiYXR0cmlidXRlcyIsInBvc2l0aW9ucyIsIm5vcm1hbHMiLCJ0ZXhDb29yZHMiLCJnZXRHZW9tZXRyeSIsIkdlb21ldHJ5IiwiREVGQVVMVF9DT0xPUiIsImRlZmF1bHRQcm9wcyIsIm1lc2giLCJ0ZXh0dXJlIiwic2l6ZVNjYWxlIiwicGFyYW1ldGVycyIsImRlcHRoVGVzdCIsImRlcHRoRnVuYyIsIkdMIiwiTEVRVUFMIiwibGlnaHRTZXR0aW5ncyIsImdldFBvc2l0aW9uIiwieCIsInBvc2l0aW9uIiwiZ2V0Q29sb3IiLCJjb2xvciIsImdldFlhdyIsInlhdyIsImFuZ2xlIiwiZ2V0UGl0Y2giLCJwaXRjaCIsImdldFJvbGwiLCJyb2xsIiwiTWVzaExheWVyIiwicHJvamVjdE1vZHVsZSIsInVzZTY0Yml0UHJvamVjdGlvbiIsInZzIiwiZnMiLCJtb2R1bGVzIiwiYXR0cmlidXRlTWFuYWdlciIsImdldEF0dHJpYnV0ZU1hbmFnZXIiLCJhZGRJbnN0YW5jZWQiLCJpbnN0YW5jZVBvc2l0aW9ucyIsInNpemUiLCJhY2Nlc3NvciIsInVwZGF0ZSIsImNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zIiwiaW5zdGFuY2VQb3NpdGlvbnM2NHh5IiwiY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnM2NHh5TG93IiwiaW5zdGFuY2VSb3RhdGlvbnMiLCJjYWxjdWxhdGVJbnN0YW5jZVJvdGF0aW9ucyIsImluc3RhbmNlQ29sb3JzIiwiY2FsY3VsYXRlSW5zdGFuY2VDb2xvcnMiLCJzZXRTdGF0ZSIsImVtcHR5VGV4dHVyZSIsImNvbnRleHQiLCJVaW50OEFycmF5Iiwid2lkdGgiLCJoZWlnaHQiLCJwcm9wcyIsIm9sZFByb3BzIiwiY2hhbmdlRmxhZ3MiLCJkYXRhQ2hhbmdlZCIsImludmFsaWRhdGVBbGwiLCJfdXBkYXRlRlA2NCIsInNldFRleHR1cmUiLCJzdGF0ZSIsIm1vZGVsIiwiZGVsZXRlIiwiZ2V0TW9kZWwiLCJ1bmlmb3JtcyIsInJlbmRlciIsIk1vZGVsIiwiZ2V0U2hhZGVycyIsImlkIiwiZ2VvbWV0cnkiLCJpc0luc3RhbmNlZCIsInNoYWRlckNhY2hlIiwic2V0VW5pZm9ybXMiLCJzYW1wbGVyIiwiaGFzVGV4dHVyZSIsImF0dHJpYnV0ZSIsInZhbHVlIiwiaSIsInBvaW50IiwiaXNGUDY0IiwidXNlNjRiaXRQb3NpdGlvbnMiLCJjb25zdGFudCIsIkZsb2F0MzJBcnJheSIsImlzTmFOIiwiTGF5ZXIiLCJsYXllck5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUF3QkE7O0FBQ0E7O0FBQ0E7O0FBR0E7O0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFMT0EsVyxHQUFlQyxVLENBQWZELFc7QUFPUCxJQUFNRSxpQkFBaUIsR0FBR0MsSUFBSSxDQUFDQyxFQUFMLEdBQVUsR0FBcEM7QUFFQTs7Ozs7Ozs7QUFPQSxTQUFTQyxVQUFULENBQW9CQyxFQUFwQixFQUF3QkMsR0FBeEIsRUFBNkJDLElBQTdCLEVBQW1DO0FBQ2pDLE1BQUksT0FBT0QsR0FBUCxLQUFlLFFBQW5CLEVBQTZCO0FBQzNCO0FBQ0EsV0FBTyx3QkFBYUQsRUFBYixFQUFpQkcsTUFBTSxDQUFDQyxNQUFQLENBQWM7QUFBQ0MsTUFBQUEsSUFBSSxFQUFFLENBQUNKLEdBQUQ7QUFBUCxLQUFkLEVBQTZCQyxJQUE3QixDQUFqQixFQUNKSSxJQURJLENBQ0MsVUFB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Q0FBTCxHQUFhMUQsS0FBSyxDQUFDLENBQUQsQ0FBbEI7QUFDQXlELFVBQUFBLEtBQUssQ0FBQ0MsQ0FBQyxFQUFGLENBQUwsR0FBYTFELEtBQUssQ0FBQyxDQUFELENBQWxCO0FBQ0F5RCxVQUFBQSxLQUFLLENBQUNDLENBQUMsRUFBRixDQUFMLEdBQWExRCxLQUFLLENBQUMsQ0FBRCxDQUFsQjtBQUNBeUQsVUFBQUEsS0FBSyxDQUFDQyxDQUFDLEVBQUYsQ0FBTCxHQUFhTSxLQUFLLENBQUNoRSxLQUFLLENBQUMsQ0FBRCxDQUFOLENBQUwsR0FBa0IsR0FBbEIsR0FBd0JBLEtBQUssQ0FBQyxDQUFELENBQTFDO0FBQ0Q7QUFWZ0M7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVdsQzs7OztFQWpLb0NpRSxXOzs7QUFvS3ZDekQsU0FBUyxDQUFDMEQsU0FBVixHQUFzQixXQUF0QjtBQUNBMUQsU0FBUyxDQUFDdEIsWUFBVixHQUF5QkEsWUFBekIiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBOb3RlOiBUaGlzIGZpbGUgd2lsbCBlaXRoZXIgYmUgbW92ZWQgYmFjayB0byBkZWNrLmdsIG9yIHJlZm9ybWF0dGVkIHRvIHdlYi1tb25vcmVwbyBzdGFuZGFyZHNcbi8vIERpc2FibGluZyBsaW50IHRlbXBvcmFyaWx5IHRvIGZhY2lsaXRhdGUgY29weWluZyBjb2RlIGluIGFuZCBvdXQgb2YgdGhpcyByZXBvXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge0xheWVyLCBDT09SRElOQVRFX1NZU1RFTX0gZnJvbSAnQGRlY2suZ2wvY29yZSc7XG5pbXBvcnQgR0wgZnJvbSAnbHVtYS5nbC9jb25zdGFudHMnO1xuaW1wb3J0IHtNb2RlbCwgR2VvbWV0cnksIGxvYWRUZXh0dXJlcywgVGV4dHVyZTJELCBmcDY0fSBmcm9tICdsdW1hLmdsJztcbmNvbnN0IHtmcDY0TG93UGFydH0gPSBmcDY0O1xuXG5pbXBvcnQgdnMgZnJvbSAnLi9tZXNoLWxheWVyLXZlcnRleC5nbHNsJztcbmltcG9ydCBmcyBmcm9tICcuL21lc2gtbGF5ZXItZnJhZ21lbnQuZ2xzbCc7XG5cbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuY29uc3QgUkFESUFOX1BFUl9ERUdSRUUgPSBNYXRoLlBJIC8gMTgwO1xuXG4vKlxuICogTG9hZCBpbWFnZSBkYXRhIGludG8gbHVtYS5nbCBUZXh0dXJlMkQgb2JqZWN0c1xuICogQHBhcmFtIHtXZWJHTENvbnRleHR9IGdsXG4gKiBAcGFyYW0ge1N0cmluZ3xUZXh0dXJlMkR8SFRNTEltYWdlRWxlbWVudHxVaW50OENsYW1wZWRBcnJheX0gc3JjIC0gc291cmNlIG9mIGltYWdlIGRhdGFcbiAqICAgY2FuIGJlIHVybCBzdHJpbmcsIFRleHR1cmUyRCBvYmplY3QsIEhUTUxJbWFnZUVsZW1lbnQgb3IgcGl4ZWwgYXJyYXlcbiAqIEByZXR1cm5zIHtQcm9taXNlfSByZXNvbHZlcyB0byBhbiBvYmplY3Qgd2l0aCBuYW1lIC0+IHRleHR1cmUgbWFwcGluZ1xuICovXG5mdW5jdGlvbiBnZXRUZXh0dXJlKGdsLCBzcmMsIG9wdHMpIHtcbiAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gVXJsLCBsb2FkIHRoZSBpbWFnZVxuICAgIHJldHVybiBsb2FkVGV4dHVyZXMoZ2wsIE9iamVjdC5hc3NpZ24oe3VybHM6IFtzcmNdfSwgb3B0cykpXG4gICAgICAudGhlbih0ZXh0dXJlcyA9PiB0ZXh0dXJlc1swXSlcbiAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGxvYWQgdGV4dHVyZSBmcm9tICR7c3JjfTogJHtlcnJvcn1gKTtcbiAgICAgIH0pO1xuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHJlc29sdmUoZ2V0VGV4dHVyZUZyb21EYXRhKGdsLCBzcmMsIG9wdHMpKSk7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGltYWdlIGRhdGEgaW50byB0ZXh0dXJlXG4gKiBAcmV0dXJucyB7VGV4dHVyZTJEfSB0ZXh0dXJlXG4gKi9cbmZ1bmN0aW9uIGdldFRleHR1cmVGcm9tRGF0YShnbCwgZGF0YSwgb3B0cykge1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIFRleHR1cmUyRCkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIHJldHVybiBuZXcgVGV4dHVyZTJEKGdsLCBPYmplY3QuYXNzaWduKHtkYXRhfSwgb3B0cykpO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUdlb21ldHJ5QXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XG4gIGFzc2VydChhdHRyaWJ1dGVzLnBvc2l0aW9ucyAmJiBhdHRyaWJ1dGVzLm5vcm1hbHMgJiYgYXR0cmlidXRlcy50ZXhDb29yZHMpO1xufVxuXG4vKlxuICogQ29udmVydCBtZXNoIGRhdGEgaW50byBnZW9tZXRyeVxuICogQHJldHVybnMge0dlb21ldHJ5fSBnZW9tZXRyeVxuICovXG5mdW5jdGlvbiBnZXRHZW9tZXRyeShkYXRhKSB7XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgR2VvbWV0cnkpIHtcbiAgICB2YWxpZGF0ZUdlb21ldHJ5QXR0cmlidXRlcyhkYXRhLmF0dHJpYnV0ZXMpO1xuICAgIHJldHVybiBkYXRhO1xuICB9IGVsc2UgaWYgKGRhdGEucG9zaXRpb25zKSB7XG4gICAgdmFsaWRhdGVHZW9tZXRyeUF0dHJpYnV0ZXMoZGF0YSk7XG4gICAgcmV0dXJuIG5ldyBHZW9tZXRyeSh7XG4gICAgICBhdHRyaWJ1dGVzOiBkYXRhXG4gICAgfSk7XG4gIH1cbiAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgbWVzaCcpO1xufVxuXG5jb25zdCBERUZBVUxUX0NPTE9SID0gWzAsIDAsIDAsIDI1NV07XG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIG1lc2g6IG51bGwsXG4gIHRleHR1cmU6IG51bGwsXG4gIHNpemVTY2FsZTogMSxcblxuICAvLyBUT0RPIC0gcGFyYW1ldGVycyBzaG91bGQgYmUgbWVyZ2VkLCBub3QgY29tcGxldGVseSBvdmVycmlkZGVuXG4gIHBhcmFtZXRlcnM6IHtcbiAgICBkZXB0aFRlc3Q6IHRydWUsXG4gICAgZGVwdGhGdW5jOiBHTC5MRVFVQUxcbiAgfSxcbiAgZnA2NDogZmFsc2UsXG4gIC8vIE9wdGlvbmFsIHNldHRpbmdzIGZvciAnbGlnaHRpbmcnIHNoYWRlciBtb2R1bGVcbiAgbGlnaHRTZXR0aW5nczoge30sXG5cbiAgZ2V0UG9zaXRpb246IHggPT4geC5wb3NpdGlvbixcbiAgZ2V0Q29sb3I6IHggPT4geC5jb2xvciB8fCBERUZBVUxUX0NPTE9SLFxuXG4gIC8vIHlhdywgcGl0Y2ggYW5kIHJvbGwgYXJlIGluIGRlZ3JlZXNcbiAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXVsZXJfYW5nbGVzXG4gIGdldFlhdzogeCA9PiB4LnlhdyB8fCB4LmFuZ2xlIHx8IDAsXG4gIGdldFBpdGNoOiB4ID0+IHgucGl0Y2ggfHwgMCxcbiAgZ2V0Um9sbDogeCA9PiB4LnJvbGwgfHwgMFxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWVzaExheWVyIGV4dGVuZHMgTGF5ZXIge1xuICBnZXRTaGFkZXJzKCkge1xuICAgIGNvbnN0IHByb2plY3RNb2R1bGUgPSB0aGlzLnVzZTY0Yml0UHJvamVjdGlvbigpID8gJ3Byb2plY3Q2NCcgOiAncHJvamVjdDMyJztcbiAgICByZXR1cm4ge3ZzLCBmcywgbW9kdWxlczogW3Byb2plY3RNb2R1bGUsICdsaWdodGluZycsICdwaWNraW5nJ119O1xuICB9XG5cbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZU1hbmFnZXIgPSB0aGlzLmdldEF0dHJpYnV0ZU1hbmFnZXIoKTtcbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICBpbnN0YW5jZVBvc2l0aW9uczoge1xuICAgICAgICBzaXplOiAzLFxuICAgICAgICBhY2Nlc3NvcjogJ2dldFBvc2l0aW9uJyxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zXG4gICAgICB9LFxuICAgICAgaW5zdGFuY2VQb3NpdGlvbnM2NHh5OiB7XG4gICAgICAgIHNpemU6IDIsXG4gICAgICAgIGFjY2Vzc29yOiAnZ2V0UG9zaXRpb24nLFxuICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnM2NHh5TG93XG4gICAgICB9LFxuICAgICAgaW5zdGFuY2VSb3RhdGlvbnM6IHtcbiAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgYWNjZXNzb3I6IFsnZ2V0WWF3JywgJ2dldFBpdGNoJywgJ2dldFJvbGwnXSxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlUm90YXRpb25zXG4gICAgICB9LFxuICAgICAgaW5zdGFuY2VDb2xvcnM6IHtzaXplOiA0LCBhY2Nlc3NvcjogJ2dldENvbG9yJywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlQ29sb3JzfVxuICAgIH0pO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAvLyBBdm9pZCBsdW1hLmdsJ3MgbWlzc2luZyB1bmlmb3JtIHdhcm5pbmdcbiAgICAgIC8vIFRPRE8gLSBhZGQgZmVhdHVyZSB0byBsdW1hLmdsIHRvIHNwZWNpZnkgaWdub3JlZCB1bmlmb3Jtcz9cbiAgICAgIGVtcHR5VGV4dHVyZTogbmV3IFRleHR1cmUyRCh0aGlzLmNvbnRleHQuZ2wsIHtcbiAgICAgICAgZGF0YTogbmV3IFVpbnQ4QXJyYXkoNCksXG4gICAgICAgIHdpZHRoOiAxLFxuICAgICAgICBoZWlnaHQ6IDFcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cblxuICB1cGRhdGVTdGF0ZSh7cHJvcHMsIG9sZFByb3BzLCBjaGFuZ2VGbGFnc30pIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVNYW5hZ2VyID0gdGhpcy5nZXRBdHRyaWJ1dGVNYW5hZ2VyKCk7XG5cbiAgICAvLyBzdXBlci51cGRhdGVTdGF0ZSh7cHJvcHMsIG9sZFByb3BzLCBjaGFuZ2VGbGFnc30pO1xuICAgIGlmIChjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCkge1xuICAgICAgYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlRlA2NChwcm9wcywgb2xkUHJvcHMpO1xuXG4gICAgaWYgKHByb3BzLnRleHR1cmUgIT09IG9sZFByb3BzLnRleHR1cmUpIHtcbiAgICAgIHRoaXMuc2V0VGV4dHVyZShwcm9wcy50ZXh0dXJlKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlRlA2NChwcm9wcywgb2xkUHJvcHMpIHtcbiAgICBpZiAocHJvcHMuZnA2NCAhPT0gb2xkUHJvcHMuZnA2NCkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUubW9kZWwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5tb2RlbC5kZWxldGUoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRTdGF0ZSh7bW9kZWw6IHRoaXMuZ2V0TW9kZWwodGhpcy5jb250ZXh0LmdsKX0pO1xuXG4gICAgICB0aGlzLnNldFRleHR1cmUodGhpcy5zdGF0ZS50ZXh0dXJlKTtcblxuICAgICAgY29uc3QgYXR0cmlidXRlTWFuYWdlciA9IHRoaXMuZ2V0QXR0cmlidXRlTWFuYWdlcigpO1xuICAgICAgYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG4gICAgfVxuICB9XG5cbiAgZHJhdyh7dW5pZm9ybXN9KSB7XG4gICAgY29uc3Qge3NpemVTY2FsZX0gPSB0aGlzLnByb3BzO1xuXG4gICAgdGhpcy5zdGF0ZS5tb2RlbC5yZW5kZXIoXG4gICAgICBPYmplY3QuYXNzaWduKHt9LCB1bmlmb3Jtcywge1xuICAgICAgICBzaXplU2NhbGVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIGdldE1vZGVsKGdsKSB7XG4gICAgcmV0dXJuIG5ldyBNb2RlbChcbiAgICAgIGdsLFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5nZXRTaGFkZXJzKCksIHtcbiAgICAgICAgaWQ6IHRoaXMucHJvcHMuaWQsXG4gICAgICAgIGdlb21ldHJ5OiBnZXRHZW9tZXRyeSh0aGlzLnByb3BzLm1lc2gpLFxuICAgICAgICBpc0luc3RhbmNlZDogdHJ1ZSxcbiAgICAgICAgc2hhZGVyQ2FjaGU6IHRoaXMuY29udGV4dC5zaGFkZXJDYWNoZVxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgc2V0VGV4dHVyZShzcmMpIHtcbiAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuICAgIGNvbnN0IHttb2RlbCwgZW1wdHlUZXh0dXJlfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBpZiAoc3JjKSB7XG4gICAgICBnZXRUZXh0dXJlKGdsLCBzcmMpLnRoZW4odGV4dHVyZSA9PiB7XG4gICAgICAgIG1vZGVsLnNldFVuaWZvcm1zKHtzYW1wbGVyOiB0ZXh0dXJlLCBoYXNUZXh0dXJlOiAxfSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe3RleHR1cmV9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXNldFxuICAgICAgdGhpcy5zdGF0ZS5tb2RlbC5zZXRVbmlmb3Jtcyh7c2FtcGxlcjogZW1wdHlUZXh0dXJlLCBoYXNUZXh0dXJlOiAwfSk7XG4gICAgICB0aGlzLnNldFN0YXRlKHt0ZXh0dXJlOiBudWxsfSk7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldFBvc2l0aW9ufSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3ZhbHVlLCBzaXplfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBwb2ludCBvZiBkYXRhKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFBvc2l0aW9uKHBvaW50KTtcbiAgICAgIHZhbHVlW2ldID0gcG9zaXRpb25bMF07XG4gICAgICB2YWx1ZVtpICsgMV0gPSBwb3NpdGlvblsxXTtcbiAgICAgIHZhbHVlW2kgKyAyXSA9IHBvc2l0aW9uWzJdIHx8IDA7XG4gICAgICBpICs9IHNpemU7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnM2NHh5TG93KGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IGlzRlA2NCA9IHRoaXMudXNlNjRiaXRQb3NpdGlvbnMoKTtcbiAgICBhdHRyaWJ1dGUuY29uc3RhbnQgPSAhaXNGUDY0O1xuXG4gICAgaWYgKCFpc0ZQNjQpIHtcbiAgICAgIGF0dHJpYnV0ZS52YWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge2RhdGEsIGdldFBvc2l0aW9ufSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3ZhbHVlfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBwb2ludCBvZiBkYXRhKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFBvc2l0aW9uKHBvaW50KTtcbiAgICAgIHZhbHVlW2krK10gPSBmcDY0TG93UGFydChwb3NpdGlvblswXSk7XG4gICAgICB2YWx1ZVtpKytdID0gZnA2NExvd1BhcnQocG9zaXRpb25bMV0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIHlhdyh6KSwgcGl0Y2goeSkgYW5kIHJvbGwoeCkgaW4gcmFkaWFuc1xuICBjYWxjdWxhdGVJbnN0YW5jZVJvdGF0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7ZGF0YSwgZ2V0WWF3LCBnZXRQaXRjaCwgZ2V0Um9sbH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHt2YWx1ZSwgc2l6ZX0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3QgcG9pbnQgb2YgZGF0YSkge1xuICAgICAgdmFsdWVbaSsrXSA9IGdldFJvbGwocG9pbnQpICogUkFESUFOX1BFUl9ERUdSRUU7XG4gICAgICB2YWx1ZVtpKytdID0gZ2V0UGl0Y2gocG9pbnQpICogUkFESUFOX1BFUl9ERUdSRUU7XG4gICAgICB2YWx1ZVtpKytdID0gZ2V0WWF3KHBvaW50KSAqIFJBRElBTl9QRVJfREVHUkVFO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlQ29sb3JzKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhLCBnZXRDb2xvcn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHt2YWx1ZX0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3QgcG9pbnQgb2YgZGF0YSkge1xuICAgICAgY29uc3QgY29sb3IgPSBnZXRDb2xvcihwb2ludCkgfHwgREVGQVVMVF9DT0xPUjtcbiAgICAgIHZhbHVlW2krK10gPSBjb2xvclswXTtcbiAgICAgIHZhbHVlW2krK10gPSBjb2xvclsxXTtcbiAgICAgIHZhbHVlW2krK10gPSBjb2xvclsyXTtcbiAgICAgIHZhbHVlW2krK10gPSBpc05hTihjb2xvclszXSkgPyAyNTUgOiBjb2xvclszXTtcbiAgICB9XG4gIH1cbn1cblxuTWVzaExheWVyLmxheWVyTmFtZSA9ICdNZXNoTGF5ZXInO1xuTWVzaExheWVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbiJdfQ==