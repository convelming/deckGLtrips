"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@deck.gl/core");

var _luma = require("luma.gl");

var _tripsLayerVertex = _interopRequireDefault(require("./trips-layer-vertex.glsl"));

var _tripsLayerFragment = _interopRequireDefault(require("./trips-layer-fragment.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var defaultProps = {
  trailLength: 120,
  currentTime: 0,
  getPath: function getPath(d) {
    return d.path;
  },
  getColor: function getColor(d) {
    return d.color;
  }
};

var TripsLayer =
/*#__PURE__*/
function (_Layer) {
  _inherits(TripsLayer, _Layer);

  function TripsLayer() {
    _classCallCheck(this, TripsLayer);

    return _possibleConstructorReturn(this, _getPrototypeOf(TripsLayer).apply(this, arguments));
  }

  _createClass(TripsLayer, [{
    key: "initializeState",
    value: function initializeState() {
      var gl = this.context.gl;
      var attributeManager = this.getAttributeManager();
      var model = this.getModel(gl);
      attributeManager.add({
        indices: {
          size: 1,
          update: this.calculateIndices,
          isIndexed: true
        },
        positions: {
          size: 3,
          update: this.calculatePositions
        },
        colors: {
          size: 3,
          accessor: 'getColor',
          update: this.calculateColors
        }
      });
      gl.getExtension('OES_element_index_uint');
      this.setState({
        model: model
      });
    }
  }, {
    key: "updateState",
    value: function updateState(_ref) {
      var props = _ref.props,
          dataChanged = _ref.changeFlags.dataChanged;

      if (dataChanged) {
        this.countVertices(props.data);
        this.state.attributeManager.invalidateAll();
      }
    }
  }, {
    key: "getModel",
    value: function getModel(gl) {
      return new _luma.Model(gl, {
        id: this.props.id,
        vs: _tripsLayerVertex.default,
        fs: _tripsLayerFragment.default,
        geometry: new _luma.Geometry({
          id: this.props.id,
          drawMode: 'LINES'
        }),
        vertexCount: 0,
        isIndexed: true,
        // TODO-state-management: onBeforeRender can go to settings, onAfterRender, we should
        // move this settings of corresponding draw.
        onBeforeRender: function onBeforeRender() {
          gl.enable(gl.BLEND);
          gl.enable(gl.POLYGON_OFFSET_FILL);
          gl.polygonOffset(2.0, 1.0);
          gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
          gl.blendEquation(gl.FUNC_ADD);
        },
        onAfterRender: function onAfterRender() {
          gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
          gl.disable(gl.POLYGON_OFFSET_FILL);
        }
      });
    }
  }, {
    key: "countVertices",
    value: function countVertices(data) {
      if (!data) {
        return;
      }

      var getPath = this.props.getPath;
      var vertexCount = 0;
      var pathLengths = data.reduce(function (acc, d) {
        var l = getPath(d).length;
        vertexCount += l;
        return _toConsumableArray(acc).concat([l]);
      }, []);
      this.setState({
        pathLengths: pathLengths,
        vertexCount: vertexCount
      });
    }
  }, {
    key: "draw",
    value: function draw(_ref2) {
      var uniforms = _ref2.uniforms;
      var _this$props = this.props,
          trailLength = _this$props.trailLength,
          currentTime = _this$props.currentTime;
      this.state.model.render(Object.assign({}, uniforms, {
        trailLength: trailLength,
        currentTime: currentTime
      }));
    }
  }, {
    key: "calculateIndices",
    value: function calculateIndices(attribute) {
      var _this$state = this.state,
          pathLengths = _this$state.pathLengths,
          vertexCount = _this$state.vertexCount;
      var indicesCount = (vertexCount - pathLengths.length) * 2;
      var indices = new Uint32Array(indicesCount);
      var offset = 0;
      var index = 0;

      for (var i = 0; i < pathLengths.length; i++) {
        var l = pathLengths[i];
        indices[index++] = offset;

        for (var j = 1; j < l - 1; j++) {
          indices[index++] = j + offset;
          indices[index++] = j + offset;
        }

        indices[index++] = offset + l - 1;
        offset += l;
      }

      attribute.value = indices;
      this.state.model.setVertexCount(indicesCount);
    }
  }, {
    key: "calculatePositions",
    value: function calculatePositions(attribute) {
      var _this$props2 = this.props,
          data = _this$props2.data,
          getPath = _this$props2.getPath;
      var vertexCount = this.state.vertexCount;
      var positions = new Float32Array(vertexCount * 3);
      var index = 0;

      for (var i = 0; i < data.length; i++) {
        var path = getPath(data[i]);

        for (var j = 0; j < path.length; j++) {
          var pt = path[j];
          positions[index++] = pt[0];
          positions[index++] = pt[1];
          positions[index++] = pt[2];
        }
      }

      attribute.value = positions;
    }
  }, {
    key: "calculateColors",
    value: function calculateColors(attribute) {
      var _this$props3 = this.props,
          data = _this$props3.data,
          getColor = _this$props3.getColor;
      var _this$state2 = this.state,
          pathLengths = _this$state2.pathLengths,
          vertexCount = _this$state2.vertexCount;
      var colors = new Float32Array(vertexCount * 3);
      var index = 0;

      for (var i = 0; i < data.length; i++) {
        var color = getColor(data[i]);
        var l = pathLengths[i];

        for (var j = 0; j < l; j++) {
          colors[index++] = color[0];
          colors[index++] = color[1];
          colors[index++] = color[2];
        }
      }

      attribute.value = colors;
    }
  }]);

  return TripsLayer;
}(_core.Layer);

exports.default = TripsLayer;
TripsLayer.layerName = 'TripsLayer';
TripsLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90cmlwcy1sYXllci90cmlwcy1sYXllci5qcyJdLCJuYW1lcyI6WyJkZWZhdWx0UHJvcHMiLCJ0cmFpbExlbmd0aCIsImN1cnJlbnRUaW1lIiwiZ2V0UGF0aCIsImQiLCJwYXRoIiwiZ2V0Q29sb3IiLCJjb2xvciIsIlRyaXBzTGF5ZXIiLCJnbCIsImNvbnRleHQiLCJhdHRyaWJ1dGVNYW5hZ2VyIiwiZ2V0QXR0cmlidXRlTWFuYWdlciIsIm1vZGVsIiwiZ2V0TW9kZWwiLCJhZGQiLCJpbmRpY2VzIiwic2l6ZSIsInVwZGF0ZSIsImNhbGN1bGF0ZUluZGljZXMiLCJpc0luZGV4ZWQiLCJwb3NpdGlvbnMiLCJjYWxjdWxhdGVQb3NpdGlvbnMiLCJjb2xvcnMiLCJhY2Nlc3NvciIsImNhbGN1bGF0ZUNvbG9ycyIsImdldEV4dGVuc2lvbiIsInNldFN0YXRlIiwicHJvcHMiLCJkYXRhQ2hhbmdlZCIsImNoYW5nZUZsYWdzIiwiY291bnRWZXJ0aWNlcyIsImRhdGEiLCJzdGF0ZSIsImludmFsaWRhdGVBbGwiLCJNb2RlbCIsImlkIiwidnMiLCJ0cmlwc1ZlcnRleCIsImZzIiwidHJpcHNGcmFnbWVudCIsImdlb21ldHJ5IiwiR2VvbWV0cnkiLCJkcmF3TW9kZSIsInZlcnRleENvdW50Iiwib25CZWZvcmVSZW5kZXIiLCJlbmFibGUiLCJCTEVORCIsIlBPTFlHT05fT0ZGU0VUX0ZJTEwiLCJwb2x5Z29uT2Zmc2V0IiwiYmxlbmRGdW5jIiwiU1JDX0FMUEhBIiwiT05FIiwiYmxlbmRFcXVhdGlvbiIsIkZVTkNfQUREIiwib25BZnRlclJlbmRlciIsIk9ORV9NSU5VU19TUkNfQUxQSEEiLCJkaXNhYmxlIiwicGF0aExlbmd0aHMiLCJyZWR1Y2UiLCJhY2MiLCJsIiwibGVuZ3RoIiwidW5pZm9ybXMiLCJyZW5kZXIiLCJPYmplY3QiLCJhc3NpZ24iLCJhdHRyaWJ1dGUiLCJpbmRpY2VzQ291bnQiLCJVaW50MzJBcnJheSIsIm9mZnNldCIsImluZGV4IiwiaSIsImoiLCJ2YWx1ZSIsInNldFZlcnRleENvdW50IiwiRmxvYXQzMkFycmF5IiwicHQiLCJMYXllciIsImxheWVyTmFtZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUVBOztBQUVBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUFNQSxZQUFZLEdBQUc7QUFDbkJDLEVBQUFBLFdBQVcsRUFBRSxHQURNO0FBRW5CQyxFQUFBQSxXQUFXLEVBQUUsQ0FGTTtBQUduQkMsRUFBQUEsT0FBTyxFQUFFLGlCQUFBQyxDQUFDO0FBQUEsV0FBSUEsQ0FBQyxDQUFDQyxJQUFOO0FBQUEsR0FIUztBQUluQkMsRUFBQUEsUUFBUSxFQUFFLGtCQUFBRixDQUFDO0FBQUEsV0FBSUEsQ0FBQyxDQUFDRyxLQUFOO0FBQUE7QUFKUSxDQUFyQjs7SUFPcUJDLFU7Ozs7Ozs7Ozs7Ozs7c0NBQ0Q7QUFBQSxVQUNUQyxFQURTLEdBQ0gsS0FBS0MsT0FERixDQUNURCxFQURTO0FBRWhCLFVBQU1FLGdCQUFnQixHQUFHLEtBQUtDLG1CQUFMLEVBQXpCO0FBRUEsVUFBTUMsS0FBSyxHQUFHLEtBQUtDLFFBQUwsQ0FBY0wsRUFBZCxDQUFkO0FBRUFFLE1BQUFBLGdCQUFnQixDQUFDSSxHQUFqQixDQUFxQjtBQUNuQkMsUUFBQUEsT0FBTyxFQUFFO0FBQUNDLFVBQUFBLElBQUksRUFBRSxDQUFQO0FBQVVDLFVBQUFBLE1BQU0sRUFBRSxLQUFLQyxnQkFBdkI7QUFBeUNDLFVBQUFBLFNBQVMsRUFBRTtBQUFwRCxTQURVO0FBRW5CQyxRQUFBQSxTQUFTLEVBQUU7QUFBQ0osVUFBQUEsSUFBSSxFQUFFLENBQVA7QUFBVUMsVUFBQUEsTUFBTSxFQUFFLEtBQUtJO0FBQXZCLFNBRlE7QUFHbkJDLFFBQUFBLE1BQU0sRUFBRTtBQUFDTixVQUFBQSxJQUFJLEVBQUUsQ0FBUDtBQUFVTyxVQUFBQSxRQUFRLEVBQUUsVUFBcEI7QUFBZ0NOLFVBQUFBLE1BQU0sRUFBRSxLQUFLTztBQUE3QztBQUhXLE9B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QUNBdkUsVUFBVSxDQUFDUixZQUFYLEdBQTBCQSxZQUExQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7TGF5ZXJ9IGZyb20gJ0BkZWNrLmdsL2NvcmUnO1xuXG5pbXBvcnQge01vZGVsLCBHZW9tZXRyeX0gZnJvbSAnbHVtYS5nbCc7XG5cbmltcG9ydCB0cmlwc1ZlcnRleCBmcm9tICcuL3RyaXBzLWxheWVyLXZlcnRleC5nbHNsJztcbmltcG9ydCB0cmlwc0ZyYWdtZW50IGZyb20gJy4vdHJpcHMtbGF5ZXItZnJhZ21lbnQuZ2xzbCc7XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgdHJhaWxMZW5ndGg6IDEyMCxcbiAgY3VycmVudFRpbWU6IDAsXG4gIGdldFBhdGg6IGQgPT4gZC5wYXRoLFxuICBnZXRDb2xvcjogZCA9PiBkLmNvbG9yXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUcmlwc0xheWVyIGV4dGVuZHMgTGF5ZXIge1xuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgY29uc3Qge2dsfSA9IHRoaXMuY29udGV4dDtcbiAgICBjb25zdCBhdHRyaWJ1dGVNYW5hZ2VyID0gdGhpcy5nZXRBdHRyaWJ1dGVNYW5hZ2VyKCk7XG5cbiAgICBjb25zdCBtb2RlbCA9IHRoaXMuZ2V0TW9kZWwoZ2wpO1xuXG4gICAgYXR0cmlidXRlTWFuYWdlci5hZGQoe1xuICAgICAgaW5kaWNlczoge3NpemU6IDEsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbmRpY2VzLCBpc0luZGV4ZWQ6IHRydWV9LFxuICAgICAgcG9zaXRpb25zOiB7c2l6ZTogMywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZVBvc2l0aW9uc30sXG4gICAgICBjb2xvcnM6IHtzaXplOiAzLCBhY2Nlc3NvcjogJ2dldENvbG9yJywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUNvbG9yc31cbiAgICB9KTtcblxuICAgIGdsLmdldEV4dGVuc2lvbignT0VTX2VsZW1lbnRfaW5kZXhfdWludCcpO1xuICAgIHRoaXMuc2V0U3RhdGUoe21vZGVsfSk7XG4gIH1cblxuICB1cGRhdGVTdGF0ZSh7cHJvcHMsIGNoYW5nZUZsYWdzOiB7ZGF0YUNoYW5nZWR9fSkge1xuICAgIGlmIChkYXRhQ2hhbmdlZCkge1xuICAgICAgdGhpcy5jb3VudFZlcnRpY2VzKHByb3BzLmRhdGEpO1xuICAgICAgdGhpcy5zdGF0ZS5hdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGVBbGwoKTtcbiAgICB9XG4gIH1cblxuICBnZXRNb2RlbChnbCkge1xuICAgIHJldHVybiBuZXcgTW9kZWwoZ2wsIHtcbiAgICAgIGlkOiB0aGlzLnByb3BzLmlkLFxuICAgICAgdnM6IHRyaXBzVmVydGV4LFxuICAgICAgZnM6IHRyaXBzRnJhZ21lbnQsXG4gICAgICBnZW9tZXRyeTogbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgaWQ6IHRoaXMucHJvcHMuaWQsXG4gICAgICAgIGRyYXdNb2RlOiAnTElORVMnXG4gICAgICB9KSxcbiAgICAgIHZlcnRleENvdW50OiAwLFxuICAgICAgaXNJbmRleGVkOiB0cnVlLFxuICAgICAgLy8gVE9ETy1zdGF0ZS1tYW5hZ2VtZW50OiBvbkJlZm9yZVJlbmRlciBjYW4gZ28gdG8gc2V0dGluZ3MsIG9uQWZ0ZXJSZW5kZXIsIHdlIHNob3VsZFxuICAgICAgLy8gbW92ZSB0aGlzIHNldHRpbmdzIG9mIGNvcnJlc3BvbmRpbmcgZHJhdy5cbiAgICAgIG9uQmVmb3JlUmVuZGVyOiAoKSA9PiB7XG4gICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgICAgIGdsLmVuYWJsZShnbC5QT0xZR09OX09GRlNFVF9GSUxMKTtcbiAgICAgICAgZ2wucG9seWdvbk9mZnNldCgyLjAsIDEuMCk7XG4gICAgICAgIGdsLmJsZW5kRnVuYyhnbC5TUkNfQUxQSEEsIGdsLk9ORSk7XG4gICAgICAgIGdsLmJsZW5kRXF1YXRpb24oZ2wuRlVOQ19BREQpO1xuICAgICAgfSxcbiAgICAgIG9uQWZ0ZXJSZW5kZXI6ICgpID0+IHtcbiAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgICAgIGdsLmRpc2FibGUoZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb3VudFZlcnRpY2VzKGRhdGEpIHtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7Z2V0UGF0aH0gPSB0aGlzLnByb3BzO1xuICAgIGxldCB2ZXJ0ZXhDb3VudCA9IDA7XG4gICAgY29uc3QgcGF0aExlbmd0aHMgPSBkYXRhLnJlZHVjZSgoYWNjLCBkKSA9PiB7XG4gICAgICBjb25zdCBsID0gZ2V0UGF0aChkKS5sZW5ndGg7XG4gICAgICB2ZXJ0ZXhDb3VudCArPSBsO1xuICAgICAgcmV0dXJuIFsuLi5hY2MsIGxdO1xuICAgIH0sIFtdKTtcbiAgICB0aGlzLnNldFN0YXRlKHtwYXRoTGVuZ3RocywgdmVydGV4Q291bnR9KTtcbiAgfVxuXG4gIGRyYXcoe3VuaWZvcm1zfSkge1xuICAgIGNvbnN0IHt0cmFpbExlbmd0aCwgY3VycmVudFRpbWV9ID0gdGhpcy5wcm9wcztcbiAgICB0aGlzLnN0YXRlLm1vZGVsLnJlbmRlcihcbiAgICAgIE9iamVjdC5hc3NpZ24oe30sIHVuaWZvcm1zLCB7XG4gICAgICAgIHRyYWlsTGVuZ3RoLFxuICAgICAgICBjdXJyZW50VGltZVxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgY2FsY3VsYXRlSW5kaWNlcyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7cGF0aExlbmd0aHMsIHZlcnRleENvdW50fSA9IHRoaXMuc3RhdGU7XG5cbiAgICBjb25zdCBpbmRpY2VzQ291bnQgPSAodmVydGV4Q291bnQgLSBwYXRoTGVuZ3Rocy5sZW5ndGgpICogMjtcbiAgICBjb25zdCBpbmRpY2VzID0gbmV3IFVpbnQzMkFycmF5KGluZGljZXNDb3VudCk7XG5cbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aExlbmd0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGwgPSBwYXRoTGVuZ3Roc1tpXTtcbiAgICAgIGluZGljZXNbaW5kZXgrK10gPSBvZmZzZXQ7XG4gICAgICBmb3IgKGxldCBqID0gMTsgaiA8IGwgLSAxOyBqKyspIHtcbiAgICAgICAgaW5kaWNlc1tpbmRleCsrXSA9IGogKyBvZmZzZXQ7XG4gICAgICAgIGluZGljZXNbaW5kZXgrK10gPSBqICsgb2Zmc2V0O1xuICAgICAgfVxuICAgICAgaW5kaWNlc1tpbmRleCsrXSA9IG9mZnNldCArIGwgLSAxO1xuICAgICAgb2Zmc2V0ICs9IGw7XG4gICAgfVxuICAgIGF0dHJpYnV0ZS52YWx1ZSA9IGluZGljZXM7XG4gICAgdGhpcy5zdGF0ZS5tb2RlbC5zZXRWZXJ0ZXhDb3VudChpbmRpY2VzQ291bnQpO1xuICB9XG5cbiAgY2FsY3VsYXRlUG9zaXRpb25zKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhLCBnZXRQYXRofSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3ZlcnRleENvdW50fSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0ZXhDb3VudCAqIDMpO1xuXG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBhdGggPSBnZXRQYXRoKGRhdGFbaV0pO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwYXRoLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IHB0ID0gcGF0aFtqXTtcbiAgICAgICAgcG9zaXRpb25zW2luZGV4KytdID0gcHRbMF07XG4gICAgICAgIHBvc2l0aW9uc1tpbmRleCsrXSA9IHB0WzFdO1xuICAgICAgICBwb3NpdGlvbnNbaW5kZXgrK10gPSBwdFsyXTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXR0cmlidXRlLnZhbHVlID0gcG9zaXRpb25zO1xuICB9XG5cbiAgY2FsY3VsYXRlQ29sb3JzKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhLCBnZXRDb2xvcn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHtwYXRoTGVuZ3RocywgdmVydGV4Q291bnR9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KHZlcnRleENvdW50ICogMyk7XG5cbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY29sb3IgPSBnZXRDb2xvcihkYXRhW2ldKTtcbiAgICAgIGNvbnN0IGwgPSBwYXRoTGVuZ3Roc1tpXTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbDsgaisrKSB7XG4gICAgICAgIGNvbG9yc1tpbmRleCsrXSA9IGNvbG9yWzBdO1xuICAgICAgICBjb2xvcnNbaW5kZXgrK10gPSBjb2xvclsxXTtcbiAgICAgICAgY29sb3JzW2luZGV4KytdID0gY29sb3JbMl07XG4gICAgICB9XG4gICAgfVxuICAgIGF0dHJpYnV0ZS52YWx1ZSA9IGNvbG9ycztcbiAgfVxufVxuXG5Ucmlwc0xheWVyLmxheWVyTmFtZSA9ICdUcmlwc0xheWVyJztcblRyaXBzTGF5ZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuIl19