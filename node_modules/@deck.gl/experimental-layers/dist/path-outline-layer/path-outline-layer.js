"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _layers = require("@deck.gl/layers");

var _constants = _interopRequireDefault(require("luma.gl/constants"));

var _luma = require("luma.gl");

var _outline = _interopRequireDefault(require("../shaderlib/outline/outline"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// TODO - this should be built into assembleShaders
function injectShaderCode(_ref) {
  var source = _ref.source,
      _ref$declarations = _ref.declarations,
      declarations = _ref$declarations === void 0 ? '' : _ref$declarations,
      _ref$code = _ref.code,
      code = _ref$code === void 0 ? '' : _ref$code;
  var INJECT_DECLARATIONS = /^/;
  var INJECT_CODE = /}[^{}]*$/;
  return source.replace(INJECT_DECLARATIONS, declarations).replace(INJECT_CODE, code.concat('\n}\n'));
}

var VS_DECLARATIONS = "#ifdef MODULE_OUTLINE\n  attribute float instanceZLevel;\n#endif\n";
var VS_CODE = "#ifdef MODULE_OUTLINE\n  outline_setUV(gl_Position);\n  outline_setZLevel(instanceZLevel);\n#endif\n";
var FS_CODE = "#ifdef MODULE_OUTLINE\n  gl_FragColor = outline_filterColor(gl_FragColor);\n#endif\n";
var defaultProps = {
  getZLevel: function getZLevel(object) {
    return object.zLevel | 0;
  }
};

var PathOutlineLayer =
/*#__PURE__*/
function (_PathLayer) {
  _inherits(PathOutlineLayer, _PathLayer);

  function PathOutlineLayer() {
    _classCallCheck(this, PathOutlineLayer);

    return _possibleConstructorReturn(this, _getPrototypeOf(PathOutlineLayer).apply(this, arguments));
  }

  _createClass(PathOutlineLayer, [{
    key: "getShaders",
    // Override getShaders to inject the outline module
    value: function getShaders() {
      var shaders = _get(_getPrototypeOf(PathOutlineLayer.prototype), "getShaders", this).call(this);

      return Object.assign({}, shaders, {
        modules: shaders.modules.concat([_outline.default]),
        vs: injectShaderCode({
          source: shaders.vs,
          declarations: VS_DECLARATIONS,
          code: VS_CODE
        }),
        fs: injectShaderCode({
          source: shaders.fs,
          code: FS_CODE
        })
      });
    }
  }, {
    key: "initializeState",
    value: function initializeState(context) {
      _get(_getPrototypeOf(PathOutlineLayer.prototype), "initializeState", this).call(this, context); // Create an outline "shadow" map
      // TODO - we should create a single outlineMap for all layers


      this.setState({
        outlineFramebuffer: new _luma.Framebuffer(context.gl),
        dummyTexture: new _luma.Texture2D(context.gl)
      }); // Create an attribute manager

      this.state.attributeManager.addInstanced({
        instanceZLevel: {
          size: 1,
          type: _constants.default.UNSIGNED_BYTE,
          update: this.calculateZLevels,
          accessor: 'getZLevel'
        }
      });
    } // Override draw to add render module

  }, {
    key: "draw",
    value: function draw(_ref2) {
      var _ref2$moduleParameter = _ref2.moduleParameters,
          moduleParameters = _ref2$moduleParameter === void 0 ? {} : _ref2$moduleParameter,
          parameters = _ref2.parameters,
          uniforms = _ref2.uniforms,
          context = _ref2.context;
      // Need to calculate same uniforms as base layer
      var _this$props = this.props,
          rounded = _this$props.rounded,
          miterLimit = _this$props.miterLimit,
          widthScale = _this$props.widthScale,
          widthMinPixels = _this$props.widthMinPixels,
          widthMaxPixels = _this$props.widthMaxPixels,
          dashJustified = _this$props.dashJustified;
      uniforms = Object.assign({}, uniforms, {
        jointType: Number(rounded),
        alignMode: Number(dashJustified),
        widthScale: widthScale,
        miterLimit: miterLimit,
        widthMinPixels: widthMinPixels,
        widthMaxPixels: widthMaxPixels
      }); // Render the outline shadowmap (based on segment z orders)

      var _this$state = this.state,
          outlineFramebuffer = _this$state.outlineFramebuffer,
          dummyTexture = _this$state.dummyTexture;
      outlineFramebuffer.resize();
      outlineFramebuffer.clear({
        color: true,
        depth: true
      });
      this.state.model.updateModuleSettings({
        outlineEnabled: true,
        outlineRenderShadowmap: true,
        outlineShadowmap: dummyTexture
      });
      this.state.model.draw({
        uniforms: Object.assign({}, uniforms, {
          jointType: 0,
          widthScale: this.props.widthScale * 1.3
        }),
        parameters: {
          depthTest: false,
          blendEquation: _constants.default.MAX // Biggest value needs to go into buffer

        },
        framebuffer: outlineFramebuffer
      }); // Now use the outline shadowmap to render the lines (with outlines)

      this.state.model.updateModuleSettings({
        outlineEnabled: true,
        outlineRenderShadowmap: false,
        outlineShadowmap: outlineFramebuffer
      });
      this.state.model.draw({
        uniforms: Object.assign({}, uniforms, {
          jointType: Number(rounded),
          widthScale: this.props.widthScale
        }),
        parameters: {
          depthTest: false
        }
      });
    }
  }, {
    key: "calculateZLevels",
    value: function calculateZLevels(attribute) {
      var _this$props2 = this.props,
          data = _this$props2.data,
          getZLevel = _this$props2.getZLevel;
      var paths = this.state.paths;
      var value = attribute.value;
      var i = 0;
      paths.forEach(function (path, index) {
        var zLevel = getZLevel(data[index], index);
        zLevel = isNaN(zLevel) ? 0 : zLevel;

        for (var ptIndex = 1; ptIndex < path.length; ptIndex++) {
          value[i++] = zLevel;
        }
      });
    }
  }]);

  return PathOutlineLayer;
}(_layers.PathLayer);

exports.default = PathOutlineLayer;
PathOutlineLayer.layerName = 'PathOutlineLayer';
PathOutlineLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wYXRoLW91dGxpbmUtbGF5ZXIvcGF0aC1vdXRsaW5lLWxheWVyLmpzIl0sIm5hbWVzIjpbImluamVjdFNoYWRlckNvZGUiLCJzb3VyY2UiLCJkZWNsYXJhdGlvbnMiLCJjb2RlIiwiSU5KRUNUX0RFQ0xBUkFUSU9OUyIsIklOSkVDVF9DT0RFIiwicmVwbGFjZSIsImNvbmNhdCIsIlZTX0RFQ0xBUkFUSU9OUyIsIlZTX0NPREUiLCJGU19DT0RFIiwiZGVmYXVsdFByb3BzIiwiZ2V0WkxldmVsIiwib2JqZWN0IiwiekxldmVsIiwiUGF0aE91dGxpbmVMYXllciIsInNoYWRlcnMiLCJPYmplY3QiLCJhc3NpZ24iLCJtb2R1bGVzIiwib3V0bGluZSIsInZzIiwiZnMiLCJjb250ZXh0Iiwic2V0U3RhdGUiLCJvdXRsaW5lRnJhbWVidWZmZXIiLCJGcmFtZWJ1ZmZlciIsImdsIiwiZHVtbXlUZXh0dXJlIiwiVGV4dHVyZTJEIiwic3RhdGUiLCJhdHRyaWJ1dGVNYW5hZ2VyIiwiYWRkSW5zdGFuY2VkIiwiaW5zdGFuY2VaTGV2ZWwiLCJzaXplIiwidHlwZSIsIkdMIiwiVU5TSUdORURfQllURSIsInVwZGF0ZSIsImNhbGN1bGF0ZVpMZXZlbHMiLCJhY2Nlc3NvciIsIm1vZHVsZVBhcmFtZXRlcnMiLCJwYXJhbWV0ZXJzIiwidW5pZm9ybXMiLCJwcm9wcyIsInJvdW5kZWQiLCJtaXRlckxpbWl0Iiwid2lkdGhTY2FsZSIsIndpZHRoTWluUGl4ZWxzIiwid2lkdGhNYXhQaXhlbHMiLCJkYXNoSnVzdGlmaWVkIiwiam9pbnRUeXBlIiwiTnVtYmVyIiwiYWxpZ25Nb2RlIiwicmVzaXplIiwiY2xlYXIiLCJjb2xvciIsImRlcHRoIiwibW9kZWwiLCJ1cGRhdGVNb2R1bGVTZXR0aW5ncyIsIm91dGxpbmVFbmFibGVkIiwib3V0bGluZVJlbmRlclNoYWRvd21hcCIsIm91dGxpbmVTaGFkb3dtYXAiLCJkcmF3IiwiZGVwdGhUZXN0IiwiYmxlbmRFcXVhdGlvbiIsIk1BWCIsImZyYW1lYnVmZmVyIiwiYXR0cmlidXRlIiwiZGF0YSIsInBhdGhzIiwidmFsdWUiLCJpIiwiZm9yRWFjaCIsInBhdGgiLCJpbmRleCIsImlzTmFOIiwicHRJbmRleCIsImxlbmd0aCIsIlBhdGhMYXllciIsImxheWVyTmFtZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBO0FBQ0EsU0FBU0EsZ0JBQVQsT0FBa0U7QUFBQSxNQUF2Q0MsTUFBdUMsUUFBdkNBLE1BQXVDO0FBQUEsK0JBQS9CQyxZQUErQjtBQUFBLE1BQS9CQSxZQUErQixrQ0FBaEIsRUFBZ0I7QUFBQSx1QkFBWkMsSUFBWTtBQUFBLE1BQVpBLElBQVksMEJBQUwsRUFBSztBQUNoRSxNQUFNQyxtQkFBbUIsR0FBRyxHQUE1QjtBQUNBLE1BQU1DLFdBQVcsR0FBRyxVQUFwQjtBQUVBLFNBQU9KLE1BQU0sQ0FDVkssT0FESSxDQUNJRixtQkFESixFQUN5QkYsWUFEekIsRUFFSkksT0FGSSxDQUVJRCxXQUZKLEVBRWlCRixJQUFJLENBQUNJLE1BQUwsQ0FBWSxPQUFaLENBRmpCLENBQVA7QUFHRDs7QUFFRCxJQUFNQyxlQUFlLHVFQUFyQjtBQU1BLElBQU1DLE9BQU8seUdBQWI7QUFPQSxJQUFNQyxPQUFPLHlGQUFiO0FBTUEsSUFBTUMsWUFBWSxHQUFHO0FBQ25CQyxFQUFBQSxTQUFTLEVBQUUsbUJBQUFDLE1BQU07QUFBQSxXQUFJQSxNQUFNLENBQUNDLE1BQVAsR0FBZ0IsQ0FBcEI7QUFBQTtBQURFLENBQXJCOztJQUlxQkMsZ0I7Ozs7Ozs7Ozs7Ozs7QUFDbkI7aUNBQ2E7QUFDWCxVQUFNQyxPQUFPLG1GQUFiOztBQUNBLGFBQU9DLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjLEVBQWQsRUFBa0JGLE9BQWxCLEVBQTJCO0FBQ2hDRyxRQUFBQSxPQUFPLEVBQUVILE9BQU8sQ0FBQ0csT0FBUixDQUFnQlosTUFBaEIsQ0FBdUIsQ0FBQ2EsZ0JB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QUFBLFVBRW5CMEQsS0FGbUIsR0FFVixLQUFLeEMsS0FGSyxDQUVuQndDLEtBRm1CO0FBQUEsVUFHbkJDLEtBSG1CLEdBR1ZILFNBSFUsQ0FHbkJHLEtBSG1CO0FBSzFCLFVBQUlDLENBQUMsR0FBRyxDQUFSO0FBQ0FGLE1BQUFBLEtBQUssQ0FBQ0csT0FBTixDQUFjLFVBQUNDLElBQUQsRUFBT0MsS0FBUCxFQUFpQjtBQUM3QixZQUFJN0QsTUFBTSxHQUFHRixTQUFTLENBQUN5RCxJQUFJLENBQUNNLEtBQUQsQ0FBTCxFQUFjQSxLQUFkLENBQXRCO0FBQ0E3RCxRQUFBQSxNQUFNLEdBQUc4RCxLQUFLLENBQUM5RCxNQUFELENBQUwsR0FBZ0IsQ0FBaEIsR0FBb0JBLE1BQTdCOztBQUNBLGFBQUssSUFBSStELE9BQU8sR0FBRyxDQUFuQixFQUFzQkEsT0FBTyxHQUFHSCxJQUFJLENBQUNJLE1BQXJDLEVBQTZDRCxPQUFPLEVBQXBELEVBQXdEO0FBQ3RETixVQUFBQSxLQUFLLENBQUNDLENBQUMsRUFBRixDQUFMLEdBQWExRCxNQUFiO0FBQ0Q7QUFDRixPQU5EO0FBT0Q7Ozs7RUExRzJDaUUsaUI7OztBQTZHOUNoRSxnQkFBZ0IsQ0FBQ2lFLFNBQWpCLEdBQTZCLGtCQUE3QjtBQUNBakUsZ0JBQWdCLENBQUNKLFlBQWpCLEdBQWdDQSxZQUFoQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7UGF0aExheWVyfSBmcm9tICdAZGVjay5nbC9sYXllcnMnO1xuaW1wb3J0IEdMIGZyb20gJ2x1bWEuZ2wvY29uc3RhbnRzJztcbmltcG9ydCB7RnJhbWVidWZmZXIsIFRleHR1cmUyRH0gZnJvbSAnbHVtYS5nbCc7XG5pbXBvcnQgb3V0bGluZSBmcm9tICcuLi9zaGFkZXJsaWIvb3V0bGluZS9vdXRsaW5lJztcblxuLy8gVE9ETyAtIHRoaXMgc2hvdWxkIGJlIGJ1aWx0IGludG8gYXNzZW1ibGVTaGFkZXJzXG5mdW5jdGlvbiBpbmplY3RTaGFkZXJDb2RlKHtzb3VyY2UsIGRlY2xhcmF0aW9ucyA9ICcnLCBjb2RlID0gJyd9KSB7XG4gIGNvbnN0IElOSkVDVF9ERUNMQVJBVElPTlMgPSAvXi87XG4gIGNvbnN0IElOSkVDVF9DT0RFID0gL31bXnt9XSokLztcblxuICByZXR1cm4gc291cmNlXG4gICAgLnJlcGxhY2UoSU5KRUNUX0RFQ0xBUkFUSU9OUywgZGVjbGFyYXRpb25zKVxuICAgIC5yZXBsYWNlKElOSkVDVF9DT0RFLCBjb2RlLmNvbmNhdCgnXFxufVxcbicpKTtcbn1cblxuY29uc3QgVlNfREVDTEFSQVRJT05TID0gYFxcXG4jaWZkZWYgTU9EVUxFX09VVExJTkVcbiAgYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlWkxldmVsO1xuI2VuZGlmXG5gO1xuXG5jb25zdCBWU19DT0RFID0gYFxcXG4jaWZkZWYgTU9EVUxFX09VVExJTkVcbiAgb3V0bGluZV9zZXRVVihnbF9Qb3NpdGlvbik7XG4gIG91dGxpbmVfc2V0WkxldmVsKGluc3RhbmNlWkxldmVsKTtcbiNlbmRpZlxuYDtcblxuY29uc3QgRlNfQ09ERSA9IGBcXFxuI2lmZGVmIE1PRFVMRV9PVVRMSU5FXG4gIGdsX0ZyYWdDb2xvciA9IG91dGxpbmVfZmlsdGVyQ29sb3IoZ2xfRnJhZ0NvbG9yKTtcbiNlbmRpZlxuYDtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBnZXRaTGV2ZWw6IG9iamVjdCA9PiBvYmplY3QuekxldmVsIHwgMFxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGF0aE91dGxpbmVMYXllciBleHRlbmRzIFBhdGhMYXllciB7XG4gIC8vIE92ZXJyaWRlIGdldFNoYWRlcnMgdG8gaW5qZWN0IHRoZSBvdXRsaW5lIG1vZHVsZVxuICBnZXRTaGFkZXJzKCkge1xuICAgIGNvbnN0IHNoYWRlcnMgPSBzdXBlci5nZXRTaGFkZXJzKCk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHNoYWRlcnMsIHtcbiAgICAgIG1vZHVsZXM6IHNoYWRlcnMubW9kdWxlcy5jb25jYXQoW291dGxpbmVdKSxcbiAgICAgIHZzOiBpbmplY3RTaGFkZXJDb2RlKHtzb3VyY2U6IHNoYWRlcnMudnMsIGRlY2xhcmF0aW9uczogVlNfREVDTEFSQVRJT05TLCBjb2RlOiBWU19DT0RFfSksXG4gICAgICBmczogaW5qZWN0U2hhZGVyQ29kZSh7c291cmNlOiBzaGFkZXJzLmZzLCBjb2RlOiBGU19DT0RFfSlcbiAgICB9KTtcbiAgfVxuXG4gIGluaXRpYWxpemVTdGF0ZShjb250ZXh0KSB7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZVN0YXRlKGNvbnRleHQpO1xuXG4gICAgLy8gQ3JlYXRlIGFuIG91dGxpbmUgXCJzaGFkb3dcIiBtYXBcbiAgICAvLyBUT0RPIC0gd2Ugc2hvdWxkIGNyZWF0ZSBhIHNpbmdsZSBvdXRsaW5lTWFwIGZvciBhbGwgbGF5ZXJzXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBvdXRsaW5lRnJhbWVidWZmZXI6IG5ldyBGcmFtZWJ1ZmZlcihjb250ZXh0LmdsKSxcbiAgICAgIGR1bW15VGV4dHVyZTogbmV3IFRleHR1cmUyRChjb250ZXh0LmdsKVxuICAgIH0pO1xuXG4gICAgLy8gQ3JlYXRlIGFuIGF0dHJpYnV0ZSBtYW5hZ2VyXG4gICAgdGhpcy5zdGF0ZS5hdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICBpbnN0YW5jZVpMZXZlbDoge1xuICAgICAgICBzaXplOiAxLFxuICAgICAgICB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLFxuICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlWkxldmVscyxcbiAgICAgICAgYWNjZXNzb3I6ICdnZXRaTGV2ZWwnXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBPdmVycmlkZSBkcmF3IHRvIGFkZCByZW5kZXIgbW9kdWxlXG4gIGRyYXcoe21vZHVsZVBhcmFtZXRlcnMgPSB7fSwgcGFyYW1ldGVycywgdW5pZm9ybXMsIGNvbnRleHR9KSB7XG4gICAgLy8gTmVlZCB0byBjYWxjdWxhdGUgc2FtZSB1bmlmb3JtcyBhcyBiYXNlIGxheWVyXG4gICAgY29uc3Qge1xuICAgICAgcm91bmRlZCxcbiAgICAgIG1pdGVyTGltaXQsXG4gICAgICB3aWR0aFNjYWxlLFxuICAgICAgd2lkdGhNaW5QaXhlbHMsXG4gICAgICB3aWR0aE1heFBpeGVscyxcbiAgICAgIGRhc2hKdXN0aWZpZWRcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIHVuaWZvcm1zID0gT2JqZWN0LmFzc2lnbih7fSwgdW5pZm9ybXMsIHtcbiAgICAgIGpvaW50VHlwZTogTnVtYmVyKHJvdW5kZWQpLFxuICAgICAgYWxpZ25Nb2RlOiBOdW1iZXIoZGFzaEp1c3RpZmllZCksXG4gICAgICB3aWR0aFNjYWxlLFxuICAgICAgbWl0ZXJMaW1pdCxcbiAgICAgIHdpZHRoTWluUGl4ZWxzLFxuICAgICAgd2lkdGhNYXhQaXhlbHNcbiAgICB9KTtcblxuICAgIC8vIFJlbmRlciB0aGUgb3V0bGluZSBzaGFkb3dtYXAgKGJhc2VkIG9uIHNlZ21lbnQgeiBvcmRlcnMpXG4gICAgY29uc3Qge291dGxpbmVGcmFtZWJ1ZmZlciwgZHVtbXlUZXh0dXJlfSA9IHRoaXMuc3RhdGU7XG4gICAgb3V0bGluZUZyYW1lYnVmZmVyLnJlc2l6ZSgpO1xuICAgIG91dGxpbmVGcmFtZWJ1ZmZlci5jbGVhcih7Y29sb3I6IHRydWUsIGRlcHRoOiB0cnVlfSk7XG5cbiAgICB0aGlzLnN0YXRlLm1vZGVsLnVwZGF0ZU1vZHVsZVNldHRpbmdzKHtcbiAgICAgIG91dGxpbmVFbmFibGVkOiB0cnVlLFxuICAgICAgb3V0bGluZVJlbmRlclNoYWRvd21hcDogdHJ1ZSxcbiAgICAgIG91dGxpbmVTaGFkb3dtYXA6IGR1bW15VGV4dHVyZVxuICAgIH0pO1xuXG4gICAgdGhpcy5zdGF0ZS5tb2RlbC5kcmF3KHtcbiAgICAgIHVuaWZvcm1zOiBPYmplY3QuYXNzaWduKHt9LCB1bmlmb3Jtcywge1xuICAgICAgICBqb2ludFR5cGU6IDAsXG4gICAgICAgIHdpZHRoU2NhbGU6IHRoaXMucHJvcHMud2lkdGhTY2FsZSAqIDEuM1xuICAgICAgfSksXG4gICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICAgIGJsZW5kRXF1YXRpb246IEdMLk1BWCAvLyBCaWdnZXN0IHZhbHVlIG5lZWRzIHRvIGdvIGludG8gYnVmZmVyXG4gICAgICB9LFxuICAgICAgZnJhbWVidWZmZXI6IG91dGxpbmVGcmFtZWJ1ZmZlclxuICAgIH0pO1xuXG4gICAgLy8gTm93IHVzZSB0aGUgb3V0bGluZSBzaGFkb3dtYXAgdG8gcmVuZGVyIHRoZSBsaW5lcyAod2l0aCBvdXRsaW5lcylcbiAgICB0aGlzLnN0YXRlLm1vZGVsLnVwZGF0ZU1vZHVsZVNldHRpbmdzKHtcbiAgICAgIG91dGxpbmVFbmFibGVkOiB0cnVlLFxuICAgICAgb3V0bGluZVJlbmRlclNoYWRvd21hcDogZmFsc2UsXG4gICAgICBvdXRsaW5lU2hhZG93bWFwOiBvdXRsaW5lRnJhbWVidWZmZXJcbiAgICB9KTtcbiAgICB0aGlzLnN0YXRlLm1vZGVsLmRyYXcoe1xuICAgICAgdW5pZm9ybXM6IE9iamVjdC5hc3NpZ24oe30sIHVuaWZvcm1zLCB7XG4gICAgICAgIGpvaW50VHlwZTogTnVtYmVyKHJvdW5kZWQpLFxuICAgICAgICB3aWR0aFNjYWxlOiB0aGlzLnByb3BzLndpZHRoU2NhbGVcbiAgICAgIH0pLFxuICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICBkZXB0aFRlc3Q6IGZhbHNlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjYWxjdWxhdGVaTGV2ZWxzKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhLCBnZXRaTGV2ZWx9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7cGF0aHN9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7dmFsdWV9ID0gYXR0cmlidXRlO1xuXG4gICAgbGV0IGkgPSAwO1xuICAgIHBhdGhzLmZvckVhY2goKHBhdGgsIGluZGV4KSA9PiB7XG4gICAgICBsZXQgekxldmVsID0gZ2V0WkxldmVsKGRhdGFbaW5kZXhdLCBpbmRleCk7XG4gICAgICB6TGV2ZWwgPSBpc05hTih6TGV2ZWwpID8gMCA6IHpMZXZlbDtcbiAgICAgIGZvciAobGV0IHB0SW5kZXggPSAxOyBwdEluZGV4IDwgcGF0aC5sZW5ndGg7IHB0SW5kZXgrKykge1xuICAgICAgICB2YWx1ZVtpKytdID0gekxldmVsO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cblBhdGhPdXRsaW5lTGF5ZXIubGF5ZXJOYW1lID0gJ1BhdGhPdXRsaW5lTGF5ZXInO1xuUGF0aE91dGxpbmVMYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4iXX0=