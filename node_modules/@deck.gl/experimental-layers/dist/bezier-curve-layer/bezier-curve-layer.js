"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@deck.gl/core");

var _constants = _interopRequireDefault(require("luma.gl/constants"));

var _luma = require("luma.gl");

var _bezierCurveLayerVertex = _interopRequireDefault(require("./bezier-curve-layer-vertex.glsl"));

var _bezierCurveLayerFragment = _interopRequireDefault(require("./bezier-curve-layer-fragment.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var fp64LowPart = _luma.fp64.fp64LowPart;
var NUM_SEGMENTS = 40;
var DEFAULT_COLOR = [0, 0, 0, 255];
var defaultProps = {
  strokeWidth: 1,
  fp64: false,
  getSourcePosition: function getSourcePosition(x) {
    return x.sourcePosition;
  },
  getTargetPosition: function getTargetPosition(x) {
    return x.targetPosition;
  },
  getControlPoint: function getControlPoint(x) {
    return x.controlPoint;
  },
  getColor: function getColor(x) {
    return x.color || DEFAULT_COLOR;
  }
};

var BezierCurveLayer =
/*#__PURE__*/
function (_Layer) {
  _inherits(BezierCurveLayer, _Layer);

  function BezierCurveLayer() {
    _classCallCheck(this, BezierCurveLayer);

    return _possibleConstructorReturn(this, _getPrototypeOf(BezierCurveLayer).apply(this, arguments));
  }

  _createClass(BezierCurveLayer, [{
    key: "getShaders",
    value: function getShaders() {
      return {
        vs: _bezierCurveLayerVertex.default,
        fs: _bezierCurveLayerFragment.default,
        modules: ['picking']
      };
    }
  }, {
    key: "initializeState",
    value: function initializeState() {
      var attributeManager = this.state.attributeManager;
      /* eslint-disable max-len */

      attributeManager.addInstanced({
        instanceSourcePositions: {
          size: 3,
          transition: true,
          accessor: 'getSourcePosition',
          update: this.calculateInstanceSourcePositions
        },
        instanceTargetPositions: {
          size: 3,
          transition: true,
          accessor: 'getTargetPosition',
          update: this.calculateInstanceTargetPositions
        },
        instanceControlPoints: {
          size: 3,
          transition: false,
          accessor: 'getControlPoint',
          update: this.calculateInstanceControlPoints
        },
        instanceColors: {
          size: 4,
          type: _constants.default.UNSIGNED_BYTE,
          transition: true,
          accessor: 'getColor',
          update: this.calculateInstanceColors
        }
      });
      /* eslint-enable max-len */
    }
  }, {
    key: "updateAttribute",
    value: function updateAttribute(_ref) {
      var props = _ref.props,
          oldProps = _ref.oldProps,
          changeFlags = _ref.changeFlags;

      if (props.fp64 !== oldProps.fp64) {
        var attributeManager = this.state.attributeManager;
        attributeManager.invalidateAll();
      }
    }
  }, {
    key: "updateState",
    value: function updateState(_ref2) {
      var props = _ref2.props,
          oldProps = _ref2.oldProps,
          changeFlags = _ref2.changeFlags;

      _get(_getPrototypeOf(BezierCurveLayer.prototype), "updateState", this).call(this, {
        props: props,
        oldProps: oldProps,
        changeFlags: changeFlags
      });

      if (props.fp64 !== oldProps.fp64) {
        var gl = this.context.gl;
        this.setState({
          model: this._getModel(gl)
        });
      }

      this.updateAttribute({
        props: props,
        oldProps: oldProps,
        changeFlags: changeFlags
      });
    }
  }, {
    key: "draw",
    value: function draw(_ref3) {
      var uniforms = _ref3.uniforms;
      var strokeWidth = this.props.strokeWidth;
      this.state.model.render(Object.assign({}, uniforms, {
        strokeWidth: strokeWidth
      }));
    }
  }, {
    key: "_getModel",
    value: function _getModel(gl) {
      /*
       *  (0, -1)-------------_(1, -1)
       *       |          _,-"  |
       *       o      _,-"      o
       *       |  _,-"          |
       *   (0, 1)"-------------(1, 1)
       */
      var positions = [];

      for (var i = 0; i <= NUM_SEGMENTS; i++) {
        positions = positions.concat([i, -1, 0, i, 1, 0]);
      }

      var model = new _luma.Model(gl, Object.assign({}, this.getShaders(), {
        id: this.props.id,
        geometry: new _luma.Geometry({
          drawMode: _constants.default.TRIANGLE_STRIP,
          attributes: {
            positions: new Float32Array(positions)
          }
        }),
        isInstanced: true,
        shaderCache: this.context.shaderCache
      }));
      model.setUniforms({
        numSegments: NUM_SEGMENTS
      });
      return model;
    }
  }, {
    key: "calculateInstanceSourcePositions",
    value: function calculateInstanceSourcePositions(attribute) {
      var _this$props = this.props,
          data = _this$props.data,
          getSourcePosition = _this$props.getSourcePosition;
      var value = attribute.value,
          size = attribute.size;
      var i = 0;
      data.forEach(function (object) {
        var sourcePosition = getSourcePosition(object);
        value[i + 0] = sourcePosition[0];
        value[i + 1] = sourcePosition[1];
        value[i + 2] = isNaN(sourcePosition[2]) ? 0 : sourcePosition[2];
        i += size;
      });
    }
  }, {
    key: "calculateInstanceTargetPositions",
    value: function calculateInstanceTargetPositions(attribute) {
      var _this$props2 = this.props,
          data = _this$props2.data,
          getTargetPosition = _this$props2.getTargetPosition;
      var value = attribute.value,
          size = attribute.size;
      var i = 0;
      data.forEach(function (object) {
        var targetPosition = getTargetPosition(object);
        value[i + 0] = targetPosition[0];
        value[i + 1] = targetPosition[1];
        value[i + 2] = isNaN(targetPosition[2]) ? 0 : targetPosition[2];
        i += size;
      });
    }
  }, {
    key: "calculateInstanceControlPoints",
    value: function calculateInstanceControlPoints(attribute) {
      var _this$props3 = this.props,
          data = _this$props3.data,
          getControlPoint = _this$props3.getControlPoint;
      var value = attribute.value,
          size = attribute.size;
      var i = 0;
      data.forEach(function (object) {
        var controlPoint = getControlPoint(object);
        value[i + 0] = controlPoint[0];
        value[i + 1] = controlPoint[1];
        value[i + 2] = isNaN(controlPoint[2]) ? 0 : controlPoint[2];
        i += size;
      });
    }
  }, {
    key: "calculateInstanceSourceTargetPositions64xyLow",
    value: function calculateInstanceSourceTargetPositions64xyLow(attribute) {
      var _this$props4 = this.props,
          data = _this$props4.data,
          getSourcePosition = _this$props4.getSourcePosition,
          getTargetPosition = _this$props4.getTargetPosition;
      var value = attribute.value,
          size = attribute.size;
      var i = 0;
      data.forEach(function (object) {
        var sourcePosition = getSourcePosition(object);
        var targetPosition = getTargetPosition(object);
        value[i + 0] = fp64LowPart(sourcePosition[0]);
        value[i + 1] = fp64LowPart(sourcePosition[1]);
        value[i + 2] = fp64LowPart(targetPosition[0]);
        value[i + 3] = fp64LowPart(targetPosition[1]);
        i += size;
      });
    }
  }, {
    key: "calculateInstanceColors",
    value: function calculateInstanceColors(attribute) {
      var _this$props5 = this.props,
          data = _this$props5.data,
          getColor = _this$props5.getColor;
      var value = attribute.value,
          size = attribute.size;
      var i = 0;
      data.forEach(function (object) {
        var color = getColor(object);
        value[i + 0] = color[0];
        value[i + 1] = color[1];
        value[i + 2] = color[2];
        value[i + 3] = isNaN(color[3]) ? 255 : color[3];
        i += size;
      });
    }
  }]);

  return BezierCurveLayer;
}(_core.Layer);

exports.default = BezierCurveLayer;
BezierCurveLayer.layerName = 'BezierCurveLayer';
BezierCurveLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9iZXppZXItY3VydmUtbGF5ZXIvYmV6aWVyLWN1cnZlLWxheWVyLmpzIl0sIm5hbWVzIjpbImZwNjRMb3dQYXJ0IiwiZnA2NCIsIk5VTV9TRUdNRU5UUyIsIkRFRkFVTFRfQ09MT1IiLCJkZWZhdWx0UHJvcHMiLCJzdHJva2VXaWR0aCIsImdldFNvdXJjZVBvc2l0aW9uIiwieCIsInNvdXJjZVBvc2l0aW9uIiwiZ2V0VGFyZ2V0UG9zaXRpb24iLCJ0YXJnZXRQb3NpdGlvbiIsImdldENvbnRyb2xQb2ludCIsImNvbnRyb2xQb2ludCIsImdldENvbG9yIiwiY29sb3IiLCJCZXppZXJDdXJ2ZUxheWVyIiwidnMiLCJmcyIsIm1vZHVsZXMiLCJhdHRyaWJ1dGVNYW5hZ2VyIiwic3RhdGUiLCJhZGRJbnN0YW5jZWQiLCJpbnN0YW5jZVNvdXJjZVBvc2l0aW9ucyIsInNpemUiLCJ0cmFuc2l0aW9uIiwiYWNjZXNzb3IiLCJ1cGRhdGUiLCJjYWxjdWxhdGVJbnN0YW5jZVNvdXJjZVBvc2l0aW9ucyIsImluc3RhbmNlVGFyZ2V0UG9zaXRpb25zIiwiY2FsY3VsYXRlSW5zdGFuY2VUYXJnZXRQb3NpdGlvbnMiLCJpbnN0YW5jZUNvbnRyb2xQb2ludHMiLCJjYWxjdWxhdGVJbnN0YW5jZUNvbnRyb2xQb2ludHMiLCJpbnN0YW5jZUNvbG9ycyIsInR5cGUiLCJHTCIsIlVOU0lHTkVEX0JZVEUiLCJjYWxjdWxhdGVJbnN0YW5jZUNvbG9ycyIsInByb3BzIiwib2xkUHJvcHMiLCJjaGFuZ2VGbGFncyIsImludmFsaWRhdGVBbGwiLCJnbCIsImNvbnRleHQiLCJzZXRTdGF0ZSIsIm1vZGVsIiwiX2dldE1vZGVsIiwidXBkYXRlQXR0cmlidXRlIiwidW5pZm9ybXMiLCJyZW5kZXIiLCJPYmplY3QiLCJhc3NpZ24iLCJwb3NpdGlvbnMiLCJpIiwiY29uY2F0IiwiTW9kZWwiLCJnZXRTaGFkZXJzIiwiaWQiLCJnZW9tZXRyeSIsIkdlb21ldHJ5IiwiZHJhd01vZGUiLCJUUklBTkdMRV9TVFJJUCIsImF0dHJpYnV0ZXMiLCJGbG9hdDMyQXJyYXkiLCJpc0luc3RhbmNlZCIsInNoYWRlckNhY2hlIiwic2V0VW5pZm9ybXMiLCJudW1TZWdtZW50cyIsImF0dHJpYnV0ZSIsImRhdGEiLCJ2YWx1ZSIsImZvckVhY2giLCJvYmplY3QiLCJpc05hTiIsIkxheWVyIiwibGF5ZXJOYW1lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBb0JBOztBQUNBOztBQUNBOztBQUdBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUhPQSxXLEdBQWVDLFUsQ0FBZkQsVztBQUtQLElBQU1FLFlBQVksR0FBRyxFQUFyQjtBQUNBLElBQU1DLGFBQWEsR0FBRyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLEdBQVYsQ0FBdEI7QUFFQSxJQUFNQyxZQUFZLEdBQUc7QUFDbkJDLEVBQUFBLFdBQVcsRUFBRSxDQURNO0FBRW5CSixFQUFBQSxJQUFJLEVBQUUsS0FGYTtBQUduQkssRUFBQUEsaUJBQWlCLEVBQUUsMkJBQUFDLENBQUM7QUFBQSxXQUFJQSxDQUFDLENBQUNDLGNBQU47QUFBQSxHQUhEO0FBSW5CQyxFQUFBQSxpQkFBaUIsRUFBRSwyQkFBQUYsQ0FBQztBQUFBLFdBQUlBLENBQUMsQ0FBQ0csY0FBTjtBQUFBLEdBSkQ7QUFLbkJDLEVBQUFBLGVBQWUsRUFBRSx5QkFBQUosQ0FBQztBQUFBLFdBQUlBLENBQUMsQ0FBQ0ssWUFBTjtBQUFBLEdBTEM7QUFNbkJDLEVBQUFBLFFBQVEsRUFBRSxrQkFBQU4sQ0FBQztBQUFBLFdBQUlBLENBQUMsQ0FBQ08sS0FBRixJQUFXWCxhQUFmO0FBQUE7QUFOUSxDQUFyQjs7SUFTcUJZLGdCOzs7Ozs7Ozs7Ozs7O2lDQUNOO0FBQ1gsYUFBTztBQUFDQyxRQUFBQSxFQUFFLEVBQUZBLCtCQUFEO0FBQUtDLFFBQUFBLEVBQUUsRUFBRkEsaUNBQUw7QUFBU0MsUUFBQUEsT0FBTyxFQUFFLENBQUMsU0FBRDtBQUFsQixPQUFQO0FBQ0Q7OztzQ0FFaUI7QUFBQSxVQUNUQyxnQkFEUyxHQUNXLEtBQUtDLEtBRGhCLENBQ1RELGdCQURTO0FBR2hCOztBQUNBQSxNQUFBQSxnQkFBZ0IsQ0FBQ0UsWUFBakIsQ0FBOEI7QUFDNUJDLFFBQUFBLHVCQUF1QixFQUFFO0FBQ3ZCQyxVQUFBQSxJQUFJLEVBQUUsQ0FEaUI7QUFFdkJDLFVBQUFBLFVBQVUsRUFBRSxJQUZXO0FBR3ZCQyxVQUFBQSxRQUFRLEVBQUUsbUJBSGE7QUFJdkJDLFVBQUFBLE1BQU0sRUFBRSxLQUFLQztBQUpVLFNBREc7QUFPNUJDLFFBQUFBLHVCQUF1QixFQUFFO0FBQ3ZCTCxVQUFBQSxJQUFJLEVBQUUsQ0FEaUI7QUFFdkJDLFVBQUFBLFVBQVUsRUFBRSxJQUZXO0FBR3ZCQyxVQUFBQSxRQUFRLEVBQUUsbUJBSGE7QUFJdkJDLFVBQUFBLE1BQU0sRUFBRSxLQUFLRztBQUpVLFNBUEc7QUFhNUJDLFFBQUFBLHFCQUFxQixFQUFFO0FBQ3JCUCxVQUFBQSxJQUFJLEVBQUUsQ0FEZTtBQUVyQkMsVUFBQUEsVUFBVSxFQUFFLEtBRlM7QUFHckJDLFVBQUFBLFFBQVEsRUFBRSxpQkFIVztBQUlyQkMsVUFBQUEsTUFBTSxFQUFFLEtBQUtLO0FBSlEsU0FiSztBQW1CNUJDLFFBQUFBLGNBQWMsRUFBRTtBQUNkVCxVQUFBQSxJQUFJLEVBQUUsQ0FEUTtBQUVkVSxVQUFBQSxJQUFJLEVBQUVDLG1CQUFHQyxhQUZLO0FBR2RYLFVBQUFBLFVBQVUsRUFBRSxJQUhFO0FBSWRDLFVBQUFBLFFBQVEsRUFBRSxVQUpJO0FBS2RDLFVBQUFBLE1BQU0sRUFBRSxLQUFLVTtBQUxDO0FBbkJZLE9BQTlCO0FBMkJBO0FBQ0Q7OzswQ0FFK0M7QUFBQSxVQUEvQkMsS0FBK0IsUUFBL0JBLEtBQStCO0FBQUEsVUFBeEJDLFFBQXdCLFFBQXhCQSxRQUF3QjtBQUFBLFVBQWRDLFdBQWMsUUFBZEEsV0FBYzs7QUFDOUMsVUFBSUYsS0FBSyxDQUFDcEMsSUFBTixLQUFlcUMsUUFBUSxDQUFDckMsSUFBNUIsRUFBa0M7QUFBQSxZQUN6QmtCLGdCQUR5QixHQUNMLEtBQUtDLEtBREEsQ0FDekJELGdCQUR5QjtBQUVoQ0EsUUFBQUEsZ0JBQWdCLENBQUNxQixhQUFqQjtBQUNEO0FBQ0Y7Ozt1Q0FFMkM7QUFBQSxVQUEvQkgsS0FBK0IsU0FBL0JBLEtBQStCO0FBQUEsVUFBeEJDLFFBQXdCLFNBQXhCQSxRQUF3QjtBQUFBLFVBQWRDLFdBQWMsU0FBZEEsV0FBYzs7QUFDMUMsd0ZBQWtCO0FBQUNGLFFBQUFBLEtBQUssRUFBTEEsS0FBRDtBQUFRQyxRQUFBQSxRQUFRLEVBQVJBLFFBQVI7QUFBa0JDLFFBQUFBLFdBQVcsRUFBWEE7QUFBbEIsT0FBbEI7O0FBRUEsVUFBSUYsS0FBSyxDQUFDcEMsSUFBTixLQUFlcUMsUUFBUSxDQUFDckMsSUFBNUIsRUFBa0M7QUFBQSxZQUN6QndDLEVBRHlCLEdBQ25CLEtBQUtDLE9BRGMsQ0FDekJELEVBRHlCO0FBRWhDLGFBQUtFLFFBQUwsQ0FBYztBQUFDQyxVQUFBQSxLQUFLLEVBQUUsS0FBS0MsU0FBTCxDQUFlSixFQUFmO0FBQVIsU0FBZDtBQUNEOztBQUNELFdBQUtLLGVBQUwsQ0FBcUI7QUFBQ1QsUUFBQUEsS0FBSyxFQUFMQSxLQUFEO0FBQVFDLFFBQUFBLFFBQVEsRUFBUkEsUUFBUjtBQUFrQkMsUUFBQUEsV0FBVyxFQUFYQTtBQUFsQixPQUFyQjtBQUNEOzs7Z0NBRWdCO0FBQUEsVUFBWFEsUUFBVyxTQUFYQSxRQUFXO0FBQUEsVUFDUjFDLFdBRFEsR0FDTyxLQUFLZ0MsS0FEWixDQUNSaEMsV0FEUTtBQUdmLFdBQUtlLEtBQUwsQ0FBV3dCLEtBQVgsQ0FBaUJJLE1BQWpCLENBQ0VDLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjLEVBQWQsRUFBa0JILFFBQWxCLEVBQTRCO0FBQzFCMUMsUUFBQUEsV0FBVyxFQUFYQTtBQUQwQixPQUE1QixDQURGO0FBS0Q7Ozs4QkFFU29DLEUsRUFBSTtBQUNaOzs7Ozs7O0FBT0EsVUFBSVUsU0FBUyxHQUFHLEVBQWhCOztBQUNBLFdBQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsSUFBSWxELFlBQXJCLEVBQW1Da0QsQ0FBQyxFQUFwQyxFQUF3QztBQUN0Q0QsUUFBQUEsU0FBUyxHQUFHQSxTQUFTLENBQUNFLE1BQVYsQ0FBaUIsQ0FBQ0QsQ0FBRCxFQUFJLENBQUMsQ0FBTCxFQUFRLENBQVIsRUFBV0EsQ0FBWCxFQUFjLENBQWQsRUFBaUIsQ0FBakIsQ0FBakIsQ0FBWjtBQUNEOztBQUVELFVBQU1SLEtBQUssR0FBRyxJQUFJVSxXQUFKLENBQ1piLEVBRFksRUFFWlEsTUFBTSxDQUFDQyxNQUFQLENBQWMsRUFBZCxFQUFrQixLQUFLSyxVQUFMLEVBQWxCLEVBQXFDO0FBQ25DQyxRQUFBQSxFQUFFLEVBQUUsS0FBS25CLEtBQUwsQ0FBV21CLEVBRG9CO0FBRW5DQyxRQUFBQSxRQUFRLEVBQUUsSUFBSUMsY0FBSixDQUFhO0FBQ3JCQyxVQUFBQSxRQUFRLEVBQUV6QixtQkFBRzBCLGNBRFE7QUFFckJDLFVBQUFBLFVBQVUsRUFBRTtBQUNWVixZQUFBQSxTQUFTLEVBQUUsSUFBSVcsWUFBSixDQUFpQlgsU0FBakI7QUFERDtBQUZTLFNBQWIsQ0FGeUI7QUFRbkNZLFFBQUFBLFdBQVcsRUFBRSxJQVJzQjtBQVNuQ0MsUUFBQUEsV0FBVyxFQUFFLEtBQUt0QixPQUFMLENBQWFzQjtBQVRTLE9BQXJDLENBRlksQ0FBZDtBQWNBcEIsTUFBQUEsS0FBSyxDQUFDcUIsV0FBTixDQUFrQjtBQUFDQyxRQUFBQSxXQUFXLEVBQUVoRTtBQUFkLE9BQWxCO0FBQ0EsYUFBTzBDLEtBQVA7QUFDRDs7O3FEQUVnQ3VCLFMsRUFBVztBQUFBLHdCQUNSLEtBQUs5QixLQURHO0FBQUEsVUFDbkMrQixJQURtQyxlQUNuQ0EsSUFEbUM7QUFBQSxVQUM3QjlELGlCQUQ2QixlQUM3QkEsaUJBRDZCO0FBQUEsVUFFbkMrRCxLQUZtQyxHQUVwQkYsU0FGb0IsQ0FFbkNFLEtBRm1DO0FBQUEsVUFFNUI5QyxJQUY0QixHQUVwQjRDLFNBRm9CLENBRTVCNUMsSUFGNEI7QUFHMUMsVUFBSTZCLENBQUMsR0FBRyxDQUFSO0FBQ0FnQixNQUFBQSxJQUFJLENBQUNFLE9BQUwsQ0FBYSxVQUFBQyxNQUFNLEVBQUk7QUFDckIsWUFBTS9ELGNBQWMsR0FBR0YsaUJBQWlCLENBQUNpRSxNQUFELENBQXhDO0FBQ0FGLFFBQUFBLEtBQUssQ0FBQ2pCLENBQUMsR0FBRyxDQUFMLENBQUwsR0FBZTVDLGNBQWMsQ0FBQyxDQUFELENBQTdCO0FBQ0E2RCxRQUFBQSxLQUFLLENBQUNqQixDQUFDLEdBQUcsQ0FBTCxDQUFMLEdBQWU1QyxjQUFjLENBQUMsQ0FBRCxDQUE3QjtBQUNBNkQsUUFBQUEsS0FBSyxDQUFDakIsQ0FBQyxHQUFHLENBQUwsQ0FBTCxHQUFlb0IsS0FBSyxDQUFDaEUsY0FBYyxDQUFDLENBQUQsQ0FBZixDQUFMLEdBQTJCLENBQTNCLEdBQStCQSxjQUFjLENBQUMsQ0FBRCxDQUE1RDtBQUNBNEMsUUFBQUEsQ0FBQyxJQUFJN0IsSUFBTDtBQUNELE9BTkQ7QUFPRDs7O3FEQUVnQzRDLFMsRUFBVztBQUFBLHlCQUNSLEtBQUs5QixLQURHO0FBQUEsVUFDbkMrQixJQURtQyxnQkFDbkNBLElBRG1DO0FBQUEsVUFDN0IzRCxpQkFENkIsZ0JBQzdCQSxpQkFENkI7QUFBQSxVQUVuQzRELEtBRm1DLEdBRXBCRixTQUZvQixDQUVuQ0UsS0FGbUM7QUFBQSxVQUU1QjlDLElBRjRCLEdBRXBCNEMsU0FGb0IsQ0FFNUI1QyxJQUY0QjtBQUcxQyxVQUFJNkIsQ0FBQyxHQUFHLENBQVI7QUFDQWdCLE1BQUFBLElBQUksQ0FBQ0UsT0FBTCxDQUFhLFVBQUFDLE1BQU0sRUFBSTtBQUNyQixZQUFNN0QsY0FBYyxHQUFHRCxpQkFBaUIsQ0FBQzhELE1BQUQsQ0FBeEM7QUFDQUYsUUFBQUEsS0FBSyxDQUFDakIsQ0FBQyxHQUFHLENBQUwsQ0FBTCxHQUFlMUMsY0FBYyxDQUFDLENBQUQsQ0FBN0I7QUFDQTJELFFBQUFBLEtBQUssQ0FBQ2pCLENBQUMsR0FBRyxDQUFMLENBQUwsR0FBZTFDLGNBQWMsQ0FBQyxDQUFELENBQTdCO0FBQ0EyRCxRQUFBQSxLQUFLLENBQUNqQixDQUFDLEdBQUcsQ0FBTCxDQUFMLEdBQWVvQixLQUFLLENBQUM5RCxjQUFjLENBQUMsQ0FBRCxDQUFmLENBQUwsR0FBMkIsQ0FBM0IsR0FBK0JBLGNBQWMsQ0FBQyxDQUFELENBQTVEO0FBQ0EwQyxRQUFBQSxDQUFDLElBQUk3QixJQUFMO0FBQ0QsT0FORDtBQU9EOzs7bURBRThCNEMsUyxFQUFXO0FBQUEseUJBQ1IsS0FBSzlCLEtBREc7QUFBQSxVQUNqQytCLElBRGlDLGdCQUNqQ0EsSUFEaUM7QUFBQSxVQUMzQnpELGVBRDJCLGdCQUMzQkEsZUFEMkI7QUFBQSxVQUVqQzBELEtBRmlDLEdBRWxCRixTQUZrQixDQUVqQ0UsS0FGaUM7QUFBQSxVQUUxQjlDLElBRjBCLEdBRWxCNEMsU0FGa0IsQ0FFMUI1QyxJQUYwQjtBQUd4QyxVQUFJNkIsQ0FBQyxHQUFHLENBQVI7QUFDQWdCLE1BQUFBLElBQUksQ0FBQ0UsT0FBTCxDQUFhLFVBQUFDLE1BQU0sRUFBSTtBQUNyQixZQUFNM0QsWUFBWSxHQUFHRCxlQUFlLENBQUM0RCxNQUFELENBQXBDO0FBQ0FGLFFBQUFBLEtBQUssQ0FBQ2pCLENBQUMsR0FBRyxDQUFMLENBQUwsR0FBZXhDLFlBQVksQ0FBQyxDQUFELENBQTNCO0FBQ0F5RCxRQUFBQSxLQUFLLENBQUNqQixDQUFDLEdBQUcsQ0FBTCxDQUFMLEdBQWV4QyxZQUFZLENBQUMsQ0FBRCxDQUEzQjtBQUNBeUQsUUFBQUEsS0FBSyxDQUFDakIsQ0FBQyxHQUFHLENBQUwsQ0FBTCxHQUFlb0IsS0FBSyxDQUFDNUQsWUFBWSxDQUFDLENBQUQsQ0FBYixDQUFMLEdBQXlCLENBQXpCLEdBQTZCQSxZQUFZLENBQUMsQ0FBRCxDQUF4RDtBQUNBd0MsUUFBQUEsQ0FBQyxJQUFJN0IsSUFBTDtBQUNELE9BTkQ7QUFPRDs7O2tFQUU2QzRDLFMsRUFBVztBQUFBLHlCQUNGLEtBQUs5QixLQURIO0FBQUEsVUFDaEQrQixJQURnRCxnQkFDaERBLElBRGdEO0FBQUEsVUFDMUM5RCxpQkFEMEMsZ0JBQzFDQSxpQkFEMEM7QUFBQSxVQUN2QkcsaUJBRHVCLGdCQUN2QkEsaUJBRHVCO0FBQUEsVUFFaEQ0RCxLQUZnRCxHQUVqQ0YsU0FGaUMsQ0FFaERFLEtBRmdEO0FBQUEsVUFFekM5QyxJQUZ5QyxHQUVqQzRDLFNBRmlDLENBRXpDNUMsSUFGeUM7QUFHdkQsVUFBSTZCLENBQUMsR0FBRyxDQUFSO0FBQ0FnQixNQUFBQSxJQUFJLENBQUNFLE9BQUwsQ0FBYSxVQUFBQyxNQUFNLEVBQUk7QUFDckIsWUFBTS9ELGNBQWMsR0FBR0YsaUJBQWlCLENBQUNpRSxNQUFELENBQXhDO0FBQ0EsWUFBTTdELGNBQWMsR0FBR0QsaUJBQWlCLENBQUM4RCxNQUFELENBQXhDO0FBQ0FGLFFBQUFBLEtBQUssQ0FBQ2pCLENBQUMsR0FBRyxDQUFMLENBQUwsR0FBZXBELFdBQVcsQ0FBQ1EsY0FBYyxDQUFDLENBQUQsQ0FBZixDQUExQjtBQUNBNkQsUUFBQUEsS0FBSyxDQUFDakIsQ0FBQyxHQUFHLENBQUwsQ0FBTCxHQUFlcEQsV0FBVyxDQUFDUSxjQUFjLENBQUMsQ0FBRCxDQUFmLENBQTFCO0FBQ0E2RCxRQUFBQSxLQUFLLENBQUNqQixDQUFDLEdBQUcsQ0FBTCxDQUFMLEdBQWVwRCxXQUFXLENBQUNVLGNBQWMsQ0FBQyxDQUFELENBQWYsQ0FBMUI7QUFDQTJELFFBQUFBLEtBQUssQ0FBQ2pCLENBQUMsR0FBRyxDQUFMLENBQUwsR0FBZXBELFdBQVcsQ0FBQ1UsY0FBYyxDQUFDLENBQUQsQ0FBZixDQUExQjtBQUNBMEMsUUFBQUEsQ0FBQyxJQUFJN0IsSUFBTDtBQUNELE9BUkQ7QUFTRDs7OzRDQUV1QjRDLFMsRUFBVztBQUFBLHlCQUNSLEtBQUs5QixLQURHO0FBQUEsVUFDMUIrQixJQUQwQixnQkFDMUJBLElBRDBCO0FBQUEsVUFDcEJ2RCxRQURvQixnQkFDcEJBLFFBRG9CO0FBQUEsVUFFMUJ3RCxLQUYwQixHQUVYRixTQUZXLENBRTFCRSxLQUYwQjtBQUFBLFVBRW5COUMsSUFGbUIsR0FFWDRDLFNBRlcsQ0FFbkI1QyxJQUZtQjtBQUdqQyxVQUFJNkIsQ0FBQyxHQUFHLENBQVI7QUFDQWdCLE1BQUFBLElBQUksQ0FBQ0UsT0FBTCxDQUFhLFVBQUFDLE1BQU0sRUFBSTtBQUNyQixZQUFNekQsS0FBSyxHQUFHRCxRQUFRLENBQUMwRCxNQUFELENBQXRCO0FBQ0FGLFFBQUFBLEtBQUssQ0FBQ2pCLENBQUMsR0FBRyxDQUFMLENBQUwsR0FBZXRDLEtBQUssQ0FBQyxDQUFELENBQXBCO0FBQ0F1RCxRQUFBQSxLQUFLLENBQUNqQixDQUFDLEdBQUcsQ0FBTCxDQUFMLEdBQWV0QyxLQUFLLENBQUMsQ0FBRCxDQUFwQjtBQUNBdUQsUUFBQUEsS0FBSyxDQUFDakIsQ0FBQyxHQUFHLENBQUwsQ0FBTCxHQUFldEMsS0FBSyxDQUFDLENBQUQsQ0FBcEI7QUFDQXVELFFBQUFBLEtBQUssQ0FBQ2pCLENBQUMsR0FBRyxDQUFMLENBQUwsR0FBZW9CLEtBQUssQ0FBQzFELEtBQUssQ0FBQyxDQUFELENBQU4sQ0FBTCxHQUFrQixHQUFsQixHQUF3QkEsS0FBSyxDQUFDLENBQUQsQ0FBNUM7QUFDQXNDLFFBQUFBLENBQUMsSUFBSTdCLElBQUw7QUFDRCxPQVBEO0FBUUQ7Ozs7RUFuSzJDa0QsVzs7O0FBc0s5QzFELGdCQUFnQixDQUFDMkQsU0FBakIsR0FBNkIsa0JBQTdCO0FBQ0EzRCxnQkFBZ0IsQ0FBQ1gsWUFBakIsR0FBZ0NBLFlBQWhDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7TGF5ZXJ9IGZyb20gJ0BkZWNrLmdsL2NvcmUnO1xuaW1wb3J0IEdMIGZyb20gJ2x1bWEuZ2wvY29uc3RhbnRzJztcbmltcG9ydCB7TW9kZWwsIEdlb21ldHJ5LCBmcDY0fSBmcm9tICdsdW1hLmdsJztcbmNvbnN0IHtmcDY0TG93UGFydH0gPSBmcDY0O1xuXG5pbXBvcnQgdnMgZnJvbSAnLi9iZXppZXItY3VydmUtbGF5ZXItdmVydGV4Lmdsc2wnO1xuaW1wb3J0IGZzIGZyb20gJy4vYmV6aWVyLWN1cnZlLWxheWVyLWZyYWdtZW50Lmdsc2wnO1xuXG5jb25zdCBOVU1fU0VHTUVOVFMgPSA0MDtcbmNvbnN0IERFRkFVTFRfQ09MT1IgPSBbMCwgMCwgMCwgMjU1XTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBzdHJva2VXaWR0aDogMSxcbiAgZnA2NDogZmFsc2UsXG4gIGdldFNvdXJjZVBvc2l0aW9uOiB4ID0+IHguc291cmNlUG9zaXRpb24sXG4gIGdldFRhcmdldFBvc2l0aW9uOiB4ID0+IHgudGFyZ2V0UG9zaXRpb24sXG4gIGdldENvbnRyb2xQb2ludDogeCA9PiB4LmNvbnRyb2xQb2ludCxcbiAgZ2V0Q29sb3I6IHggPT4geC5jb2xvciB8fCBERUZBVUxUX0NPTE9SXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCZXppZXJDdXJ2ZUxheWVyIGV4dGVuZHMgTGF5ZXIge1xuICBnZXRTaGFkZXJzKCkge1xuICAgIHJldHVybiB7dnMsIGZzLCBtb2R1bGVzOiBbJ3BpY2tpbmcnXX07XG4gIH1cblxuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICBpbnN0YW5jZVNvdXJjZVBvc2l0aW9uczoge1xuICAgICAgICBzaXplOiAzLFxuICAgICAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgICAgICBhY2Nlc3NvcjogJ2dldFNvdXJjZVBvc2l0aW9uJyxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlU291cmNlUG9zaXRpb25zXG4gICAgICB9LFxuICAgICAgaW5zdGFuY2VUYXJnZXRQb3NpdGlvbnM6IHtcbiAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICAgICAgYWNjZXNzb3I6ICdnZXRUYXJnZXRQb3NpdGlvbicsXG4gICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVRhcmdldFBvc2l0aW9uc1xuICAgICAgfSxcbiAgICAgIGluc3RhbmNlQ29udHJvbFBvaW50czoge1xuICAgICAgICBzaXplOiAzLFxuICAgICAgICB0cmFuc2l0aW9uOiBmYWxzZSxcbiAgICAgICAgYWNjZXNzb3I6ICdnZXRDb250cm9sUG9pbnQnLFxuICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VDb250cm9sUG9pbnRzXG4gICAgICB9LFxuICAgICAgaW5zdGFuY2VDb2xvcnM6IHtcbiAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgdHlwZTogR0wuVU5TSUdORURfQllURSxcbiAgICAgICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICAgICAgYWNjZXNzb3I6ICdnZXRDb2xvcicsXG4gICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZUNvbG9yc1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuICB9XG5cbiAgdXBkYXRlQXR0cmlidXRlKHtwcm9wcywgb2xkUHJvcHMsIGNoYW5nZUZsYWdzfSkge1xuICAgIGlmIChwcm9wcy5mcDY0ICE9PSBvbGRQcm9wcy5mcDY0KSB7XG4gICAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgICAgYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlU3RhdGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KSB7XG4gICAgc3VwZXIudXBkYXRlU3RhdGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KTtcblxuICAgIGlmIChwcm9wcy5mcDY0ICE9PSBvbGRQcm9wcy5mcDY0KSB7XG4gICAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7bW9kZWw6IHRoaXMuX2dldE1vZGVsKGdsKX0pO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUF0dHJpYnV0ZSh7cHJvcHMsIG9sZFByb3BzLCBjaGFuZ2VGbGFnc30pO1xuICB9XG5cbiAgZHJhdyh7dW5pZm9ybXN9KSB7XG4gICAgY29uc3Qge3N0cm9rZVdpZHRofSA9IHRoaXMucHJvcHM7XG5cbiAgICB0aGlzLnN0YXRlLm1vZGVsLnJlbmRlcihcbiAgICAgIE9iamVjdC5hc3NpZ24oe30sIHVuaWZvcm1zLCB7XG4gICAgICAgIHN0cm9rZVdpZHRoXG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBfZ2V0TW9kZWwoZ2wpIHtcbiAgICAvKlxuICAgICAqICAoMCwgLTEpLS0tLS0tLS0tLS0tLV8oMSwgLTEpXG4gICAgICogICAgICAgfCAgICAgICAgICBfLC1cIiAgfFxuICAgICAqICAgICAgIG8gICAgICBfLC1cIiAgICAgIG9cbiAgICAgKiAgICAgICB8ICBfLC1cIiAgICAgICAgICB8XG4gICAgICogICAoMCwgMSlcIi0tLS0tLS0tLS0tLS0oMSwgMSlcbiAgICAgKi9cbiAgICBsZXQgcG9zaXRpb25zID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gTlVNX1NFR01FTlRTOyBpKyspIHtcbiAgICAgIHBvc2l0aW9ucyA9IHBvc2l0aW9ucy5jb25jYXQoW2ksIC0xLCAwLCBpLCAxLCAwXSk7XG4gICAgfVxuXG4gICAgY29uc3QgbW9kZWwgPSBuZXcgTW9kZWwoXG4gICAgICBnbCxcbiAgICAgIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZ2V0U2hhZGVycygpLCB7XG4gICAgICAgIGlkOiB0aGlzLnByb3BzLmlkLFxuICAgICAgICBnZW9tZXRyeTogbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgICBkcmF3TW9kZTogR0wuVFJJQU5HTEVfU1RSSVAsXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgcG9zaXRpb25zOiBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9ucylcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBpc0luc3RhbmNlZDogdHJ1ZSxcbiAgICAgICAgc2hhZGVyQ2FjaGU6IHRoaXMuY29udGV4dC5zaGFkZXJDYWNoZVxuICAgICAgfSlcbiAgICApO1xuICAgIG1vZGVsLnNldFVuaWZvcm1zKHtudW1TZWdtZW50czogTlVNX1NFR01FTlRTfSk7XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VTb3VyY2VQb3NpdGlvbnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldFNvdXJjZVBvc2l0aW9ufSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3ZhbHVlLCBzaXplfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZGF0YS5mb3JFYWNoKG9iamVjdCA9PiB7XG4gICAgICBjb25zdCBzb3VyY2VQb3NpdGlvbiA9IGdldFNvdXJjZVBvc2l0aW9uKG9iamVjdCk7XG4gICAgICB2YWx1ZVtpICsgMF0gPSBzb3VyY2VQb3NpdGlvblswXTtcbiAgICAgIHZhbHVlW2kgKyAxXSA9IHNvdXJjZVBvc2l0aW9uWzFdO1xuICAgICAgdmFsdWVbaSArIDJdID0gaXNOYU4oc291cmNlUG9zaXRpb25bMl0pID8gMCA6IHNvdXJjZVBvc2l0aW9uWzJdO1xuICAgICAgaSArPSBzaXplO1xuICAgIH0pO1xuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VUYXJnZXRQb3NpdGlvbnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldFRhcmdldFBvc2l0aW9ufSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3ZhbHVlLCBzaXplfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZGF0YS5mb3JFYWNoKG9iamVjdCA9PiB7XG4gICAgICBjb25zdCB0YXJnZXRQb3NpdGlvbiA9IGdldFRhcmdldFBvc2l0aW9uKG9iamVjdCk7XG4gICAgICB2YWx1ZVtpICsgMF0gPSB0YXJnZXRQb3NpdGlvblswXTtcbiAgICAgIHZhbHVlW2kgKyAxXSA9IHRhcmdldFBvc2l0aW9uWzFdO1xuICAgICAgdmFsdWVbaSArIDJdID0gaXNOYU4odGFyZ2V0UG9zaXRpb25bMl0pID8gMCA6IHRhcmdldFBvc2l0aW9uWzJdO1xuICAgICAgaSArPSBzaXplO1xuICAgIH0pO1xuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VDb250cm9sUG9pbnRzKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhLCBnZXRDb250cm9sUG9pbnR9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmFsdWUsIHNpemV9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBkYXRhLmZvckVhY2gob2JqZWN0ID0+IHtcbiAgICAgIGNvbnN0IGNvbnRyb2xQb2ludCA9IGdldENvbnRyb2xQb2ludChvYmplY3QpO1xuICAgICAgdmFsdWVbaSArIDBdID0gY29udHJvbFBvaW50WzBdO1xuICAgICAgdmFsdWVbaSArIDFdID0gY29udHJvbFBvaW50WzFdO1xuICAgICAgdmFsdWVbaSArIDJdID0gaXNOYU4oY29udHJvbFBvaW50WzJdKSA/IDAgOiBjb250cm9sUG9pbnRbMl07XG4gICAgICBpICs9IHNpemU7XG4gICAgfSk7XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVNvdXJjZVRhcmdldFBvc2l0aW9uczY0eHlMb3coYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldFNvdXJjZVBvc2l0aW9uLCBnZXRUYXJnZXRQb3NpdGlvbn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHt2YWx1ZSwgc2l6ZX0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGRhdGEuZm9yRWFjaChvYmplY3QgPT4ge1xuICAgICAgY29uc3Qgc291cmNlUG9zaXRpb24gPSBnZXRTb3VyY2VQb3NpdGlvbihvYmplY3QpO1xuICAgICAgY29uc3QgdGFyZ2V0UG9zaXRpb24gPSBnZXRUYXJnZXRQb3NpdGlvbihvYmplY3QpO1xuICAgICAgdmFsdWVbaSArIDBdID0gZnA2NExvd1BhcnQoc291cmNlUG9zaXRpb25bMF0pO1xuICAgICAgdmFsdWVbaSArIDFdID0gZnA2NExvd1BhcnQoc291cmNlUG9zaXRpb25bMV0pO1xuICAgICAgdmFsdWVbaSArIDJdID0gZnA2NExvd1BhcnQodGFyZ2V0UG9zaXRpb25bMF0pO1xuICAgICAgdmFsdWVbaSArIDNdID0gZnA2NExvd1BhcnQodGFyZ2V0UG9zaXRpb25bMV0pO1xuICAgICAgaSArPSBzaXplO1xuICAgIH0pO1xuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VDb2xvcnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldENvbG9yfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3ZhbHVlLCBzaXplfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZGF0YS5mb3JFYWNoKG9iamVjdCA9PiB7XG4gICAgICBjb25zdCBjb2xvciA9IGdldENvbG9yKG9iamVjdCk7XG4gICAgICB2YWx1ZVtpICsgMF0gPSBjb2xvclswXTtcbiAgICAgIHZhbHVlW2kgKyAxXSA9IGNvbG9yWzFdO1xuICAgICAgdmFsdWVbaSArIDJdID0gY29sb3JbMl07XG4gICAgICB2YWx1ZVtpICsgM10gPSBpc05hTihjb2xvclszXSkgPyAyNTUgOiBjb2xvclszXTtcbiAgICAgIGkgKz0gc2l6ZTtcbiAgICB9KTtcbiAgfVxufVxuXG5CZXppZXJDdXJ2ZUxheWVyLmxheWVyTmFtZSA9ICdCZXppZXJDdXJ2ZUxheWVyJztcbkJlemllckN1cnZlTGF5ZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuIl19