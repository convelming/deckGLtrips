"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@deck.gl/core");

var _constants = _interopRequireDefault(require("luma.gl/constants"));

var _luma = require("luma.gl");

var _bitmapLayerVertex = _interopRequireDefault(require("./bitmap-layer-vertex"));

var _bitmapLayerFragment = _interopRequireDefault(require("./bitmap-layer-fragment"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// Note: needs to match vertex shader
var MAX_BITMAPS = 11;
var defaultProps = {
  images: [],
  desaturate: 0,
  blendMode: null,
  // More context: because of the blending mode we're using for ground imagery,
  // alpha is not effective when blending the bitmap layers with the base map.
  // Instead we need to manually dim/blend rgb values with a background color.
  transparentColor: [0, 0, 0, 0],
  tintColor: [255, 255, 255],
  // accessors
  getCenter: function getCenter(x) {
    return x.center;
  },
  getRotation: function getRotation(x) {
    return x.rotation;
  }
};
/*
 * @class
 * @param {object} props
 * @param {number} props.transparentColor - color to interpret transparency to
 * @param {number} props.tintColor - color bias
 */

var BitmapLayer =
/*#__PURE__*/
function (_Layer) {
  _inherits(BitmapLayer, _Layer);

  function BitmapLayer() {
    _classCallCheck(this, BitmapLayer);

    return _possibleConstructorReturn(this, _getPrototypeOf(BitmapLayer).apply(this, arguments));
  }

  _createClass(BitmapLayer, [{
    key: "initializeState",
    value: function initializeState() {
      var gl = this.context.gl;
      this.setState({
        model: this.getModel(gl)
      });
      var attributeManager = this.state.attributeManager;
      attributeManager.addInstanced({
        instanceCenter: {
          size: 3,
          update: this.calculateInstanceCenters
        },
        instanceRotation: {
          size: 3,
          update: this.calculateInstanceRotations
        },
        instanceBitmapIndex: {
          size: 1,
          update: this.calculateInstanceBitmapIndex
        }
      });
    }
  }, {
    key: "updateState",
    value: function updateState(_ref) {
      var props = _ref.props,
          oldProps = _ref.oldProps;

      if (props.images !== oldProps.images) {
        var changed = !oldProps.images || props.images.length !== oldProps.images.length;

        if (!changed) {
          for (var i = 0; i < props.images.length; ++i) {
            changed = changed || props.images[i] !== oldProps.images[i];
          }
        }

        if (changed) {
          this.loadMapImagesToTextures();
        }
      }

      var desaturate = props.desaturate;
      this.state.model.setUniforms({
        desaturate: desaturate
      });
    }
  }, {
    key: "getModel",
    value: function getModel(gl) {
      // Two triangles making up a square to render the bitmap texture on
      var verts = [[1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0]];
      var positions = [];
      var texCoords = [];
      verts.forEach(function (vertex) {
        // geometry: unit square centered on origin
        positions.push(vertex[0] / 2, vertex[1] / 2, vertex[2] / 2); // texture: unit square with bottom left in origin

        texCoords.push(vertex[0] / 2 + 0.5, -vertex[1] / 2 + 0.5);
      });
      var model = new _luma.Model(gl, {
        id: this.props.id,
        vs: _bitmapLayerVertex.default,
        fs: _bitmapLayerFragment.default,
        shaderCache: this.context.shaderCache,
        geometry: new _luma.Geometry({
          drawMode: _constants.default.TRIANGLES,
          vertexCount: 6,
          attributes: {
            positions: new Float32Array(positions),
            texCoords: new Float32Array(texCoords)
          }
        }),
        isInstanced: true
      });
      return model;
    }
  }, {
    key: "draw",
    value: function draw(_ref2) {
      var uniforms = _ref2.uniforms;
      var _this$props = this.props,
          transparentColor = _this$props.transparentColor,
          tintColor = _this$props.tintColor; // TODO fix zFighting
      // Render the image

      this.state.model.render(Object.assign({}, uniforms, {
        transparentColor: transparentColor,
        tintColor: tintColor
      }));
    }
  }, {
    key: "loadMapImagesToTextures",
    value: function loadMapImagesToTextures() {
      var _this = this;

      var model = this.state.model;
      var images = this.props.images;

      var _loop = function _loop(i) {
        (0, _luma.loadTextures)(_this.context.gl, {
          urls: [images[i]]
        }).then(function (_ref3) {
          var _ref4 = _slicedToArray(_ref3, 1),
              texture = _ref4[0];

          return model.setUniforms(_defineProperty({}, "uBitmap".concat(i), texture));
        });
      };

      for (var i = 0; i < Math.min(images.length, MAX_BITMAPS); i++) {
        _loop(i);
      }
    }
  }, {
    key: "getBitmapIndex",
    value: function getBitmapIndex(point) {
      var url = point.imageUrl;
      var idx = Math.max(this.props.images.indexOf(url), 0);
      return idx >= MAX_BITMAPS ? 0 : idx;
    }
  }, {
    key: "calculateInstanceCenters",
    value: function calculateInstanceCenters(attribute, props) {
      var _this$props2 = this.props,
          data = _this$props2.data,
          getCenter = _this$props2.getCenter;
      var value = attribute.value,
          size = attribute.size;
      var i = 0;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var point = _step.value;
          var center = getCenter(point);
          value[i + 0] = center[0] || 0;
          value[i + 1] = center[1] || 0;
          value[i + 2] = center[2] || 0;
          i += size;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "calculateInstanceRotations",
    value: function calculateInstanceRotations(attribute, props) {
      var _this$props3 = this.props,
          data = _this$props3.data,
          getRotation = _this$props3.getRotation;
      var value = attribute.value,
          size = attribute.size;
      var i = 0;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = data[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var point = _step2.value;
          var rotation = getRotation(point);
          value[i + 0] = rotation[0] || 0;
          value[i + 1] = rotation[1] || 0;
          value[i + 2] = rotation[2] || 0;
          i += size;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: "calculateInstanceBitmapIndex",
    value: function calculateInstanceBitmapIndex(attribute) {
      var data = this.props.data;
      var value = attribute.value,
          size = attribute.size;
      var i = 0;
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = data[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var point = _step3.value;
          var bitmapIndex = Number.isFinite(point.bitmapIndex) ? point.bitmapIndex : this.getBitmapIndex(point);
          value[i] = bitmapIndex;
          i += size;
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
  }]);

  return BitmapLayer;
}(_core.Layer);

exports.default = BitmapLayer;
BitmapLayer.layerName = 'BitmapLayer';
BitmapLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9iaXRtYXAtbGF5ZXIvYml0bWFwLWxheWVyLmpzIl0sIm5hbWVzIjpbIk1BWF9CSVRNQVBTIiwiZGVmYXVsdFByb3BzIiwiaW1hZ2VzIiwiZGVzYXR1cmF0ZSIsImJsZW5kTW9kZSIsInRyYW5zcGFyZW50Q29sb3IiLCJ0aW50Q29sb3IiLCJnZXRDZW50ZXIiLCJ4IiwiY2VudGVyIiwiZ2V0Um90YXRpb24iLCJyb3RhdGlvbiIsIkJpdG1hcExheWVyIiwiZ2wiLCJjb250ZXh0Iiwic2V0U3RhdGUiLCJtb2RlbCIsImdldE1vZGVsIiwiYXR0cmlidXRlTWFuYWdlciIsInN0YXRlIiwiYWRkSW5zdGFuY2VkIiwiaW5zdGFuY2VDZW50ZXIiLCJzaXplIiwidXBkYXRlIiwiY2FsY3VsYXRlSW5zdGFuY2VDZW50ZXJzIiwiaW5zdGFuY2VSb3RhdGlvbiIsImNhbGN1bGF0ZUluc3RhbmNlUm90YXRpb25zIiwiaW5zdGFuY2VCaXRtYXBJbmRleCIsImNhbGN1bGF0ZUluc3RhbmNlQml0bWFwSW5kZXgiLCJwcm9wcyIsIm9sZFByb3BzIiwiY2hhbmdlZCIsImxlbmd0aCIsImkiLCJsb2FkTWFwSW1hZ2VzVG9UZXh0dXJlcyIsInNldFVuaWZvcm1zIiwidmVydHMiLCJwb3NpdGlvbnMiLCJ0ZXhDb29yZHMiLCJmb3JFYWNoIiwidmVydGV4IiwicHVzaCIsIk1vZGVsIiwiaWQiLCJ2cyIsIkJJVE1BUF9WRVJURVhfU0hBREVSIiwiZnMiLCJCSVRNQVBfRlJBR01FTlRfU0hBREVSIiwic2hhZGVyQ2FjaGUiLCJnZW9tZXRyeSIsIkdlb21ldHJ5IiwiZHJhd01vZGUiLCJHTCIsIlRSSUFOR0xFUyIsInZlcnRleENvdW50IiwiYXR0cmlidXRlcyIsIkZsb2F0MzJBcnJheSIsImlzSW5zdGFuY2VkIiwidW5pZm9ybXMiLCJyZW5kZXIiLCJPYmplY3QiLCJhc3NpZ24iLCJ1cmxzIiwidGhlbiIsInRleHR1cmUiLCJNYXRoIiwibWluIiwicG9pbnQiLCJ1cmwiLCJpbWFnZVVybCIsImlkeCIsIm1heCIsImluZGV4T2YiLCJhdHRyaWJ1dGUiLCJkYXRhIiwidmFsdWUiLCJiaXRtYXBJbmRleCIsIk51bWJlciIsImlzRmluaXRlIiwiZ2V0Qml0bWFwSW5kZXgiLCJMYXllciIsImxheWVyTmFtZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQW9CQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTtBQUNBLElBQU1BLFdBQVcsR0FBRyxFQUFwQjtBQUVBLElBQU1DLFlBQVksR0FBRztBQUNuQkMsRUFBQUEsTUFBTSxFQUFFLEVBRFc7QUFHbkJDLEVBQUFBLFVBQVUsRUFBRSxDQUhPO0FBSW5CQyxFQUFBQSxTQUFTLEVBQUUsSUFKUTtBQUtuQjtBQUNBO0FBQ0E7QUFDQUMsRUFBQUEsZ0JBQWdCLEVBQUUsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLENBUkM7QUFTbkJDLEVBQUFBLFNBQVMsRUFBRSxDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsR0FBWCxDQVRRO0FBVW5CO0FBQ0FDLEVBQUFBLFNBQVMsRUFBRSxtQkFBQUMsQ0FBQztBQUFBLFdBQUlBLENBQUMsQ0FBQ0MsTUFBTjtBQUFBLEdBWE87QUFZbkJDLEVBQUFBLFdBQVcsRUFBRSxxQkFBQUYsQ0FBQztBQUFBLFdBQUlBLENBQUMsQ0FBQ0csUUFBTjtBQUFBO0FBWkssQ0FBckI7QUFlQTs7Ozs7OztJQU1xQkMsVzs7Ozs7Ozs7Ozs7OztzQ0FDRDtBQUFBLFVBQ1RDLEVBRFMsR0FDSCxLQUFLQyxPQURGLENBQ1RELEVBRFM7QUFFaEIsV0FBS0UsUUFBTCxDQUFjO0FBQUNDLFFBQUFBLEtBQUssRUFBRSxLQUFLQyxRQUFMLENBQWNKLEVBQWQ7QUFBUixPQUFkO0FBRmdCLFVBSVRLLGdCQUpTLEdBSVcsS0FBS0MsS0FKaEIsQ0FJVEQsZ0JBSlM7QUFLaEJBLE1BQUFBLGdCQUFnQixDQUFDRSxZQUFqQixDQUE4QjtBQUM1QkMsUUFB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LEtBQUssQ0FBQzFDLENBQUMsR0FBRyxDQUFMLENBQUwsR0FBZXRCLFFBQVEsQ0FBQyxDQUFELENBQVIsSUFBZSxDQUE5QjtBQUVBc0IsVUFBQUEsQ0FBQyxJQUFJWCxJQUFMO0FBQ0Q7QUFaMEM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWE1Qzs7O2lEQUU0Qm1ELFMsRUFBVztBQUFBLFVBQy9CQyxJQUQrQixHQUN2QixLQUFLN0MsS0FEa0IsQ0FDL0I2QyxJQUQrQjtBQUFBLFVBRS9CQyxLQUYrQixHQUVoQkYsU0FGZ0IsQ0FFL0JFLEtBRitCO0FBQUEsVUFFeEJyRCxJQUZ3QixHQUVoQm1ELFNBRmdCLENBRXhCbkQsSUFGd0I7QUFHdEMsVUFBSVcsQ0FBQyxHQUFHLENBQVI7QUFIc0M7QUFBQTtBQUFBOztBQUFBO0FBSXRDLDhCQUFvQnlDLElBQXBCLG1JQUEwQjtBQUFBLGNBQWZQLEtBQWU7QUFDeEIsY0FBTVMsV0FBVyxHQUFHQyxNQUFNLENBQUNDLFFBQVAsQ0FBZ0JYLEtBQUssQ0FBQ1MsV0FBdEIsSUFDaEJULEtBQUssQ0FBQ1MsV0FEVSxHQUVoQixLQUFLRyxjQUFMLENBQW9CWixLQUFwQixDQUZKO0FBR0FRLFVBQUFBLEtBQUssQ0FBQzFDLENBQUQsQ0FBTCxHQUFXMkMsV0FBWDtBQUNBM0MsVUFBQUEsQ0FBQyxJQUFJWCxJQUFMO0FBQ0Q7QUFWcUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVd2Qzs7OztFQXJJc0MwRCxXOzs7QUF3SXpDcEUsV0FBVyxDQUFDcUUsU0FBWixHQUF3QixhQUF4QjtBQUNBckUsV0FBVyxDQUFDWCxZQUFaLEdBQTJCQSxZQUEzQiIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7TGF5ZXJ9IGZyb20gJ0BkZWNrLmdsL2NvcmUnO1xuaW1wb3J0IEdMIGZyb20gJ2x1bWEuZ2wvY29uc3RhbnRzJztcbmltcG9ydCB7TW9kZWwsIEdlb21ldHJ5LCBsb2FkVGV4dHVyZXN9IGZyb20gJ2x1bWEuZ2wnO1xuXG5pbXBvcnQgQklUTUFQX1ZFUlRFWF9TSEFERVIgZnJvbSAnLi9iaXRtYXAtbGF5ZXItdmVydGV4JztcbmltcG9ydCBCSVRNQVBfRlJBR01FTlRfU0hBREVSIGZyb20gJy4vYml0bWFwLWxheWVyLWZyYWdtZW50JztcblxuLy8gTm90ZTogbmVlZHMgdG8gbWF0Y2ggdmVydGV4IHNoYWRlclxuY29uc3QgTUFYX0JJVE1BUFMgPSAxMTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBpbWFnZXM6IFtdLFxuXG4gIGRlc2F0dXJhdGU6IDAsXG4gIGJsZW5kTW9kZTogbnVsbCxcbiAgLy8gTW9yZSBjb250ZXh0OiBiZWNhdXNlIG9mIHRoZSBibGVuZGluZyBtb2RlIHdlJ3JlIHVzaW5nIGZvciBncm91bmQgaW1hZ2VyeSxcbiAgLy8gYWxwaGEgaXMgbm90IGVmZmVjdGl2ZSB3aGVuIGJsZW5kaW5nIHRoZSBiaXRtYXAgbGF5ZXJzIHdpdGggdGhlIGJhc2UgbWFwLlxuICAvLyBJbnN0ZWFkIHdlIG5lZWQgdG8gbWFudWFsbHkgZGltL2JsZW5kIHJnYiB2YWx1ZXMgd2l0aCBhIGJhY2tncm91bmQgY29sb3IuXG4gIHRyYW5zcGFyZW50Q29sb3I6IFswLCAwLCAwLCAwXSxcbiAgdGludENvbG9yOiBbMjU1LCAyNTUsIDI1NV0sXG4gIC8vIGFjY2Vzc29yc1xuICBnZXRDZW50ZXI6IHggPT4geC5jZW50ZXIsXG4gIGdldFJvdGF0aW9uOiB4ID0+IHgucm90YXRpb25cbn07XG5cbi8qXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtudW1iZXJ9IHByb3BzLnRyYW5zcGFyZW50Q29sb3IgLSBjb2xvciB0byBpbnRlcnByZXQgdHJhbnNwYXJlbmN5IHRvXG4gKiBAcGFyYW0ge251bWJlcn0gcHJvcHMudGludENvbG9yIC0gY29sb3IgYmlhc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCaXRtYXBMYXllciBleHRlbmRzIExheWVyIHtcbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIGNvbnN0IHtnbH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgdGhpcy5zZXRTdGF0ZSh7bW9kZWw6IHRoaXMuZ2V0TW9kZWwoZ2wpfSk7XG5cbiAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkSW5zdGFuY2VkKHtcbiAgICAgIGluc3RhbmNlQ2VudGVyOiB7c2l6ZTogMywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlQ2VudGVyc30sXG4gICAgICBpbnN0YW5jZVJvdGF0aW9uOiB7c2l6ZTogMywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlUm90YXRpb25zfSxcbiAgICAgIGluc3RhbmNlQml0bWFwSW5kZXg6IHtzaXplOiAxLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VCaXRtYXBJbmRleH1cbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZVN0YXRlKHtwcm9wcywgb2xkUHJvcHN9KSB7XG4gICAgaWYgKHByb3BzLmltYWdlcyAhPT0gb2xkUHJvcHMuaW1hZ2VzKSB7XG4gICAgICBsZXQgY2hhbmdlZCA9ICFvbGRQcm9wcy5pbWFnZXMgfHwgcHJvcHMuaW1hZ2VzLmxlbmd0aCAhPT0gb2xkUHJvcHMuaW1hZ2VzLmxlbmd0aDtcbiAgICAgIGlmICghY2hhbmdlZCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzLmltYWdlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IHByb3BzLmltYWdlc1tpXSAhPT0gb2xkUHJvcHMuaW1hZ2VzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICB0aGlzLmxvYWRNYXBJbWFnZXNUb1RleHR1cmVzKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHtkZXNhdHVyYXRlfSA9IHByb3BzO1xuICAgIHRoaXMuc3RhdGUubW9kZWwuc2V0VW5pZm9ybXMoe2Rlc2F0dXJhdGV9KTtcbiAgfVxuXG4gIGdldE1vZGVsKGdsKSB7XG4gICAgLy8gVHdvIHRyaWFuZ2xlcyBtYWtpbmcgdXAgYSBzcXVhcmUgdG8gcmVuZGVyIHRoZSBiaXRtYXAgdGV4dHVyZSBvblxuICAgIGNvbnN0IHZlcnRzID0gW1sxLCAxLCAwXSwgWy0xLCAxLCAwXSwgWzEsIC0xLCAwXSwgWy0xLCAxLCAwXSwgWzEsIC0xLCAwXSwgWy0xLCAtMSwgMF1dO1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuICAgIGNvbnN0IHRleENvb3JkcyA9IFtdO1xuICAgIHZlcnRzLmZvckVhY2godmVydGV4ID0+IHtcbiAgICAgIC8vIGdlb21ldHJ5OiB1bml0IHNxdWFyZSBjZW50ZXJlZCBvbiBvcmlnaW5cbiAgICAgIHBvc2l0aW9ucy5wdXNoKHZlcnRleFswXSAvIDIsIHZlcnRleFsxXSAvIDIsIHZlcnRleFsyXSAvIDIpO1xuICAgICAgLy8gdGV4dHVyZTogdW5pdCBzcXVhcmUgd2l0aCBib3R0b20gbGVmdCBpbiBvcmlnaW5cbiAgICAgIHRleENvb3Jkcy5wdXNoKHZlcnRleFswXSAvIDIgKyAwLjUsIC12ZXJ0ZXhbMV0gLyAyICsgMC41KTtcbiAgICB9KTtcblxuICAgIGNvbnN0IG1vZGVsID0gbmV3IE1vZGVsKGdsLCB7XG4gICAgICBpZDogdGhpcy5wcm9wcy5pZCxcbiAgICAgIHZzOiBCSVRNQVBfVkVSVEVYX1NIQURFUixcbiAgICAgIGZzOiBCSVRNQVBfRlJBR01FTlRfU0hBREVSLFxuICAgICAgc2hhZGVyQ2FjaGU6IHRoaXMuY29udGV4dC5zaGFkZXJDYWNoZSxcbiAgICAgIGdlb21ldHJ5OiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICBkcmF3TW9kZTogR0wuVFJJQU5HTEVTLFxuICAgICAgICB2ZXJ0ZXhDb3VudDogNixcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgIHBvc2l0aW9uczogbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbnMpLFxuICAgICAgICAgIHRleENvb3JkczogbmV3IEZsb2F0MzJBcnJheSh0ZXhDb29yZHMpXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgaXNJbnN0YW5jZWQ6IHRydWVcbiAgICB9KTtcblxuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuXG4gIGRyYXcoe3VuaWZvcm1zfSkge1xuICAgIGNvbnN0IHt0cmFuc3BhcmVudENvbG9yLCB0aW50Q29sb3J9ID0gdGhpcy5wcm9wcztcblxuICAgIC8vIFRPRE8gZml4IHpGaWdodGluZ1xuXG4gICAgLy8gUmVuZGVyIHRoZSBpbWFnZVxuICAgIHRoaXMuc3RhdGUubW9kZWwucmVuZGVyKFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwgdW5pZm9ybXMsIHtcbiAgICAgICAgdHJhbnNwYXJlbnRDb2xvcixcbiAgICAgICAgdGludENvbG9yXG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBsb2FkTWFwSW1hZ2VzVG9UZXh0dXJlcygpIHtcbiAgICBjb25zdCB7bW9kZWx9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7aW1hZ2VzfSA9IHRoaXMucHJvcHM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1pbihpbWFnZXMubGVuZ3RoLCBNQVhfQklUTUFQUyk7IGkrKykge1xuICAgICAgbG9hZFRleHR1cmVzKHRoaXMuY29udGV4dC5nbCwge1xuICAgICAgICB1cmxzOiBbaW1hZ2VzW2ldXVxuICAgICAgfSkudGhlbigoW3RleHR1cmVdKSA9PiB7XG4gICAgICAgIHJldHVybiBtb2RlbC5zZXRVbmlmb3Jtcyh7W2B1Qml0bWFwJHtpfWBdOiB0ZXh0dXJlfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBnZXRCaXRtYXBJbmRleChwb2ludCkge1xuICAgIGNvbnN0IHVybCA9IHBvaW50LmltYWdlVXJsO1xuICAgIGNvbnN0IGlkeCA9IE1hdGgubWF4KHRoaXMucHJvcHMuaW1hZ2VzLmluZGV4T2YodXJsKSwgMCk7XG4gICAgcmV0dXJuIGlkeCA+PSBNQVhfQklUTUFQUyA/IDAgOiBpZHg7XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZUNlbnRlcnMoYXR0cmlidXRlLCBwcm9wcykge1xuICAgIGNvbnN0IHtkYXRhLCBnZXRDZW50ZXJ9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmFsdWUsIHNpemV9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IHBvaW50IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IGNlbnRlciA9IGdldENlbnRlcihwb2ludCk7XG5cbiAgICAgIHZhbHVlW2kgKyAwXSA9IGNlbnRlclswXSB8fCAwO1xuICAgICAgdmFsdWVbaSArIDFdID0gY2VudGVyWzFdIHx8IDA7XG4gICAgICB2YWx1ZVtpICsgMl0gPSBjZW50ZXJbMl0gfHwgMDtcblxuICAgICAgaSArPSBzaXplO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlUm90YXRpb25zKGF0dHJpYnV0ZSwgcHJvcHMpIHtcbiAgICBjb25zdCB7ZGF0YSwgZ2V0Um90YXRpb259ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmFsdWUsIHNpemV9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IHBvaW50IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IHJvdGF0aW9uID0gZ2V0Um90YXRpb24ocG9pbnQpO1xuXG4gICAgICB2YWx1ZVtpICsgMF0gPSByb3RhdGlvblswXSB8fCAwO1xuICAgICAgdmFsdWVbaSArIDFdID0gcm90YXRpb25bMV0gfHwgMDtcbiAgICAgIHZhbHVlW2kgKyAyXSA9IHJvdGF0aW9uWzJdIHx8IDA7XG5cbiAgICAgIGkgKz0gc2l6ZTtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZUJpdG1hcEluZGV4KGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3ZhbHVlLCBzaXplfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBwb2ludCBvZiBkYXRhKSB7XG4gICAgICBjb25zdCBiaXRtYXBJbmRleCA9IE51bWJlci5pc0Zpbml0ZShwb2ludC5iaXRtYXBJbmRleClcbiAgICAgICAgPyBwb2ludC5iaXRtYXBJbmRleFxuICAgICAgICA6IHRoaXMuZ2V0Qml0bWFwSW5kZXgocG9pbnQpO1xuICAgICAgdmFsdWVbaV0gPSBiaXRtYXBJbmRleDtcbiAgICAgIGkgKz0gc2l6ZTtcbiAgICB9XG4gIH1cbn1cblxuQml0bWFwTGF5ZXIubGF5ZXJOYW1lID0gJ0JpdG1hcExheWVyJztcbkJpdG1hcExheWVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbiJdfQ==