{"version":3,"sources":["../../../src/geojson-layer/geojson.js"],"names":["assert","condition","message","Error","getGeojsonFeatures","geojson","Array","isArray","type","features","geometry","separateGeojsonFeatures","separated","pointFeatures","lineFeatures","polygonFeatures","polygonOutlineFeatures","featureIndex","length","feature","sourceFeature","index","geometries","i","subGeometry","separateGeometry","coordinates","checkCoordinates","push","forEach","point","path","polygon","unwrapSourceFeature","wrappedFeature","unwrapSourceFeatureIndex","COORDINATE_NEST_LEVEL","Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon","nestLevel","Number","isFinite"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Replacement for the external assert method to reduce bundle size\n// Since GeoJSON format issues are common to users we do show messages in\n// this case\nexport default function assert(condition, message) {\n  if (!condition) {\n    throw new Error(`deck.gl: ${message}`);\n  }\n}\n\n/**\n * \"Normalizes\" complete or partial GeoJSON data into iterable list of features\n * Can accept GeoJSON geometry or \"Feature\", \"FeatureCollection\" in addition\n * to plain arrays and iterables.\n * Works by extracting the feature array or wrapping single objects in an array,\n * so that subsequent code can simply iterate over features.\n *\n * @param {object} geojson - geojson data\n * @param {Object|Array} data - geojson object (FeatureCollection, Feature or\n *  Geometry) or array of features\n * @return {Array|\"iteratable\"} - iterable list of features\n */\nexport function getGeojsonFeatures(geojson) {\n  // If array, assume this is a list of features\n  if (Array.isArray(geojson)) {\n    return geojson;\n  }\n\n  assert(geojson.type, 'GeoJSON does not have type');\n\n  switch (geojson.type) {\n    case 'Feature':\n      // Wrap the feature in a 'Features' array\n      return [geojson];\n    case 'FeatureCollection':\n      // Just return the 'Features' array from the collection\n      assert(Array.isArray(geojson.features), 'GeoJSON does not have features array');\n      return geojson.features;\n    default:\n      // Assume it's a geometry, we'll check type in separateGeojsonFeatures\n      // Wrap the geometry object in a 'Feature' object and wrap in an array\n      return [{geometry: geojson}];\n  }\n}\n\n// Linearize\nexport function separateGeojsonFeatures(features) {\n  const separated = {\n    pointFeatures: [],\n    lineFeatures: [],\n    polygonFeatures: [],\n    polygonOutlineFeatures: []\n  };\n\n  for (let featureIndex = 0; featureIndex < features.length; featureIndex++) {\n    const feature = features[featureIndex];\n\n    assert(feature && feature.geometry, 'GeoJSON does not have geometry');\n\n    const {geometry} = feature;\n\n    const sourceFeature = {\n      feature,\n      index: featureIndex\n    };\n\n    if (geometry.type === 'GeometryCollection') {\n      assert(Array.isArray(geometry.geometries), 'GeoJSON does not have geometries array');\n      const {geometries} = geometry;\n      for (let i = 0; i < geometries.length; i++) {\n        const subGeometry = geometries[i];\n        separateGeometry(subGeometry, separated, sourceFeature);\n      }\n    } else {\n      separateGeometry(geometry, separated, sourceFeature);\n    }\n  }\n\n  return separated;\n}\n\nfunction separateGeometry(geometry, separated, sourceFeature) {\n  const {type, coordinates} = geometry;\n  const {pointFeatures, lineFeatures, polygonFeatures, polygonOutlineFeatures} = separated;\n\n  checkCoordinates(type, coordinates);\n\n  // Split each feature, but keep track of the source feature and index (for Multi* geometries)\n  switch (type) {\n    case 'Point':\n      pointFeatures.push({\n        geometry,\n        sourceFeature\n      });\n      break;\n    case 'MultiPoint':\n      coordinates.forEach(point => {\n        pointFeatures.push({\n          geometry: {type: 'Point', coordinates: point},\n          sourceFeature\n        });\n      });\n      break;\n    case 'LineString':\n      lineFeatures.push({\n        geometry,\n        sourceFeature\n      });\n      break;\n    case 'MultiLineString':\n      // Break multilinestrings into multiple lines\n      coordinates.forEach(path => {\n        lineFeatures.push({\n          geometry: {type: 'LineString', coordinates: path},\n          sourceFeature\n        });\n      });\n      break;\n    case 'Polygon':\n      polygonFeatures.push({\n        geometry,\n        sourceFeature\n      });\n      // Break polygon into multiple lines\n      coordinates.forEach(path => {\n        polygonOutlineFeatures.push({\n          geometry: {type: 'LineString', coordinates: path},\n          sourceFeature\n        });\n      });\n      break;\n    case 'MultiPolygon':\n      // Break multipolygons into multiple polygons\n      coordinates.forEach(polygon => {\n        polygonFeatures.push({\n          geometry: {type: 'Polygon', coordinates: polygon},\n          sourceFeature\n        });\n        // Break polygon into multiple lines\n        polygon.forEach(path => {\n          polygonOutlineFeatures.push({\n            geometry: {type: 'LineString', coordinates: path},\n            sourceFeature\n          });\n        });\n      });\n      break;\n    default:\n  }\n}\n\n/**\n * Returns the source feature that was passed to `separateGeojsonFeatures`\n */\nexport function unwrapSourceFeature(wrappedFeature) {\n  // The feature provided by the user is under `sourceFeature.feature`\n  return wrappedFeature.sourceFeature.feature;\n}\n\n/**\n * Returns the index of the source feature that was passed to `separateGeojsonFeatures`\n */\nexport function unwrapSourceFeatureIndex(wrappedFeature) {\n  // The index of the feature provided by the user is under `sourceFeature.index`\n  return wrappedFeature.sourceFeature.index;\n}\n\n/**\n * Simple GeoJSON validation util. For perf reasons we do not validate against the full spec,\n * only the following:\n   - geometry.type is supported\n   - geometry.coordinate has correct nesting level\n */\nconst COORDINATE_NEST_LEVEL = {\n  Point: 1,\n  MultiPoint: 2,\n  LineString: 2,\n  MultiLineString: 3,\n  Polygon: 3,\n  MultiPolygon: 4\n};\n\nfunction checkCoordinates(type, coordinates) {\n  let nestLevel = COORDINATE_NEST_LEVEL[type];\n\n  assert(nestLevel, `Unknown GeoJSON type ${type}`);\n\n  while (coordinates && --nestLevel > 0) {\n    coordinates = coordinates[0];\n  }\n  assert(coordinates && Number.isFinite(coordinates[0]), `${type} coordinates are malformed`);\n}\n"],"file":"geojson.js"}