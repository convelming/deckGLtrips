import assert from"./assert";import{LinearInterpolator}from"./transition";import MapState from"./map-state";const noop=()=>{};export const TRANSITION_EVENTS={BREAK:1,SNAP_TO_END:2,IGNORE:3};const DEFAULT_PROPS={transitionDuration:0,transitionEasing:t=>t,transitionInterpolator:new LinearInterpolator,transitionInterruption:TRANSITION_EVENTS.BREAK,onTransitionStart:noop,onTransitionInterrupt:noop,onTransitionEnd:noop},DEFAULT_STATE={animation:null,propsInTransition:null,startProps:null,endProps:null};export default class TransitionManager{constructor(props){this.props=props,this.state=DEFAULT_STATE,this._onTransitionFrame=this._onTransitionFrame.bind(this)}getViewportInTransition(){return this.state.propsInTransition}processViewportChange(nextProps){let transitionTriggered=!1;const currentProps=this.props;if(this.props=nextProps,this._shouldIgnoreViewportChange(currentProps,nextProps))return transitionTriggered;const isTransitionInProgress=this._isTransitionInProgress();if(this._isTransitionEnabled(nextProps)){const startProps=Object.assign({},currentProps,this.state.interruption===TRANSITION_EVENTS.SNAP_TO_END?this.state.endProps:this.state.propsInTransition);isTransitionInProgress&&currentProps.onTransitionInterrupt(),nextProps.onTransitionStart(),this._triggerTransition(startProps,nextProps),transitionTriggered=!0}else isTransitionInProgress&&(currentProps.onTransitionInterrupt(),this._endTransition());return transitionTriggered}_isTransitionInProgress(){return!!this.state.propsInTransition}_isTransitionEnabled(props){return 0<props.transitionDuration&&!!props.transitionInterpolator}_isUpdateDueToCurrentTransition(props){return!!this.state.propsInTransition&&this.state.interpolator.arePropsEqual(props,this.state.propsInTransition)}_shouldIgnoreViewportChange(currentProps,nextProps){if(this._isTransitionInProgress())return this.state.interruption===TRANSITION_EVENTS.IGNORE||this._isUpdateDueToCurrentTransition(nextProps);return!this._isTransitionEnabled(nextProps)||nextProps.transitionInterpolator.arePropsEqual(currentProps,nextProps)}_triggerTransition(startProps,endProps){assert(this._isTransitionEnabled(endProps),"Transition is not enabled"),cancelAnimationFrame(this.state.animation);const initialProps=endProps.transitionInterpolator.initializeProps(startProps,endProps);this.state={duration:endProps.transitionDuration,easing:endProps.transitionEasing,interpolator:endProps.transitionInterpolator,interruption:endProps.transitionInterruption,startTime:Date.now(),startProps:initialProps.start,endProps:initialProps.end,animation:null,propsInTransition:{}},this._onTransitionFrame()}_onTransitionFrame(){this.state.animation=requestAnimationFrame(this._onTransitionFrame),this._updateViewport()}_endTransition(){cancelAnimationFrame(this.state.animation),this.state=DEFAULT_STATE}_updateViewport(){const currentTime=Date.now(),_this$state=this.state,startTime=_this$state.startTime,duration=_this$state.duration,easing=_this$state.easing,interpolator=_this$state.interpolator,startProps=_this$state.startProps,endProps=_this$state.endProps;let shouldEnd=!1,t=(currentTime-startTime)/duration;1<=t&&(t=1,shouldEnd=!0),t=easing(t);const viewport=interpolator.interpolateProps(startProps,endProps,t),mapState=new MapState(Object.assign({},this.props,viewport));this.state.propsInTransition=mapState.getViewportProps();const onViewportChange=this.props.onViewportChange||this.props.onChangeViewport;onViewportChange&&onViewportChange(this.state.propsInTransition),this.props.onViewStateChange&&this.props.onViewStateChange({viewState:this.state.propsInTransition}),shouldEnd&&(this._endTransition(),this.props.onTransitionEnd())}}TransitionManager.defaultProps=DEFAULT_PROPS;
//# sourceMappingURL=transition-manager.js.map