{"version":3,"sources":["../../../src/utils/dynamic-position.js"],"names":["ANCHOR_POSITION","top","x","y","bottom","left","right","getDynamicPosition","width","height","selfWidth","selfHeight","anchor","padding","anchorX","anchorY","yStep","xStep","Math","floor","Object","keys","find","positionType","anchorPosition"],"mappings":"AACA,MAAO,MAAMA,CAAAA,eAAe,CAAG,CAC7BC,GAAG,CAAE,CAACC,CAAC,CAAE,EAAJ,CAASC,CAAC,CAAE,CAAZ,CADwB,CAE7B,WAAY,CAACD,CAAC,CAAE,CAAJ,CAAOC,CAAC,CAAE,CAAV,CAFiB,CAG7B,YAAa,CAACD,CAAC,CAAE,CAAJ,CAAOC,CAAC,CAAE,CAAV,CAHgB,CAI7BC,MAAM,CAAE,CAACF,CAAC,CAAE,EAAJ,CAASC,CAAC,CAAE,CAAZ,CAJqB,CAK7B,cAAe,CAACD,CAAC,CAAE,CAAJ,CAAOC,CAAC,CAAE,CAAV,CALc,CAM7B,eAAgB,CAACD,CAAC,CAAE,CAAJ,CAAOC,CAAC,CAAE,CAAV,CANa,CAO7BE,IAAI,CAAE,CAACH,CAAC,CAAE,CAAJ,CAAOC,CAAC,CAAE,EAAV,CAPuB,CAQ7BG,KAAK,CAAE,CAACJ,CAAC,CAAE,CAAJ,CAAOC,CAAC,CAAE,EAAV,CARsB,CAAxB,CAyBP,MAAO,SAASI,CAAAA,kBAAT,CAA4B,CACjCL,CADiC,CAC9BC,CAD8B,CAEjCK,KAFiC,CAE1BC,MAF0B,CAGjCC,SAHiC,CAGtBC,UAHsB,CAIjCC,MAJiC,CAKjCC,OAAO,CAAG,CALuB,CAA5B,CAMJ,2BAC8Bb,eAAe,CAACY,MAAD,CAD7C,CACOE,OADP,uBACIZ,CADJ,CACmBa,OADnB,uBACgBZ,CADhB,CAIGF,GAAG,CAAGE,CAAC,CAAGY,OAAO,CAAGJ,UAJvB,CAKGP,MAAM,CAAGH,GAAG,CAAGU,UALlB,CAOD,KAAMK,CAAAA,KAAK,CAAG,EAAd,CAEA,GAAIf,GAAG,CAAGY,OAAV,MAESZ,GAAG,CAAGY,OAAN,EAAiBE,OAAO,EAAIC,KAFrC,EAGID,OAAO,EAAIC,KAHf,CAIIf,GAAG,EAAIe,KAAK,CAAGL,UAJnB,KAMO,IAAIP,MAAM,CAAGK,MAAM,CAAGI,OAAtB,MAEET,MAAM,CAAGK,MAAM,CAAGI,OAAlB,EAA6BE,OAAO,EAAI,EAAIC,KAF9C,EAGHD,OAAO,EAAIC,KAHR,CAIHZ,MAAM,EAAIY,KAAK,CAAGL,UAJf,CAfN,GAwBGN,CAAAA,IAAI,CAAGH,CAAC,CAAGY,OAAO,CAAGJ,SAxBxB,CAyBGJ,KAAK,CAAGD,IAAI,CAAGK,SAzBlB,CA4BGO,KAAK,CAAG,EA5BX,CAmCD,GANgB,EAAZ,GAAAF,OAMJ,GAJED,OAAO,CAAGI,IAAI,CAACC,KAAL,CAAWL,OAAX,CAIZ,CAHEG,KAAK,CAAG,CAGV,EAAIZ,IAAI,CAAGQ,OAAX,MAESR,IAAI,CAAGQ,OAAP,EAAkBC,OAAO,EAAIG,KAFtC,EAGIH,OAAO,EAAIG,KAHf,CAIIZ,IAAI,EAAIY,KAAK,CAAGP,SAJpB,KAMO,IAAIJ,KAAK,CAAGE,KAAK,CAAGK,OAApB,MAEEP,KAAK,CAAGE,KAAK,CAAGK,OAAhB,EAA2BC,OAAO,EAAI,EAAIG,KAF5C,EAGHH,OAAO,EAAIG,KAHR,CAIHX,KAAK,EAAIW,KAAK,CAAGP,SAJd,CASP,MAAOU,CAAAA,MAAM,CAACC,IAAP,CAAYrB,eAAZ,EAA6BsB,IAA7B,CAAmCC,YAAD,EAAkB,CACzD,KAAMC,CAAAA,cAAc,CAAGxB,eAAe,CAACuB,YAAD,CAAtC,CACA,MAAOC,CAAAA,cAAc,CAACtB,CAAf,GAAqBY,OAArB,EAAgCU,cAAc,CAACrB,CAAf,GAAqBY,OAC7D,CAHM,CAIR","sourcesContent":["\nexport const ANCHOR_POSITION = {\n  top: {x: 0.5, y: 0},\n  'top-left': {x: 0, y: 0},\n  'top-right': {x: 1, y: 0},\n  bottom: {x: 0.5, y: 1},\n  'bottom-left': {x: 0, y: 1},\n  'bottom-right': {x: 1, y: 1},\n  left: {x: 0, y: 0.5},\n  right: {x: 1, y: 0.5}\n};\n\n/**\n * Calculate the dynamic position for a popup to fit in a container.\n * @param {Number} x - x position of the anchor on screen\n * @param {Number} y - y position of the anchor on screen\n * @param {Number} width - width of the container\n * @param {Number} height - height of the container\n * @param {Number} padding - extra space from the edge in pixels\n * @param {Number} selfWidth - width of the popup\n * @param {Number} selfHeight - height of the popup\n * @param {String} anchor - type of the anchor, one of 'top', 'bottom',\n    'left', 'right', 'top-left', 'top-right', 'bottom-left' , and  'bottom-right'\n * @returns {String} position - one of 'top', 'bottom',\n    'left', 'right', 'top-left', 'top-right', 'bottom-left' , and  'bottom-right'\n */\nexport function getDynamicPosition({\n  x, y,\n  width, height,\n  selfWidth, selfHeight,\n  anchor,\n  padding = 0\n}) {\n  let {x: anchorX, y: anchorY} = ANCHOR_POSITION[anchor];\n\n  // anchorY: top - 0, center - 0.5, bottom - 1\n  let top = y - anchorY * selfHeight;\n  let bottom = top + selfHeight;\n  // If needed, adjust anchorY at 0.5 step between [0, 1]\n  const yStep = 0.5;\n\n  if (top < padding) {\n    // Top edge is outside, try move down\n    while (top < padding && anchorY >= yStep) {\n      anchorY -= yStep;\n      top += yStep * selfHeight;\n    }\n  } else if (bottom > height - padding) {\n    // bottom edge is outside, try move up\n    while (bottom > height - padding && anchorY <= 1 - yStep) {\n      anchorY += yStep;\n      bottom -= yStep * selfHeight;\n    }\n  }\n\n  // anchorX: left - 0, center - 0.5, right - 1\n  let left = x - anchorX * selfWidth;\n  let right = left + selfWidth;\n\n  // If needed, adjust anchorX at 0.5 step between [0, 1]\n  let xStep = 0.5;\n  if (anchorY === 0.5) {\n    // If y is centered, then x cannot also be centered\n    anchorX = Math.floor(anchorX);\n    xStep = 1;\n  }\n\n  if (left < padding) {\n    // Left edge is outside, try move right\n    while (left < padding && anchorX >= xStep) {\n      anchorX -= xStep;\n      left += xStep * selfWidth;\n    }\n  } else if (right > width - padding) {\n    // Right edge is outside, try move left\n    while (right > width - padding && anchorX <= 1 - xStep) {\n      anchorX += xStep;\n      right -= xStep * selfWidth;\n    }\n  }\n\n  // Find the name of the new anchor position\n  return Object.keys(ANCHOR_POSITION).find((positionType) => {\n    const anchorPosition = ANCHOR_POSITION[positionType];\n    return anchorPosition.x === anchorX && anchorPosition.y === anchorY;\n  });\n}\n"],"file":"dynamic-position.js"}