"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = require("react");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _staticMap = _interopRequireDefault(require("./static-map"));

var _mapState = require("../utils/map-state");

var _viewportMercatorProject = _interopRequireDefault(require("viewport-mercator-project"));

var _transitionManager = _interopRequireDefault(require("../utils/transition-manager"));

var _styleUtils = require("../utils/style-utils");

var _mjolnir = require("mjolnir.js");

var _mapControls = _interopRequireDefault(require("../utils/map-controls"));

var _config = _interopRequireDefault(require("../config"));

var _deprecateWarn = _interopRequireDefault(require("../utils/deprecate-warn"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

var propTypes = Object.assign({}, _staticMap.default.propTypes, {
  // Additional props on top of StaticMap

  /** Viewport constraints */
  // Max zoom level
  maxZoom: _propTypes.default.number,
  // Min zoom level
  minZoom: _propTypes.default.number,
  // Max pitch in degrees
  maxPitch: _propTypes.default.number,
  // Min pitch in degrees
  minPitch: _propTypes.default.number,
  // Callbacks fired when the user interacted with the map. The object passed to the callbacks
  // contains viewport properties such as `longitude`, `latitude`, `zoom` etc.
  onViewStateChange: _propTypes.default.func,
  onViewportChange: _propTypes.default.func,

  /** Viewport transition **/
  // transition duration for viewport change
  transitionDuration: _propTypes.default.number,
  // TransitionInterpolator instance, can be used to perform custom transitions.
  transitionInterpolator: _propTypes.default.object,
  // type of interruption of current transition on update.
  transitionInterruption: _propTypes.default.number,
  // easing function
  transitionEasing: _propTypes.default.func,
  // transition status update functions
  onTransitionStart: _propTypes.default.func,
  onTransitionInterrupt: _propTypes.default.func,
  onTransitionEnd: _propTypes.default.func,

  /** Enables control event handling */
  // Scroll to zoom
  scrollZoom: _propTypes.default.bool,
  // Drag to pan
  dragPan: _propTypes.default.bool,
  // Drag to rotate
  dragRotate: _propTypes.default.bool,
  // Double click to zoom
  doubleClickZoom: _propTypes.default.bool,
  // Multitouch zoom
  touchZoom: _propTypes.default.bool,
  // Multitouch rotate
  touchRotate: _propTypes.default.bool,
  // Keyboard
  keyboard: _propTypes.default.bool,

  /**
     * Called when the map is hovered over.
     * @callback
     * @param {Object} event - The mouse event.
     * @param {[Number, Number]} event.lngLat - The coordinates of the pointer
     * @param {Array} event.features - The features under the pointer, using Mapbox's
     * queryRenderedFeatures API:
     * https://www.mapbox.com/mapbox-gl-js/api/#Map#queryRenderedFeatures
     * To make a layer interactive, set the `interactive` property in the
     * layer style to `true`. See Mapbox's style spec
     * https://www.mapbox.com/mapbox-gl-style-spec/#layer-interactive
     */
  onHover: _propTypes.default.func,

  /**
    * Called when the map is clicked.
    * @callback
    * @param {Object} event - The mouse event.
    * @param {[Number, Number]} event.lngLat - The coordinates of the pointer
    * @param {Array} event.features - The features under the pointer, using Mapbox's
    * queryRenderedFeatures API:
    * https://www.mapbox.com/mapbox-gl-js/api/#Map#queryRenderedFeatures
    * To make a layer interactive, set the `interactive` property in the
    * layer style to `true`. See Mapbox's style spec
    * https://www.mapbox.com/mapbox-gl-style-spec/#layer-interactive
    */
  onClick: _propTypes.default.func,

  /**
    * Called when the context menu is activated.
    */
  onContextMenu: _propTypes.default.func,

  /** Custom touch-action CSS for the event canvas. Defaults to 'none' */
  touchAction: _propTypes.default.string,

  /** Radius to detect features around a clicked point. Defaults to 0. */
  clickRadius: _propTypes.default.number,

  /** Accessor that returns a cursor style to show interactive state */
  getCursor: _propTypes.default.func,
  // A map control instance to replace the default map controls
  // The object must expose one property: `events` as an array of subscribed
  // event names; and two methods: `setState(state)` and `handle(event)`
  mapControls: _propTypes.default.shape({
    events: _propTypes.default.arrayOf(_propTypes.default.string),
    handleEvent: _propTypes.default.func
  })
});

var getDefaultCursor = function getDefaultCursor(_ref) {
  var isDragging = _ref.isDragging,
      isHovering = _ref.isHovering;
  return isDragging ? _config.default.CURSOR.GRABBING : isHovering ? _config.default.CURSOR.POINTER : _config.default.CURSOR.GRAB;
};

var defaultProps = Object.assign({}, _staticMap.default.defaultProps, _mapState.MAPBOX_LIMITS, _transitionManager.default.defaultProps, {
  onViewStateChange: null,
  onViewportChange: null,
  onClick: null,
  onHover: null,
  onContextMenu: function onContextMenu(event) {
    return event.preventDefault();
  },
  scrollZoom: true,
  dragPan: true,
  dragRotate: true,
  doubleClickZoom: true,
  touchAction: 'none',
  clickRadius: 0,
  getCursor: getDefaultCursor
});
var childContextTypes = {
  viewport: _propTypes.default.instanceOf(_viewportMercatorProject.default),
  isDragging: _propTypes.default.bool,
  eventManager: _propTypes.default.object
};

var InteractiveMap =
/*#__PURE__*/
function (_PureComponent) {
  _inherits(InteractiveMap, _PureComponent);

  _createClass(InteractiveMap, null, [{
    key: "supported",
    value: function supported() {
      return _staticMap.default.supported();
    }
  }]);

  function InteractiveMap(props) {
    var _this;

    _classCallCheck(this, InteractiveMap);

    _this = _possibleConstructorReturn(this, (InteractiveMap.__proto__ || Object.getPrototypeOf(InteractiveMap)).call(this, props)); // Check for deprecated props

    (0, _deprecateWarn.default)(props);
    _this.state = {
      // Whether the cursor is down
      isDragging: false,
      // Whether the cursor is over a clickable feature
      isHovering: false
    }; // If props.mapControls is not provided, fallback to default MapControls instance
    // Cannot use defaultProps here because it needs to be per map instance

    _this._mapControls = props.mapControls || new _mapControls.default();
    _this._eventManager = new _mjolnir.EventManager(null, {
      legacyBlockScroll: false,
      touchAction: props.touchAction
    });

    _this._updateQueryParams(props.mapStyle);

    _this.getMap = _this.getMap.bind(_assertThisInitialized(_this));
    _this.queryRenderedFeatures = _this.queryRenderedFeatures.bind(_assertThisInitialized(_this));
    _this._getFeatures = _this._getFeatures.bind(_assertThisInitialized(_this));
    _this._updateQueryParams = _this._updateQueryParams.bind(_assertThisInitialized(_this));
    _this._onInteractiveStateChange = _this._onInteractiveStateChange.bind(_assertThisInitialized(_this));
    _this._getPos = _this._getPos.bind(_assertThisInitialized(_this));
    _this._eventCanvasLoaded = _this._eventCanvasLoaded.bind(_assertThisInitialized(_this));
    _this._staticMapLoaded = _this._staticMapLoaded.bind(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(InteractiveMap, [{
    key: "getChildContext",
    value: function getChildContext() {
      return {
        viewport: new _viewportMercatorProject.default(this.props),
        isDragging: this.state.isDragging,
        eventManager: this._eventManager
      };
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var eventManager = this._eventManager; // Register additional event handlers for click and hover

      eventManager.on({
        mousemove: this._onMouseMove.bind(this),
        click: this._onMouseClick.bind(this),
        contextmenu: this._onContextMenu.bind(this)
      });

      this._mapControls.setOptions(Object.assign({}, this.props, this.props.viewState, {
        onStateChange: this._onInteractiveStateChange,
        eventManager: eventManager
      }));

      this._transitionManager = new _transitionManager.default(this.props);
    }
  }, {
    key: "componentWillUpdate",
    value: function componentWillUpdate(nextProps) {
      if (this.props.mapStyle !== nextProps.mapStyle) {
        this._updateQueryParams(nextProps.mapStyle);
      }

      var nextPropsWithViewState = Object.assign({}, nextProps, nextProps.viewState);

      this._mapControls.setOptions(nextPropsWithViewState);

      this._transitionManager.processViewportChange(nextPropsWithViewState);
    }
  }, {
    key: "getMap",
    value: function getMap() {
      return this._map ? this._map.getMap() : null;
    }
  }, {
    key: "queryRenderedFeatures",
    value: function queryRenderedFeatures(geometry, options) {
      return this._map.queryRenderedFeatures(geometry, options);
    }
  }, {
    key: "_getFeatures",
    value: function _getFeatures(_ref2) {
      var pos = _ref2.pos,
          radius = _ref2.radius;
      var features;

      if (radius) {
        // Radius enables point features, like marker symbols, to be clicked.
        var size = radius;
        var bbox = [[pos[0] - size, pos[1] + size], [pos[0] + size, pos[1] - size]];
        features = this._map.queryRenderedFeatures(bbox, this._queryParams);
      } else {
        features = this._map.queryRenderedFeatures(pos, this._queryParams);
      }

      return features;
    } // Hover and click only query layers whose interactive property is true

  }, {
    key: "_updateQueryParams",
    value: function _updateQueryParams(mapStyle) {
      var interactiveLayerIds = (0, _styleUtils.getInteractiveLayerIds)(mapStyle);
      this._queryParams = {
        layers: interactiveLayerIds
      };
    }
  }, {
    key: "_onInteractiveStateChange",
    value: function _onInteractiveStateChange(_ref3) {
      var _ref3$isDragging = _ref3.isDragging,
          isDragging = _ref3$isDragging === void 0 ? false : _ref3$isDragging;

      if (isDragging !== this.state.isDragging) {
        this.setState({
          isDragging: isDragging
        });
      }
    } // HOVER AND CLICK

  }, {
    key: "_getPos",
    value: function _getPos(event) {
      var _event$offsetCenter = event.offsetCenter,
          x = _event$offsetCenter.x,
          y = _event$offsetCenter.y;
      return [x, y];
    }
  }, {
    key: "_onMouseMove",
    value: function _onMouseMove(event) {
      if (!this.state.isDragging) {
        var pos = this._getPos(event);

        var features = this._getFeatures({
          pos: pos,
          radius: this.props.clickRadius
        });

        var isHovering = features && features.length > 0;

        if (isHovering !== this.state.isHovering) {
          this.setState({
            isHovering: isHovering
          });
        }

        if (this.props.onHover) {
          var viewport = new _viewportMercatorProject.default(this.props);
          event.lngLat = viewport.unproject(pos);
          event.features = features;
          this.props.onHover(event);
        }
      }
    }
  }, {
    key: "_onMouseClick",
    value: function _onMouseClick(event) {
      if (this.props.onClick) {
        var pos = this._getPos(event);

        var viewport = new _viewportMercatorProject.default(this.props);
        event.lngLat = viewport.unproject(pos);
        event.features = this._getFeatures({
          pos: pos,
          radius: this.props.clickRadius
        });
        this.props.onClick(event);
      }
    }
  }, {
    key: "_onContextMenu",
    value: function _onContextMenu(event) {
      if (this.props.onContextMenu) {
        this.props.onContextMenu(event);
      }
    }
  }, {
    key: "_eventCanvasLoaded",
    value: function _eventCanvasLoaded(ref) {
      // This will be called with `null` after unmount, releasing event manager resource
      this._eventManager.setElement(ref);
    }
  }, {
    key: "_staticMapLoaded",
    value: function _staticMapLoaded(ref) {
      this._map = ref;
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          width = _this$props.width,
          height = _this$props.height,
          getCursor = _this$props.getCursor;
      var eventCanvasStyle = {
        width: width,
        height: height,
        position: 'relative',
        cursor: getCursor(this.state)
      };
      return (0, _react.createElement)('div', {
        key: 'map-controls',
        ref: this._eventCanvasLoaded,
        style: eventCanvasStyle
      }, (0, _react.createElement)(_staticMap.default, Object.assign({}, this.props, this._transitionManager && this._transitionManager.getViewportInTransition(), {
        ref: this._staticMapLoaded,
        children: this.props.children
      })));
    }
  }]);

  return InteractiveMap;
}(_react.PureComponent);

exports.default = InteractiveMap;
InteractiveMap.displayName = 'InteractiveMap';
InteractiveMap.propTypes = propTypes;
InteractiveMap.defaultProps = defaultProps;
InteractiveMap.childContextTypes = childContextTypes;
//# sourceMappingURL=interactive-map.js.map