"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getInteractiveLayerIds = getInteractiveLayerIds;
exports.setDiffStyle = setDiffStyle;

var _isImmutableMap = _interopRequireDefault(require("./is-immutable-map"));

var _diffStyles2 = _interopRequireDefault(require("./diff-styles"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// TODO - remove in the next major release
// Mapbox dropped the `interactive` property: https://github.com/mapbox/mapbox-gl-js/issues/1479
function getInteractiveLayerIds(mapStyle) {
  var interactiveLayerIds = null;

  if ((0, _isImmutableMap.default)(mapStyle) && mapStyle.has('layers')) {
    interactiveLayerIds = mapStyle.get('layers').filter(function (l) {
      return l.get('interactive');
    }).map(function (l) {
      return l.get('id');
    }).toJS();
  } else if (Array.isArray(mapStyle.layers)) {
    interactiveLayerIds = mapStyle.layers.filter(function (l) {
      return l.interactive;
    }).map(function (l) {
      return l.id;
    });
  }

  return interactiveLayerIds;
} // Individually update the maps source and layers that have changed if all
// other style props haven't changed. This prevents flicking of the map when
// styles only change sources or layers.

/* eslint-disable max-statements, complexity */


function setDiffStyle(prevStyle, nextStyle, map) {
  var prevKeysMap = prevStyle && styleKeysMap(prevStyle) || {};
  var nextKeysMap = styleKeysMap(nextStyle);

  function styleKeysMap(style) {
    return style.map(function () {
      return true;
    }).delete('layers').delete('sources').toJS();
  }

  function propsOtherThanLayersOrSourcesDiffer() {
    var prevKeysList = Object.keys(prevKeysMap);
    var nextKeysList = Object.keys(nextKeysMap);

    if (prevKeysList.length !== nextKeysList.length) {
      return true;
    } // `nextStyle` and `prevStyle` should not have the same set of props.


    if (nextKeysList.some(function (key) {
      return prevStyle.get(key) !== nextStyle.get(key);
    } // But the value of one of those props is different.
    )) {
      return true;
    }

    return false;
  }

  if (!prevStyle || propsOtherThanLayersOrSourcesDiffer()) {
    map.setStyle(nextStyle.toJS());
    return;
  }

  var _diffStyles = (0, _diffStyles2.default)(prevStyle, nextStyle),
      sourcesDiff = _diffStyles.sourcesDiff,
      layersDiff = _diffStyles.layersDiff;

  checkForEqualLayerSourceChanges(sourcesDiff.exit, nextStyle.get('layers'));
  applySourceLayerChanges(map, nextStyle, sourcesDiff, layersDiff);
}
/* eslint-enable max-statements, complexity */
// Update a source in the map style


function updateStyleSource(map, update) {
  var newSource = update.source.toJS();

  if (newSource.type === 'geojson') {
    var oldSource = map.getSource(update.id);

    if (oldSource.type === 'geojson') {
      // update data if no other GeoJSONSource options were changed
      var oldOpts = oldSource.workerOptions; // GeoJSONSource class scales user options before assigning to workerOptions
      // https://github.com/mapbox/mapbox-gl-js/blob/master/src/source/geojson_source.js

      var scale = oldOpts.geojsonVtOptions.extent / 512;

      if ((newSource.maxzoom === undefined || newSource.maxzoom === oldOpts.geojsonVtOptions.maxZoom) && (newSource.buffer === undefined || newSource.buffer === oldOpts.geojsonVtOptions.buffer / scale) && (newSource.tolerance === undefined || newSource.tolerance === oldOpts.geojsonVtOptions.tolerance / scale) && (newSource.cluster === undefined || newSource.cluster === oldOpts.cluster) && (newSource.clusterRadius === undefined || newSource.clusterRadius === oldOpts.superclusterOptions.radius / scale) && (newSource.clusterMaxZoom === undefined || newSource.clusterMaxZoom === oldOpts.superclusterOptions.maxZoom)) {
        oldSource.setData(newSource.data);
        return;
      }
    }
  }

  map.removeSource(update.id);
  map.addSource(update.id, newSource);
}

function applySourceLayerChanges(map, nextStyle, sourcesDiff, layersDiff) {
  // TODO: It's rather difficult to determine style diffing in the presence
  // of refs. For now, if any style update has a ref, fallback to no diffing.
  // We can come back to this case if there's a solid usecase.
  if (layersDiff.updates.some(function (node) {
    return node.layer.get('ref');
  })) {
    map.setStyle(nextStyle.toJS());
    return;
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = sourcesDiff.enter[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var enter = _step.value;
      map.addSource(enter.id, enter.source.toJS());
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = sourcesDiff.update[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var update = _step2.value;
      updateStyleSource(map, update);
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = layersDiff.exiting[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var exit = _step3.value;

      if (map.style.getLayer(exit.id)) {
        map.removeLayer(exit.id);
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
        _iterator3.return();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = layersDiff.updates[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var _update = _step4.value;

      if (!_update.enter) {
        // This is an old layer that needs to be updated. Remove the old layer
        // with the same id and add it back again.
        map.removeLayer(_update.id);
      }

      map.addLayer(_update.layer.toJS(), _update.before);
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
        _iterator4.return();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  var _iteratorNormalCompletion5 = true;
  var _didIteratorError5 = false;
  var _iteratorError5 = undefined;

  try {
    for (var _iterator5 = sourcesDiff.exit[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
      var _exit = _step5.value;
      map.removeSource(_exit.id);
    }
  } catch (err) {
    _didIteratorError5 = true;
    _iteratorError5 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
        _iterator5.return();
      }
    } finally {
      if (_didIteratorError5) {
        throw _iteratorError5;
      }
    }
  }
}
/* eslint-disable max-len */


function checkForEqualLayerSourceChanges(sourceExit, nextLayers) {
  var sourceIds = sourceExit.map(function (s) {
    return s.id;
  });
  var layersNotRemoved = nextLayers.filter(function (lyr) {
    return sourceIds.includes(lyr.get('source'));
  });

  if (layersNotRemoved.size) {
    // because of this, no source/layer changes will take effect if there is an error
    throw new Error("You must remove any layers associated with sources you are removing: ".concat(layersNotRemoved.map(function (l) {
      return l.get('id');
    }).toJS().join('')));
  }
}
//# sourceMappingURL=style-utils.js.map