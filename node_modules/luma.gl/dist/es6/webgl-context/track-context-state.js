// Support for listening to context state changes and intercepting state queries
//
// NOTE: this system does not handle buffer bindings
import { setParameters, getParameters, GL_PARAMETER_DEFAULTS } from './set-parameters';
import assert from '../utils/assert';
export const clone = x => {
  return Array.isArray(x) || ArrayBuffer.isView(x) ? x.slice() : x;
};
export const deepEqual = (x, y) => {
  const isArrayX = Array.isArray(x) || ArrayBuffer.isView(x);
  const isArrayY = Array.isArray(y) || ArrayBuffer.isView(y);

  if (isArrayX && isArrayY && x.length === y.length) {
    for (let i = 0; i < x.length; ++i) {
      if (x[i] !== y[i]) {
        return false;
      }
    }

    return true;
  }

  return x === y;
}; // interceptors for WEBGL FUNCTIONS that set WebGLRenderingContext state
// These "setters" map functions to gl parameters

export const GL_STATE_SETTERS = {
  // GENERIC SETTERS
  enable: (update, cap) => update({
    [cap]: true
  }),
  disable: (update, cap) => update({
    [cap]: false
  }),
  pixelStorei: (update, pname, param) => update({
    [pname]: param
  }),
  hint: (update, pname, _hint) => update({
    [pname]: _hint
  }),
  // SPECIFIC SETTERS
  bindFramebuffer: (update, target, fb) => {
    switch (target) {
      case 36160:
        return update({
          [36006]: fb,
          [36010]: fb
        });

      case 36009:
        return update({
          [36006]: fb
        });

      case 36008:
        return update({
          [36010]: fb
        });

      default:
        return null;
    }
  },
  blendColor: (update, r, g, b, a) => update({
    [32773]: new Float32Array([r, g, b, a])
  }),
  blendEquation: (update, mode) => update({
    [32777]: mode,
    [34877]: mode
  }),
  blendEquationSeparate: (update, modeRGB, modeAlpha) => update({
    [32777]: modeRGB,
    [34877]: modeAlpha
  }),
  blendFunc: (update, src, dst) => update({
    [32969]: src,
    [32968]: dst,
    [32971]: src,
    [32970]: dst
  }),
  blendFuncSeparate: (update, srcRGB, dstRGB, srcAlpha, dstAlpha) => update({
    [32969]: srcRGB,
    [32968]: dstRGB,
    [32971]: srcAlpha,
    [32970]: dstAlpha
  }),
  clearColor: (update, r, g, b, a) => update({
    [3106]: new Float32Array([r, g, b, a])
  }),
  clearDepth: (update, depth) => update({
    [2931]: depth
  }),
  clearStencil: (update, s) => update({
    [2961]: s
  }),
  colorMask: (update, r, g, b, a) => update({
    [3107]: [r, g, b, a]
  }),
  cullFace: (update, mode) => update({
    [2885]: mode
  }),
  depthFunc: (update, func) => update({
    [2932]: func
  }),
  depthRange: (update, zNear, zFar) => update({
    [2928]: new Float32Array([zNear, zFar])
  }),
  depthMask: (update, mask) => update({
    [2930]: mask
  }),
  frontFace: (update, face) => update({
    [2886]: face
  }),
  lineWidth: (update, width) => update({
    [2849]: width
  }),
  polygonOffset: (update, factor, units) => update({
    [32824]: factor,
    [10752]: units
  }),
  sampleCoverage: (update, value, invert) => update({
    [32938]: value,
    [32939]: invert
  }),
  scissor: (update, x, y, width, height) => update({
    [3088]: new Int32Array([x, y, width, height])
  }),
  stencilMask: (update, mask) => update({
    [2968]: mask,
    [36005]: mask
  }),
  stencilMaskSeparate: (update, face, mask) => update({
    [face === 1028 ? 2968 : 36005]: mask
  }),
  stencilFunc: (update, func, ref, mask) => update({
    [2962]: func,
    [2967]: ref,
    [2963]: mask,
    [34816]: func,
    [36003]: ref,
    [36004]: mask
  }),
  stencilFuncSeparate: (update, face, func, ref, mask) => update({
    [face === 1028 ? 2962 : 34816]: func,
    [face === 1028 ? 2967 : 36003]: ref,
    [face === 1028 ? 2963 : 36004]: mask
  }),
  stencilOp: (update, fail, zfail, zpass) => update({
    [2964]: fail,
    [2965]: zfail,
    [2966]: zpass,
    [34817]: fail,
    [34818]: zfail,
    [34819]: zpass
  }),
  stencilOpSeparate: (update, face, fail, zfail, zpass) => update({
    [face === 1028 ? 2964 : 34817]: fail,
    [face === 1028 ? 2965 : 34818]: zfail,
    [face === 1028 ? 2966 : 34819]: zpass
  }),
  viewport: (update, x, y, width, height) => update({
    [2978]: new Int32Array([x, y, width, height])
  })
}; // HELPER FUNCTIONS - INSTALL GET/SET INTERCEPTORS (SPYS) ON THE CONTEXT
// Overrides a WebGLRenderingContext state "getter" function
// to return values directly from cache

function installGetterOverride(gl, functionName) {
  // Get the original function from the WebGLRenderingContext
  const originalGetterFunc = gl[functionName].bind(gl); // Wrap it with a spy so that we can update our state cache when it gets called

  gl[functionName] = function get(...params) {
    const pname = params[0]; // WebGL limits are not prepopulated in the cache, we must
    // query first time. They are all primitive (single value)

    if (!(pname in gl.state.cache)) {
      gl.state.cache[pname] = originalGetterFunc(...params);
    } // Optionally call the original function to do a "hard" query from the WebGLRenderingContext


    return gl.state.enable ? // Call the getter the params so that it can e.g. serve from a cache
    gl.state.cache[pname] : // Optionally call the original function to do a "hard" query from the WebGLRenderingContext
    originalGetterFunc(...params);
  }; // Set the name of this anonymous function to help in debugging and profiling


  Object.defineProperty(gl[functionName], 'name', {
    value: `${functionName}-from-cache`,
    configurable: false
  });
} // Overrides a WebGLRenderingContext state "setter" function
// to call a setter spy before the actual setter. Allows us to keep a cache
// updated with a copy of the WebGL context state.


function installSetterSpy(gl, functionName, setter) {
  // Get the original function from the WebGLRenderingContext
  const originalSetterFunc = gl[functionName].bind(gl); // Wrap it with a spy so that we can update our state cache when it gets called

  gl[functionName] = function set(...params) {
    // Update the value
    // Call the setter with the state cache and the params so that it can store the parameters
    const _setter = setter(gl.state._updateCache, ...params),
          valueChanged = _setter.valueChanged,
          oldValue = _setter.oldValue; // Call the original WebGLRenderingContext func to make sure the context actually gets updated


    if (valueChanged) {
      gl.state.log(`gl.${functionName}`, ...params); // eslint-disable-line

      originalSetterFunc(...params);
    } // Note: if the original function fails to set the value, our state cache will be bad
    // No solution for this at the moment, but assuming that this is unlikely to be a real problem
    // We could call the setter after the originalSetterFunc. Concern is that this would
    // cause different behavior in debug mode, where originalSetterFunc can throw exceptions


    return oldValue;
  }; // Set the name of this anonymous function to help in debugging and profiling


  Object.defineProperty(gl[functionName], 'name', {
    value: `${functionName}-to-cache`,
    configurable: false
  });
} // HELPER CLASS - GLState

/* eslint-disable no-shadow */


class GLState {
  constructor(gl, {
    copyState = false,
    // Copy cache from params (slow) or initialize from WebGL defaults (fast)
    log = () => {} // Logging function, called when gl parameter change calls are actually issued

  } = {}) {
    this.gl = gl;
    this.stateStack = [];
    this.enable = true;
    this.cache = copyState ? getParameters(gl) : Object.assign({}, GL_PARAMETER_DEFAULTS);
    this.log = log;
    this._updateCache = this._updateCache.bind(this);
    Object.seal(this);
  }

  push(values = {}) {
    this.stateStack.push({});
  }

  pop() {
    assert(this.stateStack.length > 0); // Use the saved values in the state stack to restore parameters

    const oldValues = this.stateStack[this.stateStack.length - 1];
    setParameters(this.gl, oldValues, this.cache); // Don't pop until we have reset parameters (to make sure other "stack frames" are not affected)

    this.stateStack.pop();
  } // interceptor for context set functions - update our cache and our stack
  // values (Object) - the key values for this setter


  _updateCache(values) {
    let valueChanged = false;
    let oldValue; // = undefined

    const oldValues = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];

    for (const key in values) {
      assert(key !== undefined); // Check that value hasn't already been shadowed

      if (!deepEqual(values[key], this.cache[key])) {
        valueChanged = true;
        oldValue = this.cache[key]; // First, save current value being shadowed
        // If a state stack frame is active, save the current parameter values for pop
        // but first check that value hasn't already been shadowed and saved

        if (oldValues && !(key in oldValues)) {
          oldValues[key] = this.cache[key];
        } // Save current value being shadowed


        this.cache[key] = values[key];
      }
    }

    return {
      valueChanged,
      oldValue
    };
  }

} // PUBLIC API

/**
 * Initialize WebGL state caching on a context
 * can be called multiple times to enable/disable
 * @param {WebGLRenderingContext} - context
 */
// After calling this function, context state will be cached
// gl.state.push() and gl.state.pop() will be available for saving,
// temporarily modifying, and then restoring state.


export default function trackContextState(gl, {
  enable = true,
  copyState
} = {}) {
  assert(copyState !== undefined);

  if (!gl.state) {
    /* global window, global */
    const global_ = typeof global !== 'undefined' ? global : window;

    if (global_.polyfillContext) {
      global_.polyfillContext(gl);
    } // Create a state cache


    gl.state = new GLState(gl, {
      copyState,
      enable
    }); // intercept all setter functions in the table

    for (const key in GL_STATE_SETTERS) {
      const setter = GL_STATE_SETTERS[key];
      installSetterSpy(gl, key, setter);
    } // intercept all getter functions in the table


    installGetterOverride(gl, 'getParameter');
    installGetterOverride(gl, 'isEnabled');
  }

  gl.state.enable = enable;
  return gl;
}
export function pushContextState(gl) {
  if (!gl.state) {
    trackContextState(gl, {
      copyState: false
    });
  }

  gl.state.push();
}
export function popContextState(gl) {
  assert(gl.state);
  gl.state.pop();
}
//# sourceMappingURL=track-context-state.js.map