import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import Resource from './resource';
import Texture2D from './texture-2d';
import Renderbuffer from './renderbuffer';
import Buffer from './buffer';
import { clear, clearBuffer } from './clear';
import { withParameters } from '../webgl-context';
import { getFeatures } from '../webgl-context/context-features';
import { getTypedArrayFromGLType, getGLTypeFromTypedArray } from '../webgl-utils/typed-array-utils';
import { glFormatToComponents, glTypeToBytes } from '../webgl-utils/format-utils';
import { isWebGL2, assertWebGL2Context } from '../webgl-utils';
import { flipRows, scalePixels } from '../webgl-utils';
import { glKey } from '../webgl-utils/constants-to-keys';
import { log } from '../utils';
import assert from '../utils/assert';
const ERR_MULTIPLE_RENDERTARGETS = 'Multiple render targets not supported';
export default class Framebuffer extends Resource {
  static isSupported(gl, {
    colorBufferFloat,
    // Whether floating point textures can be rendered and read
    colorBufferHalfFloat // Whether half float textures can be rendered and read

  } = {}) {
    let supported = true;
    supported = colorBufferFloat && gl.getExtension(isWebGL2(gl) ? 'EXT_color_buffer_float' : 'WEBGL.color_buffer_float');
    supported = colorBufferHalfFloat && gl.getExtension(isWebGL2(gl) ? 'EXT_color_buffer_float' : 'EXT_color_buffer_half_float');
    return supported;
  } // Create a Framebuffer wrapper for the default framebuffer (target === null)


  static getDefaultFramebuffer(gl) {
    gl.luma = gl.luma || {};
    gl.luma.defaultFramebuffer = gl.luma.defaultFramebuffer || new Framebuffer(gl, {
      id: 'default-framebuffer',
      handle: null,
      attachments: {}
    }); // TODO - can we query for and get a handle to the GL.FRONT renderbuffer?

    return gl.luma.defaultFramebuffer;
  }

  get MAX_COLOR_ATTACHMENTS() {
    return this.gl.getParameter(this.gl.MAX_COLOR_ATTACHMENTS);
  }

  get MAX_DRAW_BUFFERS() {
    return this.gl.getParameter(this.gl.MAX_DRAW_BUFFERS);
  }

  constructor(gl, opts = {}) {
    super(gl, opts); // Public members

    this.width = null;
    this.height = null;
    this.attachments = {};
    this.readBuffer = 36064;
    this.drawBuffers = [36064];
    this.initialize(opts);
    Object.seal(this);
  }

  get color() {
    return this.attachments[36064] || null;
  }

  get texture() {
    return this.attachments[36064] || null;
  }

  get depth() {
    return this.attachments[36096] || this.attachments[33306] || null;
  }

  get stencil() {
    return this.attachments[36128] || this.attachments[33306] || null;
  }

  initialize({
    width = 1,
    height = 1,
    attachments = null,
    color = true,
    depth = true,
    stencil = false,
    check = true,
    readBuffer,
    drawBuffers
  }) {
    assert(width >= 0 && height >= 0, 'Width and height need to be integers'); // Store actual width and height for diffing

    this.width = width;
    this.height = height; // Resize any provided attachments - note that resize only resizes if needed
    // Note: A framebuffer has no separate size, it is defined by its attachments (which must agree)

    if (attachments) {
      for (const attachment in attachments) {
        const target = attachments[attachment];
        const object = Array.isArray(target) ? target[0] : target;
        object.resize({
          width,
          height
        });
      }
    } else {
      // Create any requested default attachments
      attachments = this._createDefaultAttachments({
        color,
        depth,
        stencil,
        width,
        height
      });
    }

    this.update({
      clearAttachments: true,
      attachments,
      readBuffer,
      drawBuffers
    }); // Checks that framebuffer was properly set up, if not, throws an explanatory error

    if (attachments && check) {
      this.checkStatus();
    }
  }

  update({
    attachments = {},
    readBuffer,
    drawBuffers,
    clearAttachments = false
  }) {
    this.attach(attachments, {
      clearAttachments
    });
    const gl = this.gl; // Multiple render target support, set read buffer and draw buffers

    const prevHandle = gl.bindFramebuffer(36160, this.handle);

    if (readBuffer) {
      this._setReadBuffer(readBuffer);
    }

    if (drawBuffers) {
      this._setDrawBuffers(drawBuffers);
    }

    gl.bindFramebuffer(36160, prevHandle || null);
    return this;
  } // Attachment resize is expected to be a noop if size is same


  resize({
    width,
    height
  } = {}) {
    // for default framebuffer, just update the stored size
    if (this.handle === null) {
      assert(width === undefined && height === undefined);
      this.width = this.gl.drawingBufferWidth;
      this.height = this.gl.drawingBufferHeight;
      return this;
    }

    if (width === undefined) {
      width = this.gl.drawingBufferWidth;
    }

    if (height === undefined) {
      height = this.gl.drawingBufferHeight;
    }

    if (width !== this.width && height !== this.height) {
      log.log(2, `Resizing framebuffer ${this.id} to ${width}x${height}`);
    }

    for (const attachmentPoint in this.attachments) {
      this.attachments[attachmentPoint].resize({
        width,
        height
      });
    }

    this.width = width;
    this.height = height;
    return this;
  } // Attach from a map of attachments


  attach(attachments, {
    clearAttachments = false
  } = {}) {
    const newAttachments = {}; // Any current attachments need to be removed, add null values to map

    if (clearAttachments) {
      Object.keys(this.attachments).forEach(key => {
        newAttachments[key] = null;
      });
    } // Overlay the new attachments


    Object.assign(newAttachments, attachments);
    const prevHandle = this.gl.bindFramebuffer(36160, this.handle); // Walk the attachments

    for (const key in newAttachments) {
      // Ensure key is not undefined
      assert(key !== undefined, 'Misspelled framebuffer binding point?');
      const attachment = Number(key);
      const descriptor = newAttachments[attachment];
      let object = descriptor;

      if (!object) {
        this._unattach({
          attachment
        });
      } else if (object instanceof Renderbuffer) {
        this._attachRenderbuffer({
          attachment,
          renderbuffer: object
        });
      } else if (Array.isArray(descriptor)) {
        const _descriptor = _slicedToArray(descriptor, 3),
              texture = _descriptor[0],
              _descriptor$ = _descriptor[1],
              layer = _descriptor$ === void 0 ? 0 : _descriptor$,
              _descriptor$2 = _descriptor[2],
              level = _descriptor$2 === void 0 ? 0 : _descriptor$2;

        object = texture;

        this._attachTexture({
          attachment,
          texture,
          layer,
          level
        });
      } else {
        this._attachTexture({
          attachment,
          texture: object,
          layer: 0,
          level: 0
        });
      } // Resize objects


      if (object) {
        object.resize({
          width: this.width,
          height: this.height
        });
      }
    }

    this.gl.bindFramebuffer(36160, prevHandle || null); // Assign to attachments and remove any nulls to get a clean attachment map

    Object.assign(this.attachments, attachments);
    Object.keys(this.attachments).filter(key => !this.attachments[key]).forEach(key => {
      delete this.attachments[key];
    });
  }

  checkStatus() {
    const gl = this.gl;
    const prevHandle = gl.bindFramebuffer(36160, this.handle);
    const status = gl.checkFramebufferStatus(36160);
    gl.bindFramebuffer(36160, prevHandle || null);

    if (status !== 36053) {
      throw new Error(_getFrameBufferStatus(status));
    }

    return this;
  }

  clear({
    color,
    depth,
    stencil,
    drawBuffers = []
  } = {}) {
    // Bind framebuffer and delegate to global clear functions
    const prevHandle = this.gl.bindFramebuffer(36160, this.handle);

    if (color || depth || stencil) {
      clear(this.gl, {
        color,
        depth,
        stencil
      });
    }

    drawBuffers.forEach((value, drawBuffer) => {
      clearBuffer({
        drawBuffer,
        value
      });
    });
    this.gl.bindFramebuffer(36160, prevHandle || null);
    return this;
  } // NOTE: Slow requires roundtrip to GPU
  // App can provide pixelArray or have it auto allocated by this method
  // @returns {Uint8Array|Uint16Array|FloatArray} - pixel array,
  //  newly allocated by this method unless provided by app.


  readPixels({
    x = 0,
    y = 0,
    width = this.width,
    height = this.height,
    format = 6408,
    type,
    // Auto deduced from pixelArray or gl.UNSIGNED_BYTE
    pixelArray = null,
    attachment = 36064 // TODO - support gl.readBuffer

  } = {}) {
    const gl = this.gl; // TODO - Set and unset gl.readBuffer

    if (attachment === 36064 && this.handle === null) {
      attachment = 1028;
    }

    assert(this.attachments[attachment]); // Deduce the type from color attachment if not provided.

    type = type || this.attachments[attachment].type; // Deduce type and allocated pixelArray if needed

    if (!pixelArray) {
      // Allocate pixel array if not already available, using supplied type
      type = type || 5121;
      const ArrayType = getTypedArrayFromGLType(type, {
        clamped: false
      });
      const components = glFormatToComponents(format); // TODO - check for composite type (components = 1).

      pixelArray = pixelArray || new ArrayType(width * height * components);
    } // Pixel array available, if necessary, deduce type from it.


    type = type || getGLTypeFromTypedArray(pixelArray);
    const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
    this.gl.readPixels(x, y, width, height, format, type, pixelArray);
    this.gl.bindFramebuffer(36160, prevHandle || null);
    return pixelArray;
  } // Reads data into provided buffer object asynchronously
  // This function doesn't wait for copy to be complete, it programs GPU to perform a DMA transffer.


  readPixelsToBuffer({
    x = 0,
    y = 0,
    width = this.width,
    height = this.height,
    format = 6408,
    type,
    // When not provided, auto deduced from buffer or GL.UNSIGNED_BYTE
    buffer = null,
    // A new Buffer object is created when not provided.
    byteOffset = 0 // byte offset in buffer object

  }) {
    const gl = this.gl; // Asynchronus read (PIXEL_PACK_BUFFER) is WebGL2 only feature

    assertWebGL2Context(gl); // deduce type if not available.

    type = type || (buffer ? buffer.type : 5121);

    if (!buffer) {
      // Create new buffer with enough size
      const components = glFormatToComponents(format);
      const byteCount = glTypeToBytes(type);
      const bytes = byteOffset + width * height * components * byteCount;
      buffer = new Buffer(gl, {
        bytes,
        type,
        size: components
      });
    }

    buffer.bind({
      target: 35051
    });
    withParameters(gl, {
      framebuffer: this
    }, () => {
      gl.readPixels(x, y, width, height, format, type, byteOffset);
    });
    buffer.unbind({
      target: 35051
    });
    return buffer;
  } // Reads pixels as a dataUrl


  copyToDataUrl({
    attachment = 36064,
    // TODO - support gl.readBuffer
    maxHeight = Number.MAX_SAFE_INTEGER
  } = {}) {
    let data = this.readPixels({
      attachment
    }); // Scale down

    let width = this.width,
        height = this.height;

    while (height > maxHeight) {
      var _scalePixels = scalePixels({
        data,
        width,
        height
      });

      data = _scalePixels.data;
      width = _scalePixels.width;
      height = _scalePixels.height;
    } // Flip to top down coordinate system


    flipRows({
      data,
      width,
      height
    });
    /* global document */

    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const context = canvas.getContext('2d'); // Copy the pixels to a 2D canvas

    const imageData = context.createImageData(width, height);
    imageData.data.set(data);
    context.putImageData(imageData, 0, 0);
    return canvas.toDataURL();
  } // Reads pixels into an HTML Image


  copyToImage({
    image = null,
    attachment = 36064,
    // TODO - support gl.readBuffer
    maxHeight = Number.MAX_SAFE_INTEGER
  } = {}) {
    /* global Image */
    const dataUrl = this.readDataUrl({
      attachment
    });
    image = image || new Image();
    image.src = dataUrl;
    return image;
  } // copyToFramebuffer({width, height}) {
  //   const scaleX = width / this.width;
  //   const scaleY = height / this.height;
  //   const scale = Math.min(scaleX, scaleY);
  //   width = width * scale;
  //   height = height * scale;
  //   const scaledFramebuffer = new Framebuffer(this.gl, {width, height});
  //   this.blit();
  // }
  // Copy a rectangle from a framebuffer attachment into a texture (at an offset)


  copyToTexture({
    // Target
    texture,
    target,
    // for cubemaps
    xoffset = 0,
    yoffset = 0,
    zoffset = 0,
    mipmapLevel = 0,
    // Source
    attachment = 36064,
    // TODO - support gl.readBuffer
    x = 0,
    y = 0,
    width,
    // defaults to texture width
    height // defaults to texture height

  }) {
    const gl = this.gl;
    const prevHandle = gl.bindFramebuffer(36160, this.handle);
    const prevBuffer = gl.readBuffer(attachment);
    width = Number.isFinite(width) ? width : texture.width;
    height = Number.isFinite(height) ? height : texture.height; // target

    switch (texture.target) {
      case 3553:
      case 34067:
        gl.copyTexSubImage2D(target || texture.target, mipmapLevel, xoffset, yoffset, x, y, width, height);
        break;

      case 35866:
      case 32879:
        gl.copyTexSubImage3D(target || texture.target, mipmapLevel, xoffset, yoffset, zoffset, x, y, width, height);
        break;

      default:
    }

    gl.readBuffer(prevBuffer);
    gl.bindFramebuffer(36160, prevHandle || null);
    return texture;
  } // WEBGL2 INTERFACE
  // Copies a rectangle of pixels between framebuffers
  // eslint-disable-next-line complexity


  blit({
    srcFramebuffer,
    attachment = 36064,
    srcX0 = 0,
    srcY0 = 0,
    srcX1,
    srcY1,
    dstX0 = 0,
    dstY0 = 0,
    dstX1,
    dstY1,
    color = true,
    depth = false,
    stencil = false,
    mask = 0,
    filter = 9728
  }) {
    const gl = this.gl;
    assertWebGL2Context(gl);

    if (!srcFramebuffer.handle && attachment === 36064) {
      attachment = 1028;
    }

    if (color) {
      mask |= 16384;
    }

    if (depth) {
      mask |= 256;
    }

    if (stencil) {
      mask |= 1024;
    }

    assert(mask);
    srcX1 = srcX1 === undefined ? srcFramebuffer.width : srcX1;
    srcY1 = srcY1 === undefined ? srcFramebuffer.height : srcY1;
    dstX1 = dstX1 === undefined ? this.width : dstX1;
    dstY1 = dstY1 === undefined ? this.height : dstY1;
    const prevDrawHandle = gl.bindFramebuffer(36009, this.handle);
    const prevReadHandle = gl.bindFramebuffer(36008, srcFramebuffer.handle);
    gl.readBuffer(attachment);
    gl.blitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    gl.readBuffer(this.readBuffer);
    gl.bindFramebuffer(36008, prevReadHandle || null);
    gl.bindFramebuffer(36009, prevDrawHandle || null);
    return this;
  } // signals to the GL that it need not preserve all pixels of a specified region of the framebuffer


  invalidate({
    attachments = [],
    x = 0,
    y = 0,
    width,
    height
  }) {
    const gl = this.gl;
    assertWebGL2Context(gl);
    const prevHandle = gl.bindFramebuffer(36008, this.handle);
    const invalidateAll = x === 0 && y === 0 && width === undefined && height === undefined;

    if (invalidateAll) {
      gl.invalidateFramebuffer(36008, attachments);
    } else {
      gl.invalidateFramebuffer(36008, attachments, x, y, width, height);
    }

    gl.bindFramebuffer(36008, prevHandle);
    return this;
  } // Return the value for `pname` of the specified attachment.
  // The type returned is the type of the requested pname


  getAttachmentParameter(attachment, pname, keys) {
    let value = this._getAttachmentParameterFallback(pname);

    if (value === null) {
      this.gl.bindFramebuffer(36160, this.handle);
      value = this.gl.getFramebufferAttachmentParameter(36160, attachment, pname);
      this.gl.bindFramebuffer(36160, null);
    }

    if (keys && value > 1000) {
      value = glKey(this.gl, value);
    }

    return value;
  }

  getAttachmentParameters(attachment = 36064, keys, parameters = this.constructor.ATTACHMENT_PARAMETERS || []) {
    const values = {};

    for (const pname of parameters) {
      const key = keys ? glKey(this.gl, pname) : pname;
      values[key] = this.getAttachmentParameter(attachment, pname, keys);
    }

    return values;
  }

  getParameters(keys = true) {
    const attachments = Object.keys(this.attachments); // if (this === this.gl.luma.defaultFramebuffer) {
    //   attachments = [GL.COLOR_ATTACHMENT0, GL.DEPTH_STENCIL_ATTACHMENT];
    // }

    const parameters = {};

    for (const attachmentName of attachments) {
      const attachment = Number(attachmentName);
      const key = keys ? glKey(this.gl, attachment) : attachment;
      parameters[key] = this.getAttachmentParameters(attachment, keys);
    }

    return parameters;
  } // DEBUG
  // Note: Will only work when called in an event handler


  show() {
    /* global window */
    if (typeof window !== 'undefined') {
      window.open(this.copyToDataUrl(), 'luma-debug-texture');
    }

    return this;
  }

  log(priority = 0, message = '') {
    if (priority > log.priority || typeof window === 'undefined') {
      return this;
    }

    message = message || `Framebuffer ${this.id}`;
    const image = this.copyToDataUrl({
      maxHeight: 100
    });
    log.image({
      priority,
      message,
      image
    }, message)();
    return this;
  } // WEBGL INTERFACE


  bind({
    target = 36160
  } = {}) {
    this.gl.bindFramebuffer(target, this.handle);
    return this;
  }

  unbind({
    target = 36160
  } = {}) {
    this.gl.bindFramebuffer(target, null);
    return this;
  } // PRIVATE METHODS


  _createDefaultAttachments({
    color,
    depth,
    stencil,
    width,
    height
  }) {
    let defaultAttachments = null; // Add a color buffer if requested and not supplied

    if (color) {
      defaultAttachments = defaultAttachments || {};
      defaultAttachments[36064] = new Texture2D(this.gl, {
        id: `${this.id}-color0`,
        pixels: null,
        // reserves texture memory, but texels are undefined
        format: 6408,
        type: 5121,
        width,
        height,
        // Note: Mipmapping can be disabled by texture resource when we resize the texture
        // to a non-power-of-two dimenstion (NPOT texture) under WebGL1. To have consistant
        // behavior we always disable mipmaps.
        mipmaps: false,
        // Set MIN and MAG filtering parameters so mipmaps are not used in sampling.
        // Set WRAP modes that support NPOT textures too.
        parameters: {
          [10241]: 9728,
          [10240]: 9728,
          [10242]: 33071,
          [10243]: 33071
        }
      });
    }

    if (depth && stencil) {
      // TODO - handle separate stencil
      defaultAttachments = defaultAttachments || {};
      defaultAttachments[33306] = new Renderbuffer(this.gl, {
        id: `${this.id}-depth-stencil`,
        format: 35056,
        width,
        height: 111
      }); // TODO - optional texture
      // new Texture2D(this.gl, {
      //   id: `${this.id}-depth-stencil`,
      //   format: GL.DEPTH24_STENCIL8,
      //   dataFormat: GL.DEPTH_STENCIL,
      //   type: GL.UNSIGNED_INT_24_8,
      //   width,
      //   height,
      //   mipmaps: false
      // });
    } else if (depth) {
      // Add a depth buffer if requested and not supplied
      defaultAttachments = defaultAttachments || {};
      defaultAttachments[36096] = new Renderbuffer(this.gl, {
        id: `${this.id}-depth`,
        format: 33189,
        width,
        height
      });
    } else if (stencil) {
      // TODO - handle separate stencil
      assert(false);
    }

    return defaultAttachments;
  }

  _unattach({
    attachment
  }) {
    this.gl.bindRenderbuffer(36161, this.handle);
    this.gl.framebufferRenderbuffer(36160, attachment, 36161, null);
    delete this.attachments[attachment];
  }

  _attachRenderbuffer({
    attachment = 36064,
    renderbuffer
  }) {
    const gl = this.gl; // TODO - is the bind needed?
    // gl.bindRenderbuffer(GL.RENDERBUFFER, renderbuffer.handle);

    gl.framebufferRenderbuffer(36160, attachment, 36161, renderbuffer.handle); // TODO - is the unbind needed?
    // gl.bindRenderbuffer(GL.RENDERBUFFER, null);

    this.attachments[attachment] = renderbuffer;
  } // layer = 0 - index into Texture2DArray and Texture3D or face for `TextureCubeMap`
  // level = 0 - mipmapLevel (must be 0 in WebGL1)


  _attachTexture({
    attachment = 36064,
    texture,
    layer,
    level
  }) {
    const gl = this.gl;
    gl.bindTexture(texture.target, texture.handle);

    switch (texture.target) {
      case 35866:
      case 32879:
        gl.framebufferTextureLayer(36160, attachment, texture.target, level, layer);
        break;

      case 34067:
        // layer must be a cubemap face (or if index, converted to cube map face)
        const face = mapIndexToCubeMapFace(layer);
        gl.framebufferTexture2D(36160, attachment, face, texture.handle, level);
        break;

      case 3553:
        gl.framebufferTexture2D(36160, attachment, 3553, texture.handle, level);
        break;

      default:
        assert(false, 'Illegal texture type');
    }

    gl.bindTexture(texture.target, null);
    this.attachments[attachment] = texture;
  } // Expects framebuffer to be bound


  _setReadBuffer(gl, readBuffer) {
    if (isWebGL2(gl)) {
      gl.readBuffer(readBuffer);
    } else {
      // Setting to color attachment 0 is a noop, so allow it in WebGL1
      assert(readBuffer === 36064 || readBuffer === 1029, ERR_MULTIPLE_RENDERTARGETS);
    }

    this.readBuffer = readBuffer;
  } // Expects framebuffer to be bound


  _setDrawBuffers(gl, drawBuffers) {
    if (isWebGL2(gl)) {
      gl.drawBuffers(drawBuffers);
    } else {
      const ext = gl.getExtension('WEBGL.draw_buffers');

      if (ext) {
        ext.drawBuffersWEBGL(drawBuffers);
      } else {
        // Setting a single draw buffer to color attachment 0 is a noop, allow in WebGL1
        assert(drawBuffers.length === 1 && (drawBuffers[0] === 36064 || drawBuffers[0] === 1029), ERR_MULTIPLE_RENDERTARGETS);
      }
    }

    this.drawBuffers = drawBuffers;
  } // Attempt to provide workable defaults for WebGL2 symbols under WebGL1
  // null means OK to query
  // TODO - move to webgl1 polyfills

  /* eslint-disable complexity */


  _getAttachmentParameterFallback(pname) {
    const caps = getFeatures(this.gl);

    switch (pname) {
      case 36052:
        // GLint
        return !caps.webgl2 ? 0 : null;

      case 33298: // GLint

      case 33299: // GLint

      case 33300: // GLint

      case 33301: // GLint

      case 33302: // GLint

      case 33303:
        // GLint
        return !caps.webgl2 ? 8 : null;

      case 33297:
        // GLenum
        return !caps.webgl2 ? 5125 : null;

      case 33296:
        return !caps.webgl2 && !caps.EXT_sRGB ? 9729 : null;

      default:
        return null;
    }
  }
  /* eslint-enable complexity */
  // RESOURCE METHODS


  _createHandle() {
    return this.gl.createFramebuffer();
  }

  _deleteHandle() {
    this.gl.deleteFramebuffer(this.handle);
  }

  _bindHandle(handle) {
    return this.gl.bindFramebuffer(36160, handle);
  }

} // PUBLIC METHODS
// Map an index to a cube map face constant

function mapIndexToCubeMapFace(layer) {
  // TEXTURE_CUBE_MAP_POSITIVE_X is a big value (0x8515)
  // if smaller assume layer is index, otherwise assume it is already a cube map face constant
  return layer < 34069 ? layer + 34069 : layer;
} // Helper METHODS
// Get a string describing the framebuffer error if installed


function _getFrameBufferStatus(status) {
  // Use error mapping if installed
  const STATUS = Framebuffer.STATUS || {};
  return STATUS[status] || `Framebuffer error ${status}`;
}

export const FRAMEBUFFER_ATTACHMENT_PARAMETERS = [36049, // WebGLRenderbuffer or WebGLTexture
36048, // GL.RENDERBUFFER, GL.TEXTURE, GL.NONE
// GL.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE, // GL.TEXTURE_CUBE_MAP_POSITIVE_X, etc.
// GL.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL, // GLint
// EXT_sRGB or WebGL2
33296, // GL.LINEAR, GL.SRBG
// WebGL2
// GL.FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER, // GLint
33298, // GLint
33299, // GLint
33300, // GLint
33301, // GLint
33302, // GLint
33303 // GLint
// GL.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE
// GL.FLOAT, GL.INT, GL.UNSIGNED_INT, GL.SIGNED_NORMALIZED, OR GL.UNSIGNED_NORMALIZED.
];
Framebuffer.ATTACHMENT_PARAMETERS = FRAMEBUFFER_ATTACHMENT_PARAMETERS;
//# sourceMappingURL=framebuffer.js.map