{"version":3,"sources":["../../../src/core/transform-shader-utils.js"],"names":["assert","combineInjects","getQualifierDetails","typeToChannelSuffix","SAMPLER_UNIFORM_PREFIX","SIZE_UNIFORM_PREFIX","VS_POS_VARIABLE","updateForTextures","vs","sourceTextureMap","targetTextureVarying","targetTexture","texAttributeNames","Object","keys","sourceCount","length","targetTextureType","uniforms","samplerTextureMap","updatedVs","finalInject","vsLines","split","updateVsLines","slice","forEach","line","index","lines","updated","processAttributeDefinition","updatedLine","inject","assign","getVaryingType","sizeName","width","height","uniformDeclaration","posInstructions","join","getAttributeDefinition","getSamplerDeclerations","textureName","samplerName","uniformDeclerations","varying","qualaiferDetails","name","type","textureMap","attributeData","channels","sampleInstruction"],"mappings":"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","sourcesContent":["import assert from 'assert';\nimport {combineInjects, getQualifierDetails, typeToChannelSuffix} from '../shadertools/src';\n\nconst SAMPLER_UNIFORM_PREFIX = 'transform_uSampler_';\nconst SIZE_UNIFORM_PREFIX = 'transform_uSize_';\nconst VS_POS_VARIABLE = 'transform_position';\n\n// Scan provided vertex shader\n// for each texture attribute, inject sampler instructions and build uniforms for size and sampler\n// for texture target, get varying type and inject position instruction\nexport function updateForTextures({vs, sourceTextureMap, targetTextureVarying, targetTexture}) {\n  const texAttributeNames = Object.keys(sourceTextureMap);\n  let sourceCount = texAttributeNames.length;\n  let targetTextureType = null;\n  const uniforms = {};\n  const samplerTextureMap = {};\n  let updatedVs = vs;\n  let finalInject = {};\n\n  if (sourceCount > 0 || targetTextureVarying) {\n    const vsLines = updatedVs.split('\\n');\n    const updateVsLines = vsLines.slice();\n    vsLines.forEach((line, index, lines) => { // TODO add early exit\n      if (sourceCount > 0) {\n        const updated = processAttributeDefinition(line, sourceTextureMap);\n        if (updated) {\n          const {updatedLine, inject} = updated;\n          updateVsLines[index] = updatedLine;\n          // sampleInstructions.push(sampleInstruction);\n          finalInject = combineInjects([finalInject, inject]);\n          Object.assign(uniforms, updated.uniforms);\n          Object.assign(samplerTextureMap, updated.samplerTextureMap);\n          sourceCount--;\n        }\n      }\n      if (targetTextureVarying && !targetTextureType) {\n        targetTextureType = getVaryingType(line, targetTextureVarying);\n      }\n    });\n\n    if (targetTextureVarying) {\n      assert(targetTexture);\n      const sizeName = `${SIZE_UNIFORM_PREFIX}${targetTextureVarying}`;\n      const {width, height} = targetTexture;\n      uniforms[sizeName] = [width, height];\n\n      const uniformDeclaration = `uniform vec2 ${sizeName};\\n`;\n      const posInstructions = `\\\n     vec2 ${VS_POS_VARIABLE} = transform_getPos(${sizeName});\n     gl_Position = vec4(${VS_POS_VARIABLE}, 0, 1.);\\n`;\n      const inject = {\n        'vs:#decl': uniformDeclaration,\n        'vs:#main-start': posInstructions\n      };\n      finalInject = combineInjects([finalInject, inject]);\n    }\n    updatedVs = updateVsLines.join('\\n');\n  }\n  return {\n    // updated vertex shader (commented texture attribute definition)\n    vs: updatedVs,\n    // sampler size unitforms\n    uniforms,\n    // type (float, vec2, vec3 of vec4) target texture varying\n    targetTextureType,\n    // required vertex and fragment shader injects\n    inject: finalInject,\n    // map of sampler name to texture name, can be used to set attributes\n    // usefull when swapping textures, as source and destination texture change when swap is called.\n    samplerTextureMap,\n  };\n}\n\n// Checks if provided line is defining an attribute, if so returns details otherwise null\nfunction getAttributeDefinition(line) {\n  return getQualifierDetails(line, ['attribute', 'in']);\n}\n\nfunction getSamplerDeclerations(textureName) {\n  const samplerName = `${SAMPLER_UNIFORM_PREFIX}${textureName}`;\n  const sizeName = `${SIZE_UNIFORM_PREFIX}${textureName}`;\n  const uniformDeclerations = `\\\n  uniform sampler2D ${samplerName};\n  uniform vec2 ${sizeName};`;\n  return {samplerName, sizeName, uniformDeclerations};\n}\n\n// Return size (float, vec2 etc) of a given varying, null if doens't exist.\nexport function getVaryingType(line, varying) {\n  const qualaiferDetails = getQualifierDetails(line, ['varying', 'out']);\n  if (!qualaiferDetails) {\n    return null;\n  }\n  return qualaiferDetails.name === varying ? qualaiferDetails.type : null;\n}\n\n// build required definitions, sample instructions and uniforms for each texture attribute\nexport function processAttributeDefinition(line, textureMap) {\n  const uniforms = {};\n  const samplerTextureMap = {};\n  const attributeData = getAttributeDefinition(line);\n  if (!attributeData) {\n    return null;\n  }\n  const {type, name} = attributeData;\n  if (name && textureMap[name]) {\n    const updatedLine = `\\// ${line} => Replaced by Transform with a sampler`;\n    const {samplerName, sizeName, uniformDeclerations} = getSamplerDeclerations(name);\n\n    const channels = typeToChannelSuffix(type);\n    const sampleInstruction =\n      `  ${type} ${name} = transform_getInput(${samplerName}, ${sizeName}).${channels};\\n`;\n\n    const {width, height} = textureMap[name];\n    samplerTextureMap[samplerName] = name;\n    uniforms[sizeName] = [width, height];\n    const inject = {\n      'vs:#decl': uniformDeclerations,\n      'vs:#main-start': sampleInstruction\n    };\n\n    // samplerNameMap\n    return {\n      // update vertex shader line.\n      updatedLine,\n      // inject object with sampler instructions.\n      inject,\n      // sampler size uniforms\n      uniforms,\n      // sampler name to texture name map\n      samplerTextureMap\n    };\n  }\n  return null;\n}\n"],"file":"transform-shader-utils.js"}