import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";

/* global window */
import { clear, isWebGL } from '../webgl';
import Group from './group';
import assert from '../utils/assert';

function getDevicePixelRatio() {
  return typeof window !== 'undefined' ? window.devicePixelRatio : 1;
}

export default function pickModels(gl, props) {
  const models = props.models,
        position = props.position,
        _props$uniforms = props.uniforms,
        uniforms = _props$uniforms === void 0 ? {} : _props$uniforms,
        _props$parameters = props.parameters,
        parameters = _props$parameters === void 0 ? {} : _props$parameters,
        settings = props.settings,
        _props$useDevicePixel = props.useDevicePixels,
        useDevicePixels = _props$useDevicePixel === void 0 ? true : _props$useDevicePixel,
        framebuffer = props.framebuffer,
        context = props.context;
  assert(isWebGL(gl) && framebuffer && position);

  const _position = _slicedToArray(position, 2),
        x = _position[0],
        y = _position[1]; // Match our picking framebuffer with the size of the canvas drawing buffer


  framebuffer.resize({
    width: gl.canvas.width,
    height: gl.canvas.height
  }); // Compensate for devicePixelRatio
  // Note: this assumes the canvas framebuffer has been matched

  const dpr = useDevicePixels ? getDevicePixelRatio() : 1; // Reverse the y coordinate

  const deviceX = x * dpr;
  const deviceY = gl.canvas.height - y * dpr; // return withParameters(gl, {
  //   // framebuffer,
  //   // // We are only interested in one pixel, no need to render anything else
  //   // scissorTest: {x: deviceX, y: deviceY, w: 1, h: 1}
  // }, () => {

  const group = new Group({
    children: models
  });
  return group.traverseReverse(model => {
    if (model.pickable) {
      // Clear the frame buffer
      clear(gl, {
        framebuffer,
        color: true,
        depth: true
      }); // Render picking colors

      /* eslint-disable camelcase */

      model.setUniforms({
        picking_uActive: 1
      });
      model.draw(Object.assign({}, props, {
        uniforms,
        parameters,
        settings,
        framebuffer,
        context
      }));
      model.setUniforms({
        picking_uActive: 0
      }); // Sample Read color in the central pixel, to be mapped as a picking color

      const color = framebuffer.readPixels({
        x: deviceX,
        y: deviceY,
        width: 1,
        height: 1,
        format: 6408,
        type: 5121
      });
      const isPicked = color[0] !== 0 || color[1] !== 0 || color[2] !== 0; // Add the information to the stack

      if (isPicked) {
        return {
          model,
          color,
          x,
          y,
          deviceX,
          deviceY
        };
      }
    }

    return null;
  }); // });
}
//# sourceMappingURL=pick-models.js.map