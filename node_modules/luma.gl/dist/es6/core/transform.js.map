{"version":3,"sources":["../../../src/core/transform.js"],"names":["Model","Buffer","Framebuffer","Texture2D","TransformFeedback","_transform","transform","getPassthroughFS","typeToChannelCount","isWebGL2","assertWebGL2Context","getShaderVersion","cloneTextureFrom","assert","log","isObjectEmpty","updateForTextures","SRC_TEX_PARAMETER_OVERRIDES","FS_OUTPUT_VARIABLE","Transform","isSupported","gl","constructor","props","model","elementCount","currentIndex","sourceBuffers","Array","sourceTextures","feedbackBuffers","targetTextures","transformFeedbacks","framebuffers","_createdBuffers","elementIDBuffer","_initialize","Object","seal","delete","name","getBuffer","varyingName","_getTargetTexture","attachments","getData","packed","targetTextureVarying","pixels","readPixels","ArrayType","channelCount","targetTextureType","packedPixels","length","packCount","i","j","_getInputs","samplerUniforms","current","attributes","assign","hasSourceTextures","transform_elementID","sampler","samplerTextureMap","textureName","_setSourceTextureParameters","run","opts","uniforms","parameters","clearRenderTarget","framebuffer","discard","renderingToTexture","viewport","width","height","clear","COLOR_BUFFER_BIT","setAttributes","transformFeedback","swapBuffers","deprecated","swap","feedbackMap","_swapTexture","update","_setElementCount","bufferName","_createFeedbackBuffers","setBuffers","_setupSwapBuffers","_sourceTextures","_targetTexture","targetTexture","_getDestinationTexture","_setupSwapTextures","index","setParameters","_updateElementIDBuffer","setVertexCount","_validateProps","varyings","_targetTextureVarying","varyingsArray","isArray","values","_setupBuffers","_setupTextures","_buildModel","id","drawMode","destinationBuffers","sourceDestinationMap","vs","keys","texture","textureOrAttribute","refTexture","pixelStore","sourceBufferName","feedbackBufferName","sourceBuffer","bytes","type","usage","accessor","buffer","_createNewBuffer","next","srcName","dstName","_getShaders","fs","modules","inject","vertexCount","_setupTransformFeedback","_setupFramebuffers","program","buffers","elementIds","Float32Array","forEach","_","array","data","size","setData","_processVertexShader","version","input","inputType","output","concat","sourceTextureMap"],"mappings":"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","sourcesContent":["import GL from '../constants';\nimport Model from './model';\nimport Buffer from '../webgl/buffer';\nimport Framebuffer from '../webgl/framebuffer';\nimport Texture2D from '../webgl/texture-2d';\nimport TransformFeedback from '../webgl/transform-feedback';\nimport {\n  _transform as transform,\n  getPassthroughFS,\n  typeToChannelCount\n} from '../shadertools/src';\nimport {isWebGL2, assertWebGL2Context, getShaderVersion, cloneTextureFrom} from '../webgl-utils';\nimport assert from '../utils/assert';\nimport {log, isObjectEmpty} from '../utils';\nimport {updateForTextures} from './transform-shader-utils';\n\n// Texture parameters needed so sample can precisely pick pixel for given element id.\nconst SRC_TEX_PARAMETER_OVERRIDES = {\n  [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n};\nconst FS_OUTPUT_VARIABLE = 'transform_output';\n\nexport default class Transform {\n\n  static isSupported(gl) {\n    // For now WebGL2 only\n    return isWebGL2(gl);\n  }\n\n  constructor(gl, props = {}) {\n    assertWebGL2Context(gl);\n\n    this.gl = gl;\n    this.model = null;\n    this.elementCount = 0;\n    this.currentIndex = 0;\n\n    // Source and destination resources are stored in two element Arrays for easier swapping when\n    // 'feedbackMap' is provided. If not only the first array elment is used.\n\n    // Each array element is an object with attribute name as Key and Buffer object as value.\n    this.sourceBuffers = new Array(2);\n\n    // Each array element is an object with attribute name as Key and Texture object as value.\n    this.sourceTextures = new Array(2);\n\n    // Each array element is an object with varying name as Key and Buffer object as value.\n    this.feedbackBuffers = new Array(2);\n\n    // Each array element is a Texture object used as color attachment for framebuffer.\n    this.targetTextures = new Array(2);\n\n    // Each array element is a TransformFeedback object.\n    this.transformFeedbacks = new Array(2);\n\n    // Each array element is a Framebuffer object.\n    this.framebuffers = new Array(2);\n    this._createdBuffers = {};\n    this.elementIDBuffer = null;\n\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  // Delete owned resources.\n  delete() {\n    for (const name in this._createdBuffers) {\n      this._createdBuffers[name].delete();\n    }\n    this.model.delete();\n  }\n\n  // Return Buffer object for given varying name.\n  getBuffer(varyingName = null) {\n    assert(varyingName && this.feedbackBuffers[this.currentIndex][varyingName]);\n    return this.feedbackBuffers[this.currentIndex][varyingName];\n  }\n\n  // Returns the color attachment textuer from current framebuffer target\n  _getTargetTexture() {\n    if (this.framebuffers[this.currentIndex]) {\n      return this.framebuffers[this.currentIndex].attachments[GL.COLOR_ATTACHMENT0];\n    }\n    return null;\n  }\n\n  // Return data either from Buffer or from Texture\n  getData({varyingName = null, packed = false} = {}) {\n    // Either there should be specified feedbackBuffer or we should be rendering to a texture\n    if (varyingName && this.feedbackBuffers[this.currentIndex][varyingName]) {\n      return this.feedbackBuffers[this.currentIndex][varyingName].getData();\n    }\n\n    // When varyingName is not provided return data from framebuffer object.\n    assert(!varyingName || varyingName === this.targetTextureVarying);\n\n    const pixels = this.framebuffers[this.currentIndex].readPixels();\n\n    if (!packed) {\n      return pixels;\n    }\n\n    // readPixels returns 4 elements for each pixel, pack the elements when requested\n    const ArrayType = pixels.constructor;\n    const channelCount = typeToChannelCount(this.targetTextureType);\n    const packedPixels = new ArrayType(pixels.length * channelCount / 4);\n    let packCount = 0;\n    for (let i = 0; i < pixels.length; i += 4) {\n      for (let j = 0; j < channelCount; j++) {\n        packedPixels[packCount++] = pixels[i + j];\n      }\n    }\n    return packedPixels;\n  }\n\n  _getInputs() {\n    const samplerUniforms = {};\n    const current = this.currentIndex;\n\n    // Buffer inputs\n    const attributes = Object.assign({}, this.sourceBuffers[current]);\n\n    // Texture inputs\n    if (this.hasSourceTextures || this.targetTextureVarying) {\n      // TODO: add option not generate position using element id.\n      attributes.transform_elementID = this.elementIDBuffer;\n      for (const sampler in this.samplerTextureMap) {\n        const textureName = this.samplerTextureMap[sampler];\n        samplerUniforms[sampler] = this.sourceTextures[current][textureName];\n      }\n      this._setSourceTextureParameters();\n    }\n    return {attributes, samplerUniforms};\n  }\n\n  // Run one transform feedback loop.\n  run(opts = {}) {\n    const {attributes, samplerUniforms} = this._getInputs();\n    const uniforms = Object.assign({}, samplerUniforms, opts.uniforms);;\n    const parameters = Object.assign({}, opts.parameters);\n    const {clearRenderTarget = true} = opts;\n    let framebuffer = null;\n    let discard = true;\n\n    if (this.renderingToTexture) {\n      discard = false;\n      framebuffer = this.framebuffers[this.currentIndex];\n      assert(framebuffer);\n      parameters.viewport = [0, 0, framebuffer.width, framebuffer.height]\n      if (clearRenderTarget) {\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n      }\n    }\n    this.model.setAttributes(attributes);\n    this.model.transform(Object.assign({}, opts, {\n      transformFeedback: this.transformFeedbacks[this.currentIndex],\n      uniforms,\n      discard,\n      framebuffer,\n      parameters,\n    }));\n  }\n\n  // Swap source and destination buffers and textures.\n  swapBuffers() {\n    log.deprecated('swapBuffers()', 'swap()');\n    this.swap();\n  }\n\n  // Swap source and destination buffers and textures.\n  swap() {\n    assert(this.feedbackMap || this._swapTexture);\n    this.currentIndex = (this.currentIndex + 1) % 2;\n  }\n\n  // Update some or all buffer bindings.\n  update(opts = {}) {\n\n    if (opts.elementCount) {\n        this._setElementCount(opts.elementCount);\n    }\n\n    const {sourceBuffers = null, feedbackBuffers = null} = opts;\n    const {currentIndex} = this;\n    if (sourceBuffers || feedbackBuffers) {\n      for (const bufferName in feedbackBuffers) {\n        assert(feedbackBuffers[bufferName] instanceof Buffer);\n      }\n\n      Object.assign(this.sourceBuffers[currentIndex], sourceBuffers);\n      Object.assign(this.feedbackBuffers[currentIndex], feedbackBuffers);\n      this._createFeedbackBuffers({feedbackBuffers});\n      if (this.transformFeedbacks[currentIndex]) {\n        this.transformFeedbacks[currentIndex].setBuffers(this.feedbackBuffers[currentIndex]);\n      }\n\n      // Buffers have changed, need to re-setup swap buffers.\n      this._setupSwapBuffers();\n    }\n\n    const {_sourceTextures, _targetTexture} = opts;\n    if (_sourceTextures || _targetTexture) {\n      Object.assign(this.sourceTextures[currentIndex], _sourceTextures);\n      const targetTexture = this._getDestinationTexture(_targetTexture);\n      if (targetTexture) {\n        this.targetTextures[currentIndex] =  this._getDestinationTexture(_targetTexture);\n        this.framebuffers[currentIndex].update({\n          [GL.COLOR_ATTACHMENT0]: this.targetTextures[currentIndex]\n        });\n      }\n      // textures have changed, need to re-setup swap textures.\n      this._setupSwapTextures();\n    }\n  }\n\n  // set texture filtering parameters on source textures.\n  _setSourceTextureParameters() {\n    const index = this.currentIndex;\n    for (const name in this.sourceTextures[index]) {\n      this.sourceTextures[index][name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);\n    }\n  }\n\n  // set element count and updated elementID buffer if needed.\n  _setElementCount(elementCount) {\n    if (this.elementCount === elementCount) {\n      return;\n    }\n    if (this.elementCount < elementCount) {\n      this._updateElementIDBuffer(elementCount);\n    }\n    this.model.setVertexCount(elementCount);\n    this.elementCount = elementCount;\n  }\n\n  // Private\n\n  _initialize(props = {}) {\n    const {feedbackBuffers, feedbackMap} = this._validateProps(props);\n    const {sourceBuffers, varyings, _targetTexture, _targetTextureVarying, _swapTexture} = props;\n\n    let varyingsArray = varyings;\n    if (feedbackMap && !Array.isArray(varyings)) {\n      varyingsArray = Object.values(feedbackMap);\n    }\n    this.varyingsArray = varyingsArray;\n    this.feedbackMap = feedbackMap;\n    this._swapTexture = _swapTexture;\n    if (_targetTexture) {\n      this.targetTextureVarying = _targetTextureVarying;\n      this.renderingToTexture = true;\n      assert(this.targetTextureVarying);\n    }\n\n    this._setupBuffers({sourceBuffers, feedbackBuffers});\n    this._setupTextures(props);\n    this._setupSwapBuffers();\n    this._setupSwapTextures();\n    this._buildModel(Object.assign({}, props, {\n      id: props.id || 'transform-model',\n      drawMode: props.drawMode || GL.POINTS,\n      varyings: varyingsArray\n    }));\n  }\n\n  // assert on required parameters\n  /* eslint-disable complexity */\n  _validateProps(props) {\n    let {feedbackBuffers, feedbackMap} = props;\n\n    // backward compitability\n    const {destinationBuffers, sourceDestinationMap} = props;\n    if (destinationBuffers) {\n      log.deprecated('destinationBuffers', 'feedbackBuffers')();\n      feedbackBuffers = feedbackBuffers || destinationBuffers;\n    }\n    if (sourceDestinationMap) {\n      log.deprecated('sourceDestinationMap', 'feedbackMap')();\n      feedbackMap = feedbackMap || sourceDestinationMap;\n    }\n\n    // assert on required parameters\n    const {vs, elementCount, varyings} = props;\n    const {_sourceTextures, _targetTexture, _targetTextureVarying, _swapTexture} = props;\n\n    assert(\n      vs &&\n      // destinations are provided\n      (varyings || feedbackMap || _targetTexture) &&\n      // when only writting to textures auto-duduce from texture dimenstions\n      elementCount\n    );\n\n    for (const bufferName in feedbackBuffers || {}) {\n      assert(feedbackBuffers[bufferName] instanceof Buffer);\n    }\n    for (const textureName in _sourceTextures || {}) {\n      assert(_sourceTextures[textureName] instanceof Texture2D);\n    }\n\n    // If rendering to texture , varying is provided\n    assert (!_targetTexture || _targetTextureVarying);\n\n    // swap texture must be a valid source texture\n    assert(!_swapTexture || _sourceTextures[_swapTexture]);\n\n    return {feedbackBuffers, feedbackMap};\n  }\n  /* eslint-enable complexity */\n\n  // setup source and destination buffers\n  _setupBuffers({sourceBuffers = null, feedbackBuffers = null}) {\n    this.sourceBuffers[0] = Object.assign({}, sourceBuffers);\n    this.feedbackBuffers[0] = Object.assign({}, feedbackBuffers);\n    this._createFeedbackBuffers({feedbackBuffers});\n    this.sourceBuffers[1] = {};\n    this.feedbackBuffers[1] = {};\n  }\n\n  // setup source and destination textures\n  _setupTextures(props = {}) {\n    const {_sourceTextures, _targetTexture} = props;\n    // Setup source texture\n    this.sourceTextures[0] = Object.assign({}, _sourceTextures);\n    this.sourceTextures[1] = {};\n    this.hasSourceTextures = Object.keys(this.sourceTextures[0]).length > 0;\n\n    if (this.targetTextureVarying) {\n      const texture = this._getDestinationTexture(_targetTexture);\n      // Either a texture or refAttribute must be provided\n      assert(texture);\n      this.targetTextures[0] = texture;\n      this.targetTextures[1] = null;\n    }\n  }\n\n  _getDestinationTexture(textureOrAttribute) {\n\n    if (textureOrAttribute instanceof Texture2D) {\n      return textureOrAttribute;\n    }\n    const refTexture = this.sourceTextures[0][textureOrAttribute];\n    if (!refTexture) {\n      return null;\n    }\n    return cloneTextureFrom(refTexture, {\n      parameters: {\n        [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n        [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n      },\n      pixelStore: {\n        [GL.UNPACK_FLIP_Y_WEBGL]: false\n      }\n    });\n  }\n\n  // auto create any feedback buffers\n  _createFeedbackBuffers({feedbackBuffers}) {\n    if (!this.feedbackMap) {\n      // feedbackMap required to auto create buffers.\n      return;\n    }\n    const current = this.currentIndex;\n    for (const sourceBufferName in this.feedbackMap) {\n      const feedbackBufferName = this.feedbackMap[sourceBufferName];\n      if (feedbackBufferName !== this.targetTextureVarying &&\n          (!feedbackBuffers || !feedbackBuffers[feedbackBufferName])\n      ) {\n        // Create new buffer with same layout and settings as source buffer\n        const sourceBuffer = this.sourceBuffers[current][sourceBufferName];\n        const {bytes, type, usage, accessor} = sourceBuffer;\n        const buffer = new Buffer(this.gl, {bytes, type, usage, accessor});\n\n        if (this._createdBuffers[feedbackBufferName]) {\n          this._createdBuffers[feedbackBufferName].delete();\n        }\n        this._createdBuffers[feedbackBufferName] = buffer;\n        this.feedbackBuffers[current][feedbackBufferName] = buffer;\n      }\n    }\n  }\n\n  // Create a buffer and add to list of buffers to be deleted.\n  _createNewBuffer(name, opts) {\n    const buffer = new Buffer(this.gl, opts);\n    if (this._createdBuffers[name]) {\n      this._createdBuffers[name].delete();\n      this._createdBuffers[name] = buffer;\n    }\n    return buffer;\n  }\n\n  // setup buffers for swapping.\n  // Second set of source and feedback objects are setup to point\n  // to corresponding feedback and source buffers.\n  _setupSwapBuffers() {\n    if (!this.feedbackMap) {\n      // feedbackMap required set up swap buffers.\n      return;\n    }\n    const current = this.currentIndex;\n    const next = (current + 1) % 2;\n\n    // Copy all buffers/textures so un-mapped sources will remain same\n    Object.assign(this.sourceBuffers[next], this.sourceBuffers[current]);\n    Object.assign(this.feedbackBuffers[next], this.feedbackBuffers[current]);\n\n    for (const srcName in this.feedbackMap) {\n      const dstName = this.feedbackMap[srcName];\n      // TODO: add textureMap and remove this if loop\n      if (dstName !== this.targetTextureVarying) {\n        this.sourceBuffers[next][srcName] =\n          this.feedbackBuffers[current][dstName];\n        this.feedbackBuffers[next][dstName] =\n          this.sourceBuffers[current][srcName];\n\n        // make sure the new destination buffer is a Buffer object\n        assert(this.feedbackBuffers[next][dstName] instanceof Buffer);\n      }\n    }\n\n    // When triggered by `update()` TranformFeedback objects are already set up,\n    // if so update buffers\n    if (this.transformFeedbacks[next]) {\n      this.transformFeedbacks[next].setBuffers(this.feedbackBuffers[next]);\n    }\n\n    // TODO: add swap support for targetTexture and framebuffers\n  }\n\n\n  // setup textures for swapping.\n  _setupSwapTextures() {\n    if (!this._swapTexture || !this.targetTextureVarying) {\n      // Must be rendering to a texture and _swapTexture is provided\n      return;\n    }\n    const current = this.currentIndex;\n    const next = (current + 1) % 2;\n\n    Object.assign(this.sourceTextures[next], this.sourceTextures[current]);\n\n    this.sourceTextures[next][this._swapTexture] = this.targetTextures[current];\n    this.targetTextures[next] = this.sourceTextures[current][this._swapTexture];\n\n    // When triggered by `update()` Framebuffer objects are already set up,\n    // if so update buffers\n    if (this.framebuffers[next]) {\n      this.framebuffers[next].update({\n        [GL.COLOR_ATTACHMENT0]: this.targetTextures[next]\n      });\n    }\n\n  }\n\n  // build Model and TransformFeedback objects\n  _buildModel(props = {}) {\n\n    const {vs, fs, modules, uniforms, inject, samplerTextureMap} = this._getShaders(props);\n    this.model = new Model(this.gl, Object.assign({}, props, {\n      vs,\n      fs,\n      vertexCount: props.elementCount,\n      modules,\n      uniforms,\n      inject\n    }));\n    this.samplerTextureMap = samplerTextureMap;\n\n    // setup TF to capture varyings.\n    this._setupTransformFeedback();\n\n    // setup Framebuffer object for rendering to Texture.\n    this._setupFramebuffers();\n\n    // create buffer to access source texture pixesl.\n    this._setElementCount(props.elementCount);\n\n  }\n\n  // setup TransformFeedback objects to capture the results\n  _setupTransformFeedback() {\n    if (isObjectEmpty(this.feedbackBuffers[0])) {\n      return;\n    }\n    this.transformFeedbacks[0] = new TransformFeedback(this.gl, {\n      program: this.model.program,\n      buffers: this.feedbackBuffers[0]\n    });\n\n    // If buffers are swappable setup second transform feedback object.\n    if (this.feedbackMap) {\n      this.transformFeedbacks[1] = new TransformFeedback(this.gl, {\n        program: this.model.program,\n        buffers: this.feedbackBuffers[1]\n      });\n    }\n  }\n\n  // setup framebuffers with texture attachments, to which results are rendered\n  _setupFramebuffers() {\n    if (!this.renderingToTexture) {\n      return;\n    }\n\n    let {width, height} = this.targetTextures[0];\n    this.framebuffers[0] = new Framebuffer(this.gl, {\n      id: `${this.id || 'transform'}-framebuffer-0`,\n      width,\n      height,\n      attachments: {\n        [GL.COLOR_ATTACHMENT0]: this.targetTextures[0]\n      }\n    });\n\n    if (this._swapTexture) {\n      ({width, height} = this.targetTextures[1]);\n\n      this.framebuffers[1] = new Framebuffer(this.gl, {\n        id: `${this.id || 'transform'}-framebuffer-1`,\n        width,\n        height,\n        attachments: {\n          [GL.COLOR_ATTACHMENT0]: this.targetTextures[1]\n        }\n      });\n    }\n  }\n\n  // create/update buffer to access source texture's individual pixels.\n  _updateElementIDBuffer(elementCount) {\n    if (!this.hasSourceTextures && !this.targetTextureVarying) {\n      return;\n    }\n    // NOTE: using float so this will work with GLSL 1.0 shaders.\n    const elementIds = new Float32Array(elementCount);\n    elementIds.forEach((_, index, array) => {\n      array[index] = index;\n    });\n    if (!this.elementIDBuffer) {\n      this.elementIDBuffer = new Buffer(this.gl, {data: elementIds, size: 1});\n    } else {\n      this.elementIDBuffer.setData({data: elementIds});\n    }\n  }\n\n  // build and return shader releated parameters\n  _getShaders(props = {}) {\n    const {vs, uniforms, targetTextureType, inject, samplerTextureMap} = this._processVertexShader(props.vs);\n    this.targetTextureType = targetTextureType;\n    const fs = getPassthroughFS({\n      version: getShaderVersion(vs),\n      input: this.targetTextureVarying,\n      inputType: targetTextureType,\n      output: FS_OUTPUT_VARIABLE\n    });\n    const modules = this.hasSourceTextures || this.targetTextureVarying ?\n      [transform].concat(props.modules || []) : props.modules;\n    return {vs, fs, modules, uniforms, inject, samplerTextureMap};\n  }\n\n  // scan and update vertex shader for texture atrributes.\n  _processVertexShader(vs) {\n    return updateForTextures({\n      vs,\n      sourceTextureMap: this.sourceTextures[this.currentIndex],\n      targetTextureVarying: this.targetTextureVarying,\n      targetTexture: this.targetTextures[this.currentIndex]\n    });\n  }\n}\n"],"file":"transform.js"}