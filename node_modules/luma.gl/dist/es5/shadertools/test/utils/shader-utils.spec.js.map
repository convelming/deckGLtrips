{"version":3,"sources":["../../../../../src/shadertools/test/utils/shader-utils.spec.js"],"names":["t","QUALIFIER_TEST_CASES","line","qualifiers","expected","qualifier","type","name","qualifers","forEach","testCase","result","deepEqual","end","PASSTHROUGH_TEST_CASES","version","input","inputType","output","equal"],"mappings":";;;;AAAA;;AAOA;;AAEA,wBAAK,kCAAL,EAAyC,UAAAA,CAAC,EAAI;AAC5C,MAAMC,oBAAoB,GAAG,CAC3B;AACEC,IAAAA,IAAI,EAAE,oBADR;AAEEC,IAAAA,UAAU,EAAE,SAFd;AAGEC,IAAAA,QAAQ,EAAE;AACRC,MAAAA,SAAS,EAAE,SADH;AAERC,MAAAA,IAAI,EAAE,MAFE;AAGRC,MAAAA,IAAI,EAAE;AAHE;AAHZ,GAD2B,EAU3B;AACEL,IAAAA,IAAI,EAAE,uBADR;AAEEC,IAAAA,UAAU,EAAE,CAAC,IAAD,CAFd;AAGEC,IAAAA,QAAQ,EAAE;AAHZ,GAV2B,EAe3B;AACEF,IAAAA,IAAI,EAAE,uBADR;AAEEC,IAAAA,UAAU,EAAE,CAAC,WAAD,EAAc,IAAd,CAFd;AAGEC,IAAAA,QAAQ,EAAE;AACRC,MAAAA,SAAS,EAAE,WADH;AAERC,MAAAA,IAAI,EAAE,MAFE;AAGRC,MAAAA,IAAI,EAAE;AAHE;AAHZ,GAf2B,EAwB3B;AACEL,IAAAA,IAAI,EAAE,4CADR;AAEEM,IAAAA,SAAS,EAAE,CAAC,WAAD,EAAc,IAAd,CAFb;AAGEJ,IAAAA,QAAQ,EAAE;AAHZ,GAxB2B,CAA7B;AA+BAH,EAAAA,oBAAoB,CAACQ,OAArB,CAA6B,UAAAC,QAAQ,EAAI;AAAA,QAChCR,IADgC,GACFQ,QADE,CAChCR,IADgC;AAAA,QAC1BC,UAD0B,GACFO,QADE,CAC1BP,UAD0B;AAAA,QACdC,QADc,GACFM,QADE,CACdN,QADc;AAEvC,QAAMO,MAAM,GAAG,sCAAoBT,IAApB,EAA0BC,UAA1B,CAAf;AACAH,IAAAA,CAAC,CAACY,SAAF,CAAYD,MAAZ,EAAoBP,QAApB,qEAC8DF,IAD9D;AAED,GALD;AAMAF,EAAAA,CAAC,CAACa,GAAF;AACD,CAvCD;AAyCA,wBAAK,+BAAL,EAAsC,UAAAb,CAAC,EAAI;AACzC,MAAMc,sBAAsB,GAAG,CAC7B;AACEC,IAAAA,OAAO,EAAE,GADX;AAEEC,IAAAA,KAAK,EAAE,SAFT;AAGEC,IAAAA,SAAS,EAAE,MAHb;AAIEb,IAAAA,QAAQ;AAJV,GAD6B,EAW7B;AACEW,IAAAA,OAAO,EAAE,GADX;AAEEC,IAAAA,KAAK,EAAE,SAFT;AAGEC,IAAAA,SAAS,EAAE,OAHb;AAIEC,IAAAA,MAAM,EAAE,UAJV;AAKEd,IAAAA,QAAQ;AALV,GAX6B,CAA/B;AA0BAU,EAAAA,sBAAsB,CAACL,OAAvB,CAA+B,UAAAC,QAAQ,EAAI;AAAA,QAClCK,OADkC,GACaL,QADb,CAClCK,OADkC;AAAA,QACzBC,KADyB,GACaN,QADb,CACzBM,KADyB;AAAA,QAClBC,SADkB,GACaP,QADb,CAClBO,SADkB;AAAA,QACPC,MADO,GACaR,QADb,CACPQ,MADO;AAAA,QACCd,QADD,GACaM,QADb,CACCN,QADD;AAEzC,QAAMO,MAAM,GAAG,mCAAiB;AAACI,MAAAA,OAAO,EAAPA,OAAD;AAAUC,MAAAA,KAAK,EAALA,KAAV;AAAiBC,MAAAA,SAAS,EAATA,SAAjB;AAA4BC,MAAAA,MAAM,EAANA;AAA5B,KAAjB,CAAf;AACAlB,IAAAA,CAAC,CAACmB,KAAF,CAAQR,MAAR,EAAgBP,QAAhB,yDACkDW,OADlD,mBACkEE,SADlE;AAED,GALD;AAMAjB,EAAAA,CAAC,CAACa,GAAF;AACD,CAlCD;AAoCA,wBAAK,kCAAL,EAAyC,UAAAb,CAAC,EAAI;AAC5CA,EAAAA,CAAC,CAACmB,KAAF,CAAQ,sCAAoB,OAApB,CAAR,EAAsC,GAAtC,EAA2C,+CAA3C;AACAnB,EAAAA,CAAC,CAACmB,KAAF,CAAQ,sCAAoB,MAApB,CAAR,EAAqC,IAArC,EAA2C,+CAA3C;AACAnB,EAAAA,CAAC,CAACmB,KAAF,CAAQ,sCAAoB,MAApB,CAAR,EAAqC,KAArC,EAA4C,gDAA5C;AACAnB,EAAAA,CAAC,CAACmB,KAAF,CAAQ,sCAAoB,MAApB,CAAR,EAAqC,MAArC,EAA6C,iDAA7C;AACAnB,EAAAA,CAAC,CAACa,GAAF;AACD,CAND;AAQA,wBAAK,iCAAL,EAAwC,UAAAb,CAAC,EAAI;AAC3CA,EAAAA,CAAC,CAACmB,KAAF,CAAQ,qCAAmB,OAAnB,CAAR,EAAqC,CAArC,EAAwC,8CAAxC;AACAnB,EAAAA,CAAC,CAACmB,KAAF,CAAQ,qCAAmB,MAAnB,CAAR,EAAoC,CAApC,EAAuC,6CAAvC;AACAnB,EAAAA,CAAC,CAACmB,KAAF,CAAQ,qCAAmB,MAAnB,CAAR,EAAoC,CAApC,EAAuC,6CAAvC;AACAnB,EAAAA,CAAC,CAACmB,KAAF,CAAQ,qCAAmB,MAAnB,CAAR,EAAoC,CAApC,EAAuC,6CAAvC;AACAnB,EAAAA,CAAC,CAACa,GAAF;AACD,CAND;AAQA,wBAAK,4BAAL,EAAmC,UAAAb,CAAC,EAAI;AACtCA,EAAAA,CAAC,CAACmB,KAAF,CAAQ,gCAAc,KAAd,EAAqB,OAArB,CAAR,EAAuC,0BAAvC,EACE,mDADF;AAEAnB,EAAAA,CAAC,CAACmB,KAAF,CAAQ,gCAAc,KAAd,EAAqB,MAArB,CAAR,EAAsC,qBAAtC,EACE,kDADF;AAEAnB,EAAAA,CAAC,CAACmB,KAAF,CAAQ,gCAAc,KAAd,EAAqB,MAArB,CAAR,EAAsC,gBAAtC,EACE,kDADF;AAEAnB,EAAAA,CAAC,CAACmB,KAAF,CAAQ,gCAAc,KAAd,EAAqB,MAArB,CAAR,EAAsC,KAAtC,EAA6C,kDAA7C;AACAnB,EAAAA,CAAC,CAACa,GAAF;AACD,CATD","sourcesContent":["import {\n  getQualifierDetails,\n  getPassthroughFS,\n  typeToChannelSuffix,\n  typeToChannelCount,\n  convertToVec4\n} from '../../src/utils/shader-utils';\nimport test from 'tape-catch';\n\ntest('shader-utils#getQualifierDetails', t => {\n  const QUALIFIER_TEST_CASES = [\n    {\n      line: 'uniform vec2 size;',\n      qualifiers: 'uniform',\n      expected: {\n        qualifier: 'uniform',\n        type: 'vec2',\n        name: 'size'\n      }\n    },\n    {\n      line: 'attribute vec4 input;',\n      qualifiers: ['in'],\n      expected: null\n    },\n    {\n      line: 'attribute vec4 input;',\n      qualifiers: ['attribute', 'in'],\n      expected: {\n        qualifier: 'attribute',\n        type: 'vec4',\n        name: 'input'\n      }\n    },\n    {\n      line: 'vec4 pos = vec3(in, 1.0); // some comments',\n      qualifers: ['attribute', 'in'],\n      expected: null\n    }\n  ];\n\n  QUALIFIER_TEST_CASES.forEach(testCase => {\n    const {line, qualifiers, expected} = testCase;\n    const result = getQualifierDetails(line, qualifiers);\n    t.deepEqual(result, expected,\n      `getQualifierDetails should return valid values when line=${line}`);\n  });\n  t.end();\n});\n\ntest('shader-utils#getPassthroughFS', t => {\n  const PASSTHROUGH_TEST_CASES = [\n    {\n      version: 100,\n      input: 'myInput',\n      inputType: 'vec2',\n      expected: `\\\nvarying vec2 myInput;\nvoid main() {\n  gl_FragColor = vec4(myInput, 0.0, 1.0);\n}`\n    },\n    {\n      version: 300,\n      input: 'myInput',\n      inputType: 'float',\n      output: 'myOutput',\n      expected: `\\\n#version 300 es\nin float myInput;\nout vec4 myOutput;\nvoid main() {\n  myOutput = vec4(myInput, 0.0, 0.0, 1.0);\n}`\n    }\n  ];\n\n  PASSTHROUGH_TEST_CASES.forEach(testCase => {\n    const {version, input, inputType, output, expected} = testCase;\n    const result = getPassthroughFS({version, input, inputType, output});\n    t.equal(result, expected,\n      `Passthrough shader should match when version=${version} type=${inputType}`);\n  });\n  t.end();\n});\n\ntest('shader-utils#typeToChannelSuffix', t => {\n  t.equal(typeToChannelSuffix('float'), 'x', 'typeToChannelSuffix should return x for float');\n  t.equal(typeToChannelSuffix('vec2'), 'xy', 'typeToChannelSuffix should return xy for vec2');\n  t.equal(typeToChannelSuffix('vec3'), 'xyz', 'typeToChannelSuffix should return xyz for vec3');\n  t.equal(typeToChannelSuffix('vec4'), 'xyzw', 'typeToChannelSuffix should return xyzw for vec4');\n  t.end();\n});\n\ntest('shader-utils#typeToChannelCount', t => {\n  t.equal(typeToChannelCount('float'), 1, 'typeToChannelCount should return 1 for float');\n  t.equal(typeToChannelCount('vec2'), 2, 'typeToChannelCount should return 2 for vec2');\n  t.equal(typeToChannelCount('vec3'), 3, 'typeToChannelCount should return 3 for vec3');\n  t.equal(typeToChannelCount('vec4'), 4, 'typeToChannelCount should return 4 for vec4');\n  t.end();\n});\n\ntest('shader-utils#convertToVec4', t => {\n  t.equal(convertToVec4('one', 'float'), 'vec4(one, 0.0, 0.0, 1.0)',\n    'convertToVec4 should return right value for float');\n  t.equal(convertToVec4('one', 'vec2'), 'vec4(one, 0.0, 1.0)',\n    'convertToVec4 should return right value for vec2');\n  t.equal(convertToVec4('one', 'vec3'), 'vec4(one, 1.0)',\n    'convertToVec4 should return right value for vec3');\n  t.equal(convertToVec4('one', 'vec4'), 'one', 'convertToVec4 should return right value for vec4');\n  t.end();\n});\n"],"file":"shader-utils.spec.js"}