"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _shaderUtils = require("../../src/utils/shader-utils");

var _tapeCatch = _interopRequireDefault(require("tape-catch"));

(0, _tapeCatch.default)('shader-utils#getQualifierDetails', function (t) {
  var QUALIFIER_TEST_CASES = [{
    line: 'uniform vec2 size;',
    qualifiers: 'uniform',
    expected: {
      qualifier: 'uniform',
      type: 'vec2',
      name: 'size'
    }
  }, {
    line: 'attribute vec4 input;',
    qualifiers: ['in'],
    expected: null
  }, {
    line: 'attribute vec4 input;',
    qualifiers: ['attribute', 'in'],
    expected: {
      qualifier: 'attribute',
      type: 'vec4',
      name: 'input'
    }
  }, {
    line: 'vec4 pos = vec3(in, 1.0); // some comments',
    qualifers: ['attribute', 'in'],
    expected: null
  }];
  QUALIFIER_TEST_CASES.forEach(function (testCase) {
    var line = testCase.line,
        qualifiers = testCase.qualifiers,
        expected = testCase.expected;
    var result = (0, _shaderUtils.getQualifierDetails)(line, qualifiers);
    t.deepEqual(result, expected, "getQualifierDetails should return valid values when line=".concat(line));
  });
  t.end();
});
(0, _tapeCatch.default)('shader-utils#getPassthroughFS', function (t) {
  var PASSTHROUGH_TEST_CASES = [{
    version: 100,
    input: 'myInput',
    inputType: 'vec2',
    expected: "varying vec2 myInput;\nvoid main() {\n  gl_FragColor = vec4(myInput, 0.0, 1.0);\n}"
  }, {
    version: 300,
    input: 'myInput',
    inputType: 'float',
    output: 'myOutput',
    expected: "#version 300 es\nin float myInput;\nout vec4 myOutput;\nvoid main() {\n  myOutput = vec4(myInput, 0.0, 0.0, 1.0);\n}"
  }];
  PASSTHROUGH_TEST_CASES.forEach(function (testCase) {
    var version = testCase.version,
        input = testCase.input,
        inputType = testCase.inputType,
        output = testCase.output,
        expected = testCase.expected;
    var result = (0, _shaderUtils.getPassthroughFS)({
      version: version,
      input: input,
      inputType: inputType,
      output: output
    });
    t.equal(result, expected, "Passthrough shader should match when version=".concat(version, " type=").concat(inputType));
  });
  t.end();
});
(0, _tapeCatch.default)('shader-utils#typeToChannelSuffix', function (t) {
  t.equal((0, _shaderUtils.typeToChannelSuffix)('float'), 'x', 'typeToChannelSuffix should return x for float');
  t.equal((0, _shaderUtils.typeToChannelSuffix)('vec2'), 'xy', 'typeToChannelSuffix should return xy for vec2');
  t.equal((0, _shaderUtils.typeToChannelSuffix)('vec3'), 'xyz', 'typeToChannelSuffix should return xyz for vec3');
  t.equal((0, _shaderUtils.typeToChannelSuffix)('vec4'), 'xyzw', 'typeToChannelSuffix should return xyzw for vec4');
  t.end();
});
(0, _tapeCatch.default)('shader-utils#typeToChannelCount', function (t) {
  t.equal((0, _shaderUtils.typeToChannelCount)('float'), 1, 'typeToChannelCount should return 1 for float');
  t.equal((0, _shaderUtils.typeToChannelCount)('vec2'), 2, 'typeToChannelCount should return 2 for vec2');
  t.equal((0, _shaderUtils.typeToChannelCount)('vec3'), 3, 'typeToChannelCount should return 3 for vec3');
  t.equal((0, _shaderUtils.typeToChannelCount)('vec4'), 4, 'typeToChannelCount should return 4 for vec4');
  t.end();
});
(0, _tapeCatch.default)('shader-utils#convertToVec4', function (t) {
  t.equal((0, _shaderUtils.convertToVec4)('one', 'float'), 'vec4(one, 0.0, 0.0, 1.0)', 'convertToVec4 should return right value for float');
  t.equal((0, _shaderUtils.convertToVec4)('one', 'vec2'), 'vec4(one, 0.0, 1.0)', 'convertToVec4 should return right value for vec2');
  t.equal((0, _shaderUtils.convertToVec4)('one', 'vec3'), 'vec4(one, 1.0)', 'convertToVec4 should return right value for vec3');
  t.equal((0, _shaderUtils.convertToVec4)('one', 'vec4'), 'one', 'convertToVec4 should return right value for vec4');
  t.end();
});
//# sourceMappingURL=shader-utils.spec.js.map