"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _transpileShader = _interopRequireDefault(require("luma.gl/shadertools/src/lib/transpile-shader"));

var _tapeCatch = _interopRequireDefault(require("tape-catch"));

/* eslint-disable camelcase */
// 300 version should use 'textureCube()'' instead of 'texture()'
var VS_GLSL_300 = "#version 300 es\n\nin vec4 positions;\nuniform sampler2D sampler;\nuniform samplerCube sCube;\nout vec4 vColor;\n\nvoid f(out float a, in float b) {}\n\nvoid main(void) {\n  gl_Position = positions;\n  vec4 texColor = texture(sampler, texCoord);\n  vec4 texCubeColor = textureCube(sCube, cubeCoord);\n  vColor = vec4(1., 0., 0., 1.);\n}\n"; // transpiled 300 version should have correct `texure()` syntax

var VS_GLSL_300_transpiled = "#version 300 es\n\nin vec4 positions;\nuniform sampler2D sampler;\nuniform samplerCube sCube;\nout vec4 vColor;\n\nvoid f(out float a, in float b) {}\n\nvoid main(void) {\n  gl_Position = positions;\n  vec4 texColor = texture(sampler, texCoord);\n  vec4 texCubeColor = texture(sCube, cubeCoord);\n  vColor = vec4(1., 0., 0., 1.);\n}\n";
var VS_GLSL_100 = "#version 300 es\n\nattribute vec4 positions;\nuniform sampler2D sampler;\nuniform samplerCube sCube;\nvarying vec4 vColor;\n\nvoid f(out float a, in float b) {}\n\nvoid main(void) {\n  gl_Position = positions;\n  vec4 texColor = texture2D(sampler, texCoord);\n  vec4 texCubeColor = textureCube(sCube, cubeCoord);\n  vColor = vec4(1., 0., 0., 1.);\n}\n"; // 300 version should use 'textureCube()'' instead of 'texture()'

var FS_GLSL_300 = "#version 300 es\n\nprecision highp float;\n\nout vec4 fragmentColor;\nuniform sampler2D sampler;\nuniform samplerCube sCube;\nin vec4 vColor;\n\nvoid f(out float a, in float b) {}\n\nvoid main(void) {\n  vec4 texColor = texture(sampler, texCoord);\n  vec4 texCubeColor = textureCube(sCube, cubeCoord);\n  fragmentColor = vColor;\n}\n"; // transpiled 300 version should have correct `texure()` syntax

var FS_GLSL_300_transpiled = "#version 300 es\n\nprecision highp float;\n\nout vec4 fragmentColor;\nuniform sampler2D sampler;\nuniform samplerCube sCube;\nin vec4 vColor;\n\nvoid f(out float a, in float b) {}\n\nvoid main(void) {\n  vec4 texColor = texture(sampler, texCoord);\n  vec4 texCubeColor = texture(sCube, cubeCoord);\n  fragmentColor = vColor;\n}\n";
var FS_GLSL_100 = "#version 300 es\n\nprecision highp float;\n\nout vec4 fragmentColor;\nuniform sampler2D sampler;\nuniform samplerCube sCube;\nvarying vec4 vColor;\n\nvoid f(out float a, in float b) {}\n\nvoid main(void) {\n  vec4 texColor = texture2D(sampler, texCoord);\n  vec4 texCubeColor = textureCube(sCube, cubeCoord);\n  fragmentColor = vColor;\n}\n";
/*
const VS_GLSL_300 = `\
#version 300 es

in vec4 positions;
uniform sampler2D sampler;
uniform samplerCube sCube;
out vec4 vColor;

void f(out float a, in float b) {}

void main(void) {
  gl_Position = positions;
  vec4 texColor = texture(sampler, texCoord);
  vec4 texCubeColor = textureCube(sCube, cubeCoord);
  vColor = vec4(1., 0., 0., 1.);
}
`;

// 300 version should also be writtend with 'textureCube()'' instead of 'texture()'
const VS_GLSL_300_textureCube = `\
#version 300 es

in vec4 positions;
uniform samplerCube sCube;
out vec4 vColor;

void main(void) {
  gl_Position = positions;
  vec4 texCubeColor = textureCube(sCube, cubeCoord);
  vColor = vec4(1., 0., 0., 1.);
}
`;

// transpiled version should have correct `texture(` syntax
const VS_GLSL_300_textureCube_transpiled = `\
#version 300 es

in vec4 positions;
uniform samplerCube sCube;
out vec4 vColor;

void main(void) {
  gl_Position = positions;
  vec4 texCubeColor = texture(sCube, cubeCoord);
  vColor = vec4(1., 0., 0., 1.);
}
`;

const VS_GLSL_100_textureCube = `\
#version 300 es

attribute vec4 positions;
uniform samplerCube sCube;
varying vec4 vColor;

void main(void) {
  gl_Position = positions;
  vec4 texCubeColor = textureCube(sCube, cubeCoord);
  vColor = vec4(1., 0., 0., 1.);
}
`;

const FS_GLSL_300 = `\
#version 300 es

precision highp float;

out vec4 fragmentColor;
uniform sampler2D sampler;
uniform samplerCube sCube;
in vec4 vColor;

void f(out float a, in float b) {}

void main(void) {
  vec4 texColor = texture(sampler, texCoord);
  vec4 texCubeColor = textureCube(sCube, cubeCoord);
  fragmentColor = vColor;
}
`;

const FS_GLSL_100 = `\
#version 300 es

precision highp float;

out vec4 fragmentColor;
uniform sampler2D sampler;
uniform samplerCube sCube;
varying vec4 vColor;

void f(out float a, in float b) {}

void main(void) {
  vec4 texColor = texture2D(sampler, texCoord);
  vec4 texCubeColor = textureCube(sCube, cubeCoord);
  fragmentColor = vColor;
}
`;

const VS_GLSL_300 = `\
#version 300 es

in vec4 positions;
uniform sampler2D sampler;
uniform samplerCube sCube;
out vec4 vColor;

void f(out float a, in float b) {}

void main(void) {
  gl_Position = positions;
  vec4 texColor = texture(sampler, texCoord);
  vec4 texCubeColor = textureCube(sCube, cubeCoord);
  vColor = vec4(1., 0., 0., 1.);
}
`;
*/

(0, _tapeCatch.default)('transpileShader#import', function (t) {
  t.ok(_transpileShader.default !== undefined, 'transpileShader import successful');
  t.end();
});
(0, _tapeCatch.default)('transpileShader#versions', function (t) {
  var assembleResult;
  assembleResult = (0, _transpileShader.default)(VS_GLSL_300, 100, true);
  t.equal(assembleResult, VS_GLSL_100, 'correctly transpiled');
  assembleResult = (0, _transpileShader.default)(FS_GLSL_300, 100, false);
  t.equal(assembleResult, FS_GLSL_100, 'correctly transpiled');
  assembleResult = (0, _transpileShader.default)(VS_GLSL_100, 300, true);
  t.equal(assembleResult, VS_GLSL_300_transpiled, 'correctly transpiled');
  assembleResult = (0, _transpileShader.default)(FS_GLSL_100, 300, false);
  t.equal(assembleResult, FS_GLSL_300_transpiled, 'correctly transpiled'); // test 300 to 300 transpilation, textureCube() should be replaced with texture()

  assembleResult = (0, _transpileShader.default)(VS_GLSL_300, 300, true);
  t.equal(assembleResult, VS_GLSL_300_transpiled, 'correctly transpiled');
  assembleResult = (0, _transpileShader.default)(FS_GLSL_300, 300, false);
  t.equal(assembleResult, FS_GLSL_300_transpiled, 'correctly transpiled');
  t.end();
});
//# sourceMappingURL=transpile-shader.spec.js.map