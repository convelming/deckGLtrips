"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _injectShader = _interopRequireWildcard(require("luma.gl/shadertools/src/lib/inject-shader"));

var _luma = require("luma.gl");

var _tapeCatch = _interopRequireDefault(require("tape-catch"));

/* eslint-disable camelcase */
var fixture = {
  gl: (0, _luma.createGLContext)()
};
var VS_GLSL_TEMPLATE = "#version 300 es\n\nin vec4 positions;\nout vec4 vColor;\n\nvoid f(out float a, in float b) {}\n\nvoid main(void) {\n  gl_Position = positions;\n  vColor = vec4(1., 0., 0., 1.);\n}\n";
var VS_GLSL_RESOLVED = "#version 300 es\nuniform float uNewUniform;\n\nin vec4 positions;\nout vec4 vColor;\n\nvoid f(out float a, in float b) {}\n\nvoid main(void) {\n  gl_Position = positions;\n  vColor = vec4(1., 0., 0., 1.);\n}\n";
var FS_GLSL_TEMPLATE = "#version 300 es\n\nprecision highp float;\n\nout vec4 fragmentColor;\nin vec4 vColor;\n\nvoid f(out float a, in float b) {}\n\nvoid main(void) {\n  fragmentColor = vColor;\n}\n";
var FS_GLSL_RESOLVED = "#version 300 es\nuniform bool uDiscard;\n\nprecision highp float;\n\nout vec4 fragmentColor;\nin vec4 vColor;\n\nvoid f(out float a, in float b) {}\n\nvoid main(void) {\n  if (uDiscard} { discard } else {\n  fragmentColor = vColor;\n  }\n}\n";
var INJECT = {
  'vs:#decl': 'uniform float uNewUniform;\n',
  'fs:#decl': 'uniform bool uDiscard;\n',
  'fs:#main-start': '  if (uDiscard} { discard } else {\n',
  'fs:#main-end': '  }\n'
};
var INJECT2 = {
  'vs:#decl': 'uniform float uNewUniform2;\n',
  'fs:#main-start': '  uNewUniform2 = uNewUniform + 1.;\n',
  'vs:#main-start': ' uNewUniform = uNewUniform2;\n'
};
var COMBINED_INJECT = {
  'vs:#decl': 'uniform float uNewUniform;\n\nuniform float uNewUniform2;\n',
  'fs:#decl': 'uniform bool uDiscard;\n',
  'fs:#main-start': '  if (uDiscard} { discard } else {\n\n  uNewUniform2 = uNewUniform + 1.;\n',
  'fs:#main-end': '  }\n',
  'vs:#main-start': ' uNewUniform = uNewUniform2;\n'
};
(0, _tapeCatch.default)('injectShader#import', function (t) {
  t.ok(_injectShader.default !== undefined, 'injectShader import successful');
  t.end();
});
(0, _tapeCatch.default)('injectShader#injectShader', function (t) {
  var injectResult;
  injectResult = (0, _injectShader.default)(VS_GLSL_TEMPLATE, 'vs', INJECT);
  t.equal(injectResult, VS_GLSL_RESOLVED, 'correctly injected');
  injectResult = (0, _injectShader.default)(FS_GLSL_TEMPLATE, 'fs', INJECT);
  t.equal(injectResult, FS_GLSL_RESOLVED, 'correctly injected');
  t.end();
});
(0, _tapeCatch.default)('injectShader#assembleShaders', function (t) {
  var assembleResult = (0, _luma.assembleShaders)(fixture.gl, {
    vs: VS_GLSL_TEMPLATE,
    fs: FS_GLSL_TEMPLATE,
    inject: INJECT,
    prologue: false
  });
  t.equal(assembleResult.vs, VS_GLSL_RESOLVED, 'correctly injected');
  t.equal(assembleResult.fs, FS_GLSL_RESOLVED, 'correctly injected');
  t.end();
});
(0, _tapeCatch.default)('injectShader#combineInjects', function (t) {
  t.deepEqual((0, _injectShader.combineInjects)([INJECT, INJECT2]), COMBINED_INJECT, 'injects correctly combined');
  t.end();
});
//# sourceMappingURL=inject-shader.spec.js.map