"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _luma = require("luma.gl");

var _tapeCatch = _interopRequireDefault(require("tape-catch"));

/* eslint-disable camelcase */
// import {getShaderModule} from 'luma.gl/shadertools/src/lib/resolve-modules';
// import {makeSpy} from 'probe.gl/test-utils';
var fixture = {
  gl: (0, _luma.createGLContext)()
};
var VS_GLSL_300 = "#version 300 es\n\nin vec4 positions;\n\nvoid main(void) {\n  gl_Position = positions;\n}\n";
var FS_GLSL_300 = "#version 300 es\n\nprecision highp float;\n\nout vec4 fragmentColor;\n\nvoid main(void) {\n  fragmentColor = vec4(1.0, 1.0, 1.0, 1.0);\n}\n";
(0, _tapeCatch.default)('assembleShaders#import', function (t) {
  t.ok(_luma.assembleShaders !== undefined, 'assembleShaders import successful');
  t.end();
});
(0, _tapeCatch.default)('assembleShaders#version_directive', function (t) {
  var assembleResult = (0, _luma.assembleShaders)(fixture.gl, {
    vs: VS_GLSL_300,
    fs: FS_GLSL_300,
    modules: [_luma.picking]
  }); // Verify version directive remains as first line.

  t.equal(assembleResult.vs.indexOf('#version 300 es'), 0, 'version directive should be first statement');
  t.equal(assembleResult.fs.indexOf('#version 300 es'), 0, 'version directive should be first statement');
  t.end();
});
(0, _tapeCatch.default)('assembleShaders#getUniforms', function (t) {
  var testModuleSettings = {
    pickingActive: true
  }; // inject spy into the picking module's getUniforms
  // const module = getShaderModule(picking);
  // const getUniformsSpy = makeSpy(module, 'getUniforms');

  var assembleResult; // Without shader modules

  assembleResult = (0, _luma.assembleShaders)(fixture.gl, {
    vs: VS_GLSL_300,
    fs: FS_GLSL_300
  }); // Verify getUniforms is function

  t.is((0, _typeof2.default)(assembleResult.getUniforms), 'function', 'getUniforms should be function'); // With shader modules

  var testModule = {
    name: 'test-module',
    vs: '',
    fs: '',
    getUniforms: function getUniforms(opts, context) {
      // Check a uniform generated by its dependency
      t.ok(context.picking_uActive, 'module getUniforms is called with correct context');
      return {};
    },
    dependencies: ['picking']
  };
  assembleResult = (0, _luma.assembleShaders)(fixture.gl, {
    vs: VS_GLSL_300,
    fs: FS_GLSL_300,
    modules: [_luma.picking, testModule, _luma.fp64]
  }); // Verify getUniforms is function

  t.is((0, _typeof2.default)(assembleResult.getUniforms), 'function', 'getUniforms should be function');
  assembleResult.getUniforms(testModuleSettings); // t.ok(module.getUniforms.called, 'module getUniforms is called');
  // TODO: probe.gl spy does not yet support args
  // t.deepEqual(
  //   picking.getUniforms.getCall(0).args[0],
  //   testModuleSettings,
  //   'module getUniforms is called with correct opts');
  // t.ok(testModule.getUniforms.calledAfter(picking.getUniforms),
  //   'module getUniforms is called after its dependencies');
  // TODO: probe.gl spy does not yet support args
  // t.deepEqual(
  //   testModule.getUniforms.getCall(0).args[0],
  //   testModuleSettings,
  //   'module getUniforms is called with correct opts');
  // getUniformsSpy.restore();

  t.end();
});
//# sourceMappingURL=assemble-shaders.spec.js.map