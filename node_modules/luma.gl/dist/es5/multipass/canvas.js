"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

require("luma.gl/debug");

var _luma = require("luma.gl");

var _shaderModulePass = _interopRequireDefault(require("./shader-module-pass"));

/* global document */
var DEFAULT_VS = "attribute vec2 vertex;\nattribute vec2 _texCoord;\nvarying vec2 texCoord;\nvoid main() {\n  texCoord = _texCoord;\n  gl_Position = vec4(vertex * 2.0 - 1.0, 0.0, 1.0);\n}\n";

var Canvas =
/*#__PURE__*/
function () {
  function Canvas() {
    (0, _classCallCheck2.default)(this, Canvas);
    this.canvas = document.createElement('canvas');
    this.width = this.canvas.clientWidth;
    this.height = this.canvas.clientHeight;
    this.gl = (0, _luma.createGLContext)({
      canvas: this.canvas,
      opts: {
        premultipliedAlpha: false
      }
    });

    if (!this.gl) {
      throw new Error('This browser does not support WebGL');
    }

    this.texture = null;
    this.spareTexture = null;
    this.flippedModel = null;
  }

  (0, _createClass2.default)(Canvas, [{
    key: "installFiltersAsMethods",
    value: function installFiltersAsMethods(filters) {
      var _this = this;

      var _loop = function _loop(key) {
        if (key !== 'canvas') {
          _this[key] = function (props) {
            return _this.filter(filters[key], props).bind(_this);
          };
        }
      };

      // // Filter methods
      for (var key in filters) {
        _loop(key);
      }
    }
  }, {
    key: "setTexture",
    value: function setTexture(element) {
      this.texture = new _luma.Texture2D(this.gl, {
        pixels: element
      });
      this.resize(this.gl, this.texture.width, this.texture.height);
      return this;
    }
  }, {
    key: "resize",
    value: function resize(gl, width, height) {
      var realToCSSPixels = 1; // window.devicePixelRatio || 1;
      // Check if the canvas is not the same size.

      if (gl.canvas.width !== width || gl.canvas.height !== height) {
        // Make the canvas the same size
        gl.canvas.width = width;
        gl.canvas.height = height; // Lookup the size the browser is displaying the canvas in CSS pixels
        // and compute a size needed to make our drawingbuffer match it in
        // device pixels.

        var displayWidth = Math.floor(width / realToCSSPixels);
        var displayHeight = Math.floor(height / realToCSSPixels);
        gl.canvas.style.width = "".concat(displayWidth, "px");
        gl.canvas.style.height = "".concat(displayHeight, "px");
        gl.viewport(0, 0, width, height);
        this.width = displayWidth;
        this.height = displayHeight;
      }
    }
  }, {
    key: "replace",
    value: function replace(node) {
      node.parentNode.insertBefore(this.canvas, node);
      node.parentNode.removeChild(node);
      return this;
    } // Draw a texture to the canvas, with an optional width and height to scale to.
    // If no width and height are given then the original texture width and height
    // are used.

  }, {
    key: "draw",
    value: function draw() {
      this.multiPassRenderer = new _luma._MultiPassRenderer(this.gl, [new _luma._ClearPass(this.gl), new _luma._TexturePass(this.gl, {
        texture: this.texture
      }), new _luma._CopyPass(this.gl, {
        screen: true
      })]);
      this.multiPassRenderer.render();
      return this;
    }
  }, {
    key: "update",
    value: function update() {
      this.multiPassRenderer.render({});
      return this;
    }
  }, {
    key: "filter",
    value: function filter(shaderModule, props) {
      this.multiPassRenderer = new _luma._MultiPassRenderer(this.gl, [new _luma._ClearPass(this.gl), new _luma._TexturePass(this.gl, {
        texture: this.texture
      }), new _shaderModulePass.default(this.gl, shaderModule, props), new _luma._CopyPass(this.gl, {
        screen: true
      })]);
      this.multiPassRenderer.render();
      return this;
    }
    /*
    contents() {
      // const gl = this.gl;
      // const texture = new Texture2D(this.gl, {
      //   width: this.texture.width,
      //   height: this.texture.height,
      //   format: gl.RGBA,
      //   type: gl.UNSIGNED_BYTE
      // });
      // this.texture.use();
      // texture.drawTo(() => this.getDefaultModel(this.gl).drawRect());
      // return wrapTexture(texture);
    }
    */
    // Get a Uint8 array of pixel values: [r, g, b, a, r, g, b, a, ...]
    // Length of the array will be width * height * 4.

  }, {
    key: "getPixelArray",
    value: function getPixelArray() {
      var gl = this.gl;
      var w = this.texture.width;
      var h = this.texture.height;
      var array = new Uint8Array(w * h * 4);
      this.texture.drawTo(function () {
        return gl.readPixels(0, 0, w, h, 6408, 5121, array);
      });
      return array;
    }
  }, {
    key: "_initialize",
    value: function _initialize(width, height) {
      var gl = this.gl;
      var type = 5121; // Go for floating point buffer textures if we can, it'll make the bokeh
      // filter look a lot better. Note that on Windows, ANGLE does not let you
      // render to a floating-point texture when linear filtering is enabled.
      // See http://crbug.com/172278 for more information.

      if (this.gl.getExtension('OES_texture_float') && gl.getExtension('OES_texture_float_linear')) {
        var testTexture = new _luma.Texture2D(this.gl, {
          width: 100,
          height: 100,
          format: 6408,
          type: 5126
        });

        try {
          // Only use gl.FLOAT if we can render to it
          testTexture.drawTo(function () {
            type = 5126;
          });
        } catch (error) {// ignore
        }

        testTexture.destroy();
      }

      if (this.spareTexture) {
        this.spareTexture.destroy();
      }

      this.width = width;
      this.height = height;
      this.texture = new _luma.Texture2D(this.gl, {
        width: width,
        height: height,
        format: 6408,
        type: type
      });
      this.spareTexture = new _luma.Texture2D(this.gl, {
        width: width,
        height: height,
        format: 6408,
        type: type
      });
      this.extraTexture = this.extraTexture || new _luma.Texture2D(this.gl, {
        width: 0,
        height: 0,
        format: 6408,
        type: type
      });
      this.flippedModel = this.flippedModel || new _luma.Model(this.gl, {
        vs: DEFAULT_VS,
        fs: "uniform sampler2D texture;\nvarying vec2 texCoord;\nvoid main() {\n  gl_FragColor = texture2D(texture, vec2(texCoord.x, 1.0 - texCoord.y));\n}\n"
      });
      this.isInitialized = true;
    }
  }]);
  return Canvas;
}();

exports.default = Canvas;
//# sourceMappingURL=canvas.js.map