"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setParameters = setParameters;
exports.withParameters = withParameters;
Object.defineProperty(exports, "getParameter", {
  enumerable: true,
  get: function get() {
    return _setParameters.getParameter;
  }
});
Object.defineProperty(exports, "getParameters", {
  enumerable: true,
  get: function get() {
    return _setParameters.getParameters;
  }
});
Object.defineProperty(exports, "setParameter", {
  enumerable: true,
  get: function get() {
    return _setParameters.setParameter;
  }
});
Object.defineProperty(exports, "resetParameters", {
  enumerable: true,
  get: function get() {
    return _setParameters.resetParameters;
  }
});
Object.defineProperty(exports, "getModifiedParameters", {
  enumerable: true,
  get: function get() {
    return _setParameters.getModifiedParameters;
  }
});
exports.LUMA_SETTERS = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _trackContextState = require("../webgl-context/track-context-state");

var _setParameters = require("../webgl-context/set-parameters");

var _utils = require("../utils");

var _assert = _interopRequireDefault(require("../utils/assert"));

/* eslint-disable no-inline-comments, max-len */
// map of parameter setter function names, parameter constants, default values and types
// - Uses gl function names, except when setter function exist that are named differently
// - When the WebGL api offers <setter> and <setter>Separate (e.g. blendEquation and
//   blendEquationSeparate, we use non-separate name, but accept both non-separate and
//   separate arguments. Thus, a `getParameter` call will always return all the separate values
//   in an array, in a form that can be accepted by the setter.
var LUMA_SETTERS = {
  framebuffer: function framebuffer(gl, _framebuffer) {
    // accepts 1) a WebGLFramebuffer 2) null (default framebuffer), or 3) luma.gl Framebuffer class
    // framebuffer is null when restoring to default framebuffer, otherwise use the WebGL handle.
    var handle = _framebuffer && 'handle' in _framebuffer ? _framebuffer.handle : _framebuffer;
    return gl.bindFramebuffer(36160, handle);
  },
  blend: function blend(gl, value) {
    return value ? gl.enable(3042) : gl.disable(3042);
  },
  blendColor: function blendColor(gl, value) {
    return gl.blendColor.apply(gl, (0, _toConsumableArray2.default)(value));
  },
  blendEquation: function blendEquation(gl, args) {
    args = isArray(args) ? args : [args, args];
    gl.blendEquationSeparate.apply(gl, (0, _toConsumableArray2.default)(args));
  },
  blendFunc: function blendFunc(gl, args) {
    args = isArray(args) && args.length === 2 ? (0, _toConsumableArray2.default)(args).concat((0, _toConsumableArray2.default)(args)) : args;
    gl.blendFuncSeparate.apply(gl, (0, _toConsumableArray2.default)(args));
  },
  clearColor: function clearColor(gl, value) {
    return gl.clearColor.apply(gl, (0, _toConsumableArray2.default)(value));
  },
  clearDepth: function clearDepth(gl, value) {
    return gl.clearDepth(value);
  },
  clearStencil: function clearStencil(gl, value) {
    return gl.clearStencil(value);
  },
  colorMask: function colorMask(gl, value) {
    return gl.colorMask.apply(gl, (0, _toConsumableArray2.default)(value));
  },
  cull: function cull(gl, value) {
    return value ? gl.enable(2884) : gl.disable(2884);
  },
  cullFace: function cullFace(gl, value) {
    return gl.cullFace(value);
  },
  depthTest: function depthTest(gl, value) {
    return value ? gl.enable(2929) : gl.disable(2929);
  },
  depthFunc: function depthFunc(gl, value) {
    return gl.depthFunc(value);
  },
  depthMask: function depthMask(gl, value) {
    return gl.depthMask(value);
  },
  depthRange: function depthRange(gl, value) {
    return gl.depthRange.apply(gl, (0, _toConsumableArray2.default)(value));
  },
  dither: function dither(gl, value) {
    return value ? gl.enable(3024) : gl.disable(3024);
  },
  derivativeHint: function derivativeHint(gl, value) {
    // gl1: 'OES_standard_derivatives'
    gl.hint(35723, value);
  },
  frontFace: function frontFace(gl, value) {
    return gl.frontFace(value);
  },
  mipmapHint: function mipmapHint(gl, value) {
    return gl.hint(33170, value);
  },
  lineWidth: function lineWidth(gl, value) {
    return gl.lineWidth(value);
  },
  polygonOffsetFill: function polygonOffsetFill(gl, value) {
    return value ? gl.enable(32823) : gl.disable(32823);
  },
  polygonOffset: function polygonOffset(gl, value) {
    return gl.polygonOffset.apply(gl, (0, _toConsumableArray2.default)(value));
  },
  sampleCoverage: function sampleCoverage(gl, value) {
    return gl.sampleCoverage.apply(gl, (0, _toConsumableArray2.default)(value));
  },
  scissorTest: function scissorTest(gl, value) {
    return value ? gl.enable(3089) : gl.disable(3089);
  },
  scissor: function scissor(gl, value) {
    return gl.scissor.apply(gl, (0, _toConsumableArray2.default)(value));
  },
  stencilTest: function stencilTest(gl, value) {
    return value ? gl.enable(2960) : gl.disable(2960);
  },
  stencilMask: function stencilMask(gl, value) {
    value = isArray(value) ? value : [value, value];

    var _value = value,
        _value2 = (0, _slicedToArray2.default)(_value, 2),
        mask = _value2[0],
        backMask = _value2[1];

    gl.stencilMaskSeparate(1028, mask);
    gl.stencilMaskSeparate(1029, backMask);
  },
  stencilFunc: function stencilFunc(gl, args) {
    args = isArray(args) && args.length === 3 ? (0, _toConsumableArray2.default)(args).concat((0, _toConsumableArray2.default)(args)) : args;

    var _args = args,
        _args2 = (0, _slicedToArray2.default)(_args, 6),
        func = _args2[0],
        ref = _args2[1],
        mask = _args2[2],
        backFunc = _args2[3],
        backRef = _args2[4],
        backMask = _args2[5];

    gl.stencilFuncSeparate(1028, func, ref, mask);
    gl.stencilFuncSeparate(1029, backFunc, backRef, backMask);
  },
  stencilOp: function stencilOp(gl, args) {
    args = isArray(args) && args.length === 3 ? (0, _toConsumableArray2.default)(args).concat((0, _toConsumableArray2.default)(args)) : args;

    var _args3 = args,
        _args4 = (0, _slicedToArray2.default)(_args3, 6),
        sfail = _args4[0],
        dpfail = _args4[1],
        dppass = _args4[2],
        backSfail = _args4[3],
        backDpfail = _args4[4],
        backDppass = _args4[5];

    gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
    gl.stencilOpSeparate(1029, backSfail, backDpfail, backDppass);
  },
  viewport: function viewport(gl, value) {
    return gl.viewport.apply(gl, (0, _toConsumableArray2.default)(value));
  }
}; // HELPERS

exports.LUMA_SETTERS = LUMA_SETTERS;

function isArray(array) {
  return Array.isArray(array) || ArrayBuffer.isView(array);
} // GETTERS AND SETTERS
// Get the parameter value(s) from the context


// Note: "setParameters" is given extra treatment below
// Set the parameter value(s) by key to the context
// Sets value with key to context.
// Value may be "normalized" (in case a short form is supported). In that case
// the normalized value is retured.
function setParameters(gl, parameters) {
  (0, _setParameters.setParameters)(gl, parameters);

  for (var key in parameters) {
    var setter = LUMA_SETTERS[key];

    if (setter) {
      setter(gl, parameters[key], key);
    }
  }
} // VERY LIMITED / BASIC GL STATE MANAGEMENT
// Executes a function with gl states temporarily set, exception safe
// Currently support pixelStorage, scissor test and framebuffer binding


function withParameters(gl, parameters, func) {
  // assertWebGLContext(gl);
  if ((0, _utils.isObjectEmpty)(parameters)) {
    // Avoid setting state if no parameters provided. Just call and return
    return func(gl);
  }

  var _parameters$nocatch = parameters.nocatch,
      nocatch = _parameters$nocatch === void 0 ? true : _parameters$nocatch; // frameBuffer not supported use framebuffer

  (0, _assert.default)(!parameters.frameBuffer);
  (0, _trackContextState.pushContextState)(gl);
  setParameters(gl, parameters); // Setup is done, call the function

  var value;

  if (nocatch) {
    // Avoid try catch to minimize stack size impact for safe execution paths
    value = func(gl);
    (0, _trackContextState.popContextState)(gl);
  } else {
    // Wrap in a try-catch to ensure that parameters are restored on exceptions
    try {
      value = func(gl);
    } finally {
      (0, _trackContextState.popContextState)(gl);
    }
  }

  return value;
}
//# sourceMappingURL=context-state.js.map