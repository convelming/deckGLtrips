"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _webglContext = require("../webgl-context");

var _debugContext = require("../webgl-context/debug-context");

var _webglUtils = require("../webgl-utils");

var _utils = require("../utils");

var _assert = _interopRequireDefault(require("../utils/assert"));

var _webgl = require("../webgl");

// TODO - remove dependency on webgl classes
var DEFAULT_GL_OPTIONS = {
  preserveDrawingBuffer: true
};

var AnimationLoop =
/*#__PURE__*/
function () {
  /*
   * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context
   */
  function AnimationLoop() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, AnimationLoop);
    var _props$onCreateContex = props.onCreateContext,
        onCreateContext = _props$onCreateContex === void 0 ? function (opts) {
      return (0, _webglContext.createGLContext)(opts);
    } : _props$onCreateContex,
        _props$onAddHTML = props.onAddHTML,
        onAddHTML = _props$onAddHTML === void 0 ? null : _props$onAddHTML,
        _props$onInitialize = props.onInitialize,
        onInitialize = _props$onInitialize === void 0 ? function () {} : _props$onInitialize,
        _props$onRender = props.onRender,
        onRender = _props$onRender === void 0 ? function () {} : _props$onRender,
        _props$onFinalize = props.onFinalize,
        onFinalize = _props$onFinalize === void 0 ? function () {} : _props$onFinalize,
        _props$offScreen = props.offScreen,
        offScreen = _props$offScreen === void 0 ? false : _props$offScreen,
        _props$gl = props.gl,
        gl = _props$gl === void 0 ? null : _props$gl,
        _props$glOptions = props.glOptions,
        glOptions = _props$glOptions === void 0 ? {} : _props$glOptions,
        _props$debug = props.debug,
        debug = _props$debug === void 0 ? false : _props$debug,
        _props$createFramebuf = props.createFramebuffer,
        createFramebuffer = _props$createFramebuf === void 0 ? false : _props$createFramebuf,
        _props$autoResizeView = props.autoResizeViewport,
        autoResizeViewport = _props$autoResizeView === void 0 ? true : _props$autoResizeView,
        _props$autoResizeDraw = props.autoResizeDrawingBuffer,
        autoResizeDrawingBuffer = _props$autoResizeDraw === void 0 ? true : _props$autoResizeDraw;
    var _props$useDevicePixel = props.useDevicePixels,
        useDevicePixels = _props$useDevicePixel === void 0 ? true : _props$useDevicePixel;

    if ('useDevicePixelRatio' in props) {
      _utils.log.deprecated('useDevicePixelRatio', 'useDevicePixels')();

      useDevicePixels = props.useDevicePixelRatio;
    }

    this.props = {
      onCreateContext: onCreateContext,
      onAddHTML: onAddHTML,
      onInitialize: onInitialize,
      onRender: onRender,
      onFinalize: onFinalize,
      gl: gl,
      glOptions: glOptions,
      debug: debug,
      createFramebuffer: createFramebuffer
    }; // state

    this.gl = gl;
    this.offScreen = offScreen;
    this.needsRedraw = null;
    this.setProps({
      autoResizeViewport: autoResizeViewport,
      autoResizeDrawingBuffer: autoResizeDrawingBuffer,
      useDevicePixels: useDevicePixels
    }); // Bind methods

    this.start = this.start.bind(this);
    this.stop = this.stop.bind(this);
    this._renderFrame = this._renderFrame.bind(this);
    this._onMousemove = this._onMousemove.bind(this);
    this._onMouseleave = this._onMouseleave.bind(this);
    return this;
  }

  (0, _createClass2.default)(AnimationLoop, [{
    key: "setNeedsRedraw",
    value: function setNeedsRedraw(reason) {
      (0, _assert.default)(typeof reason === 'string');
      this.needsRedraw = this.needsRedraw || reason;
      return this;
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      if ('autoResizeViewport' in props) {
        this.autoResizeViewport = props.autoResizeViewport;
      }

      if ('autoResizeDrawingBuffer' in props) {
        this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;
      }

      if ('useDevicePixels' in props) {
        this.useDevicePixels = props.useDevicePixels;
      }

      return this;
    } // Starts a render loop if not already running
    // @param {Object} context - contains frame specific info (E.g. tick, width, height, etc)

  }, {
    key: "start",
    value: function start() {
      var _this = this;

      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this._stopped = false; // console.debug(`Starting ${this.constructor.name}`);

      if (!this._animationFrameId) {
        // Wait for start promise before rendering frame
        this._startPromise = (0, _webglContext.getPageLoadPromise)().then(function () {
          if (_this._stopped) {
            return null;
          } // Create the WebGL context


          _this._createWebGLContext(opts);

          _this._createFramebuffer();

          _this._startEventHandling(); // Initialize the callback data


          _this._initializeCallbackData();

          _this._updateCallbackData(); // Default viewport setup, in case onInitialize wants to render


          _this._resizeCanvasDrawingBuffer();

          _this._resizeViewport(); // Note: onIntialize can return a promise (in case it needs to load resources)


          return _this.onInitialize(_this.animationProps);
        }).then(function (appContext) {
          if (!_this._stopped) {
            _this._addCallbackData(appContext || {});

            if (appContext !== false && !_this._animationFrameId) {
              _this._animationFrameId = (0, _webglUtils.requestAnimationFrame)(_this._renderFrame);
            }
          }
        });
      }

      return this;
    } // Stops a render loop if already running, finalizing

  }, {
    key: "stop",
    value: function stop() {
      // console.debug(`Stopping ${this.constructor.name}`);
      if (this._animationFrameId) {
        this._finalizeCallbackData();

        (0, _webglUtils.cancelAnimationFrame)(this._animationFrameId);
        this._animationFrameId = null;
        this._stopped = true;
      }

      return this;
    }
  }, {
    key: "onCreateContext",
    value: function onCreateContext() {
      var _this$props;

      return (_this$props = this.props).onCreateContext.apply(_this$props, arguments);
    }
  }, {
    key: "onInitialize",
    value: function onInitialize() {
      var _this$props2;

      return (_this$props2 = this.props).onInitialize.apply(_this$props2, arguments);
    }
  }, {
    key: "onRender",
    value: function onRender() {
      var _this$props3;

      return (_this$props3 = this.props).onRender.apply(_this$props3, arguments);
    }
  }, {
    key: "onFinalize",
    value: function onFinalize() {
      var _this$props4;

      return (_this$props4 = this.props).onFinalize.apply(_this$props4, arguments);
    } // DEPRECATED/REMOVED METHODS

  }, {
    key: "getHTMLControlValue",
    value: function getHTMLControlValue(id) {
      var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var element = document.getElementById(id);
      return element ? Number(element.value) : defaultValue;
    } // Update parameters

  }, {
    key: "setViewParameters",
    value: function setViewParameters() {
      _utils.log.removed('AnimationLoop.setViewParameters', 'AnimationLoop.setProps')();

      return this;
    } // PRIVATE METHODS

  }, {
    key: "_setupFrame",
    value: function _setupFrame() {
      if (this._onSetupFrame) {
        // call callback
        this._onSetupFrame(this.animationProps); // end callback

      } else {
        this._resizeCanvasDrawingBuffer();

        this._resizeViewport();

        this._resizeFramebuffer();
      }
    }
    /**
     * @private
     * Handles a render loop frame - updates context and calls the application
     * callback
     */

  }, {
    key: "_renderFrame",
    value: function _renderFrame() {
      if (this._stopped) {
        return;
      }

      this._setupFrame();

      this._updateCallbackData(); // call callback


      this.onRender(this.animationProps); // end callback

      if (this.offScreen) {
        // commit returns a Promise
        this.gl.commit().then(this._renderFrame);
      } else {
        // Request another render frame (now )
        this._animationFrameId = (0, _webglUtils.requestAnimationFrame)(this._renderFrame);
      }
    } // Initialize the  object that will be passed to app callbacks

  }, {
    key: "_initializeCallbackData",
    value: function _initializeCallbackData() {
      this.animationProps = {
        gl: this.gl,
        stop: this.stop,
        canvas: this.gl.canvas,
        framebuffer: this.framebuffer,
        // Initial values
        useDevicePixels: this.useDevicePixels,
        needsRedraw: null,
        // Animation props
        startTime: Date.now(),
        time: 0,
        tick: 0,
        tock: 0,
        // canvas
        // Experimental
        _loop: this,
        _animationLoop: this,
        _mousePosition: null // Event props

      };
    } // Update the context object that will be passed to app callbacks

  }, {
    key: "_updateCallbackData",
    value: function _updateCallbackData() {
      // Update redraw reason
      this.animationProps.needsRedraw = this.needsRedraw;
      this.needsRedraw = null;

      var _this$_getSizeAndAspe = this._getSizeAndAspect(),
          width = _this$_getSizeAndAspe.width,
          height = _this$_getSizeAndAspe.height,
          aspect = _this$_getSizeAndAspe.aspect;

      if (width !== this.animationProps.width || height !== this.animationProps.height) {
        this.setNeedsRedraw('drawing buffer resized');
      }

      if (aspect !== this.animationProps.aspect) {
        this.setNeedsRedraw('drawing buffer aspect changed');
      }

      this.animationProps.width = width;
      this.animationProps.height = height;
      this.animationProps.aspect = aspect;
      this.animationProps.needsRedraw = this.needsRedraw; // Increment tick

      this.animationProps.time = Date.now() - this.animationProps.startTime;
      this.animationProps.tick = Math.floor(this.animationProps.time / 1000 * 60);
      this.animationProps.tock++; // experimental

      this.animationProps._offScreen = this.offScreen;
    }
  }, {
    key: "_finalizeCallbackData",
    value: function _finalizeCallbackData() {
      // call callback
      this.onFinalize(this.animationProps); // end callback
    } // Add application's data to the app context object

  }, {
    key: "_addCallbackData",
    value: function _addCallbackData(appContext) {
      if ((0, _typeof2.default)(appContext) === 'object' && appContext !== null) {
        this.animationProps = Object.assign({}, this.animationProps, appContext);
      }
    } // Either uses supplied or existing context, or calls provided callback to create one

  }, {
    key: "_createWebGLContext",
    value: function _createWebGLContext(opts) {
      // Create the WebGL context if necessary
      opts = Object.assign({}, opts, DEFAULT_GL_OPTIONS, this.props.glOptions);
      this.gl = this.props.gl || this.onCreateContext(opts);

      if (!(0, _webglUtils.isWebGL)(this.gl)) {
        throw new Error('AnimationLoop.onCreateContext - illegal context returned');
      }

      if (this.props.debug) {
        this.gl = (0, _debugContext.makeDebugContext)(this.gl);
      } // Reset the WebGL context.


      (0, _webglContext.resetParameters)(this.gl);

      this._createInfoDiv();
    }
  }, {
    key: "_createInfoDiv",
    value: function _createInfoDiv() {
      if (this.gl.canvas && this.props.onAddHTML) {
        /* global document */
        var wrapperDiv = document.createElement('div');
        document.body.appendChild(wrapperDiv);
        wrapperDiv.style.position = 'relative';
        var div = document.createElement('div');
        div.style.position = 'absolute';
        div.style.left = '10px';
        div.style.bottom = '10px';
        div.style.width = '300px';
        div.style.background = 'white';
        wrapperDiv.appendChild(this.gl.canvas);
        wrapperDiv.appendChild(div);
        var html = this.props.onAddHTML(div);

        if (html) {
          div.innerHTML = html;
        }
      }
    }
  }, {
    key: "_getSizeAndAspect",
    value: function _getSizeAndAspect() {
      // https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
      var width = this.gl.drawingBufferWidth;
      var height = this.gl.drawingBufferHeight; // https://webglfundamentals.org/webgl/lessons/webgl-anti-patterns.html

      var aspect = 1;
      var _this$gl$canvas = this.gl.canvas,
          clientWidth = _this$gl$canvas.clientWidth,
          clientHeight = _this$gl$canvas.clientHeight;

      if (clientWidth >= 0 && clientHeight >= 0) {
        aspect = height > 0 ? clientWidth / clientHeight : 1;
      } else if (width > 0 && height > 0) {
        aspect = width / height;
      }

      return {
        width: width,
        height: height,
        aspect: aspect
      };
    } // Default viewport setup

  }, {
    key: "_resizeViewport",
    value: function _resizeViewport() {
      if (this.autoResizeViewport) {
        this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
      }
    } // Resize the render buffer of the canvas to match canvas client size
    // Optionally multiplying with devicePixel ratio

  }, {
    key: "_resizeCanvasDrawingBuffer",
    value: function _resizeCanvasDrawingBuffer() {
      if (this.autoResizeDrawingBuffer) {
        (0, _webglContext.resizeGLContext)(this.gl, {
          useDevicePixels: this.useDevicePixels
        });
      }
    } // TBD - deprecated?

  }, {
    key: "_createFramebuffer",
    value: function _createFramebuffer() {
      // Setup default framebuffer
      if (this.props.createFramebuffer) {
        this.framebuffer = new _webgl.Framebuffer(this.gl);
      }
    }
  }, {
    key: "_resizeFramebuffer",
    value: function _resizeFramebuffer() {
      if (this.framebuffer) {
        this.framebuffer.resize({
          width: this.gl.drawingBufferWidth,
          height: this.gl.drawingBufferHeight
        });
      }
    } // Event handling

  }, {
    key: "_startEventHandling",
    value: function _startEventHandling() {
      this.gl.canvas.addEventListener('mousemove', this._onMousemove);
      this.gl.canvas.addEventListener('mouseleave', this._onMouseleave);
    }
  }, {
    key: "_onMousemove",
    value: function _onMousemove(e) {
      this.animationProps._mousePosition = [e.offsetX, e.offsetY];
    }
  }, {
    key: "_onMouseleave",
    value: function _onMouseleave(e) {
      this.animationProps._mousePosition = null;
    }
  }]);
  return AnimationLoop;
}();

exports.default = AnimationLoop;
//# sourceMappingURL=animation-loop.js.map