"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _model = _interopRequireDefault(require("./model"));

var _buffer = _interopRequireDefault(require("../webgl/buffer"));

var _framebuffer = _interopRequireDefault(require("../webgl/framebuffer"));

var _texture2d = _interopRequireDefault(require("../webgl/texture-2d"));

var _transformFeedback = _interopRequireDefault(require("../webgl/transform-feedback"));

var _src = require("../shadertools/src");

var _webglUtils = require("../webgl-utils");

var _assert = _interopRequireDefault(require("../utils/assert"));

var _utils = require("../utils");

var _transformShaderUtils = require("./transform-shader-utils");

var _SRC_TEX_PARAMETER_OV;

// Texture parameters needed so sample can precisely pick pixel for given element id.
var SRC_TEX_PARAMETER_OVERRIDES = (_SRC_TEX_PARAMETER_OV = {}, (0, _defineProperty2.default)(_SRC_TEX_PARAMETER_OV, 10241, 9728), (0, _defineProperty2.default)(_SRC_TEX_PARAMETER_OV, 10240, 9728), (0, _defineProperty2.default)(_SRC_TEX_PARAMETER_OV, 10242, 33071), (0, _defineProperty2.default)(_SRC_TEX_PARAMETER_OV, 10243, 33071), _SRC_TEX_PARAMETER_OV);
var FS_OUTPUT_VARIABLE = 'transform_output';

var Transform =
/*#__PURE__*/
function () {
  (0, _createClass2.default)(Transform, null, [{
    key: "isSupported",
    value: function isSupported(gl) {
      // For now WebGL2 only
      return (0, _webglUtils.isWebGL2)(gl);
    }
  }]);

  function Transform(gl) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Transform);
    (0, _webglUtils.assertWebGL2Context)(gl);
    this.gl = gl;
    this.model = null;
    this.elementCount = 0;
    this.currentIndex = 0; // Source and destination resources are stored in two element Arrays for easier swapping when
    // 'feedbackMap' is provided. If not only the first array elment is used.
    // Each array element is an object with attribute name as Key and Buffer object as value.

    this.sourceBuffers = new Array(2); // Each array element is an object with attribute name as Key and Texture object as value.

    this.sourceTextures = new Array(2); // Each array element is an object with varying name as Key and Buffer object as value.

    this.feedbackBuffers = new Array(2); // Each array element is a Texture object used as color attachment for framebuffer.

    this.targetTextures = new Array(2); // Each array element is a TransformFeedback object.

    this.transformFeedbacks = new Array(2); // Each array element is a Framebuffer object.

    this.framebuffers = new Array(2);
    this._createdBuffers = {};
    this.elementIDBuffer = null;

    this._initialize(props);

    Object.seal(this);
  } // Delete owned resources.


  (0, _createClass2.default)(Transform, [{
    key: "delete",
    value: function _delete() {
      for (var name in this._createdBuffers) {
        this._createdBuffers[name].delete();
      }

      this.model.delete();
    } // Return Buffer object for given varying name.

  }, {
    key: "getBuffer",
    value: function getBuffer() {
      var varyingName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      (0, _assert.default)(varyingName && this.feedbackBuffers[this.currentIndex][varyingName]);
      return this.feedbackBuffers[this.currentIndex][varyingName];
    } // Returns the color attachment textuer from current framebuffer target

  }, {
    key: "_getTargetTexture",
    value: function _getTargetTexture() {
      if (this.framebuffers[this.currentIndex]) {
        return this.framebuffers[this.currentIndex].attachments[36064];
      }

      return null;
    } // Return data either from Buffer or from Texture

  }, {
    key: "getData",
    value: function getData() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$varyingName = _ref.varyingName,
          varyingName = _ref$varyingName === void 0 ? null : _ref$varyingName,
          _ref$packed = _ref.packed,
          packed = _ref$packed === void 0 ? false : _ref$packed;

      // Either there should be specified feedbackBuffer or we should be rendering to a texture
      if (varyingName && this.feedbackBuffers[this.currentIndex][varyingName]) {
        return this.feedbackBuffers[this.currentIndex][varyingName].getData();
      } // When varyingName is not provided return data from framebuffer object.


      (0, _assert.default)(!varyingName || varyingName === this.targetTextureVarying);
      var pixels = this.framebuffers[this.currentIndex].readPixels();

      if (!packed) {
        return pixels;
      } // readPixels returns 4 elements for each pixel, pack the elements when requested


      var ArrayType = pixels.constructor;
      var channelCount = (0, _src.typeToChannelCount)(this.targetTextureType);
      var packedPixels = new ArrayType(pixels.length * channelCount / 4);
      var packCount = 0;

      for (var i = 0; i < pixels.length; i += 4) {
        for (var j = 0; j < channelCount; j++) {
          packedPixels[packCount++] = pixels[i + j];
        }
      }

      return packedPixels;
    }
  }, {
    key: "_getInputs",
    value: function _getInputs() {
      var samplerUniforms = {};
      var current = this.currentIndex; // Buffer inputs

      var attributes = Object.assign({}, this.sourceBuffers[current]); // Texture inputs

      if (this.hasSourceTextures || this.targetTextureVarying) {
        // TODO: add option not generate position using element id.
        attributes.transform_elementID = this.elementIDBuffer;

        for (var sampler in this.samplerTextureMap) {
          var textureName = this.samplerTextureMap[sampler];
          samplerUniforms[sampler] = this.sourceTextures[current][textureName];
        }

        this._setSourceTextureParameters();
      }

      return {
        attributes: attributes,
        samplerUniforms: samplerUniforms
      };
    } // Run one transform feedback loop.

  }, {
    key: "run",
    value: function run() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _this$_getInputs = this._getInputs(),
          attributes = _this$_getInputs.attributes,
          samplerUniforms = _this$_getInputs.samplerUniforms;

      var uniforms = Object.assign({}, samplerUniforms, opts.uniforms);
      ;
      var parameters = Object.assign({}, opts.parameters);
      var _opts$clearRenderTarg = opts.clearRenderTarget,
          clearRenderTarget = _opts$clearRenderTarg === void 0 ? true : _opts$clearRenderTarg;
      var framebuffer = null;
      var discard = true;

      if (this.renderingToTexture) {
        discard = false;
        framebuffer = this.framebuffers[this.currentIndex];
        (0, _assert.default)(framebuffer);
        parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];

        if (clearRenderTarget) {
          this.gl.clear(this.gl.COLOR_BUFFER_BIT);
        }
      }

      this.model.setAttributes(attributes);
      this.model.transform(Object.assign({}, opts, {
        transformFeedback: this.transformFeedbacks[this.currentIndex],
        uniforms: uniforms,
        discard: discard,
        framebuffer: framebuffer,
        parameters: parameters
      }));
    } // Swap source and destination buffers and textures.

  }, {
    key: "swapBuffers",
    value: function swapBuffers() {
      _utils.log.deprecated('swapBuffers()', 'swap()');

      this.swap();
    } // Swap source and destination buffers and textures.

  }, {
    key: "swap",
    value: function swap() {
      (0, _assert.default)(this.feedbackMap || this._swapTexture);
      this.currentIndex = (this.currentIndex + 1) % 2;
    } // Update some or all buffer bindings.

  }, {
    key: "update",
    value: function update() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (opts.elementCount) {
        this._setElementCount(opts.elementCount);
      }

      var _opts$sourceBuffers = opts.sourceBuffers,
          sourceBuffers = _opts$sourceBuffers === void 0 ? null : _opts$sourceBuffers,
          _opts$feedbackBuffers = opts.feedbackBuffers,
          feedbackBuffers = _opts$feedbackBuffers === void 0 ? null : _opts$feedbackBuffers;
      var currentIndex = this.currentIndex;

      if (sourceBuffers || feedbackBuffers) {
        for (var bufferName in feedbackBuffers) {
          (0, _assert.default)(feedbackBuffers[bufferName] instanceof _buffer.default);
        }

        Object.assign(this.sourceBuffers[currentIndex], sourceBuffers);
        Object.assign(this.feedbackBuffers[currentIndex], feedbackBuffers);

        this._createFeedbackBuffers({
          feedbackBuffers: feedbackBuffers
        });

        if (this.transformFeedbacks[currentIndex]) {
          this.transformFeedbacks[currentIndex].setBuffers(this.feedbackBuffers[currentIndex]);
        } // Buffers have changed, need to re-setup swap buffers.


        this._setupSwapBuffers();
      }

      var _sourceTextures = opts._sourceTextures,
          _targetTexture = opts._targetTexture;

      if (_sourceTextures || _targetTexture) {
        Object.assign(this.sourceTextures[currentIndex], _sourceTextures);

        var targetTexture = this._getDestinationTexture(_targetTexture);

        if (targetTexture) {
          this.targetTextures[currentIndex] = this._getDestinationTexture(_targetTexture);
          this.framebuffers[currentIndex].update((0, _defineProperty2.default)({}, 36064, this.targetTextures[currentIndex]));
        } // textures have changed, need to re-setup swap textures.


        this._setupSwapTextures();
      }
    } // set texture filtering parameters on source textures.

  }, {
    key: "_setSourceTextureParameters",
    value: function _setSourceTextureParameters() {
      var index = this.currentIndex;

      for (var name in this.sourceTextures[index]) {
        this.sourceTextures[index][name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);
      }
    } // set element count and updated elementID buffer if needed.

  }, {
    key: "_setElementCount",
    value: function _setElementCount(elementCount) {
      if (this.elementCount === elementCount) {
        return;
      }

      if (this.elementCount < elementCount) {
        this._updateElementIDBuffer(elementCount);
      }

      this.model.setVertexCount(elementCount);
      this.elementCount = elementCount;
    } // Private

  }, {
    key: "_initialize",
    value: function _initialize() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _this$_validateProps = this._validateProps(props),
          feedbackBuffers = _this$_validateProps.feedbackBuffers,
          feedbackMap = _this$_validateProps.feedbackMap;

      var sourceBuffers = props.sourceBuffers,
          varyings = props.varyings,
          _targetTexture = props._targetTexture,
          _targetTextureVarying = props._targetTextureVarying,
          _swapTexture = props._swapTexture;
      var varyingsArray = varyings;

      if (feedbackMap && !Array.isArray(varyings)) {
        varyingsArray = Object.values(feedbackMap);
      }

      this.varyingsArray = varyingsArray;
      this.feedbackMap = feedbackMap;
      this._swapTexture = _swapTexture;

      if (_targetTexture) {
        this.targetTextureVarying = _targetTextureVarying;
        this.renderingToTexture = true;
        (0, _assert.default)(this.targetTextureVarying);
      }

      this._setupBuffers({
        sourceBuffers: sourceBuffers,
        feedbackBuffers: feedbackBuffers
      });

      this._setupTextures(props);

      this._setupSwapBuffers();

      this._setupSwapTextures();

      this._buildModel(Object.assign({}, props, {
        id: props.id || 'transform-model',
        drawMode: props.drawMode || 0,
        varyings: varyingsArray
      }));
    } // assert on required parameters

    /* eslint-disable complexity */

  }, {
    key: "_validateProps",
    value: function _validateProps(props) {
      var feedbackBuffers = props.feedbackBuffers,
          feedbackMap = props.feedbackMap; // backward compitability

      var destinationBuffers = props.destinationBuffers,
          sourceDestinationMap = props.sourceDestinationMap;

      if (destinationBuffers) {
        _utils.log.deprecated('destinationBuffers', 'feedbackBuffers')();

        feedbackBuffers = feedbackBuffers || destinationBuffers;
      }

      if (sourceDestinationMap) {
        _utils.log.deprecated('sourceDestinationMap', 'feedbackMap')();

        feedbackMap = feedbackMap || sourceDestinationMap;
      } // assert on required parameters


      var vs = props.vs,
          elementCount = props.elementCount,
          varyings = props.varyings;
      var _sourceTextures = props._sourceTextures,
          _targetTexture = props._targetTexture,
          _targetTextureVarying = props._targetTextureVarying,
          _swapTexture = props._swapTexture;
      (0, _assert.default)(vs && ( // destinations are provided
      varyings || feedbackMap || _targetTexture) && // when only writting to textures auto-duduce from texture dimenstions
      elementCount);

      for (var bufferName in feedbackBuffers || {}) {
        (0, _assert.default)(feedbackBuffers[bufferName] instanceof _buffer.default);
      }

      for (var textureName in _sourceTextures || {}) {
        (0, _assert.default)(_sourceTextures[textureName] instanceof _texture2d.default);
      } // If rendering to texture , varying is provided


      (0, _assert.default)(!_targetTexture || _targetTextureVarying); // swap texture must be a valid source texture

      (0, _assert.default)(!_swapTexture || _sourceTextures[_swapTexture]);
      return {
        feedbackBuffers: feedbackBuffers,
        feedbackMap: feedbackMap
      };
    }
    /* eslint-enable complexity */
    // setup source and destination buffers

  }, {
    key: "_setupBuffers",
    value: function _setupBuffers(_ref2) {
      var _ref2$sourceBuffers = _ref2.sourceBuffers,
          sourceBuffers = _ref2$sourceBuffers === void 0 ? null : _ref2$sourceBuffers,
          _ref2$feedbackBuffers = _ref2.feedbackBuffers,
          feedbackBuffers = _ref2$feedbackBuffers === void 0 ? null : _ref2$feedbackBuffers;
      this.sourceBuffers[0] = Object.assign({}, sourceBuffers);
      this.feedbackBuffers[0] = Object.assign({}, feedbackBuffers);

      this._createFeedbackBuffers({
        feedbackBuffers: feedbackBuffers
      });

      this.sourceBuffers[1] = {};
      this.feedbackBuffers[1] = {};
    } // setup source and destination textures

  }, {
    key: "_setupTextures",
    value: function _setupTextures() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _sourceTextures = props._sourceTextures,
          _targetTexture = props._targetTexture; // Setup source texture

      this.sourceTextures[0] = Object.assign({}, _sourceTextures);
      this.sourceTextures[1] = {};
      this.hasSourceTextures = Object.keys(this.sourceTextures[0]).length > 0;

      if (this.targetTextureVarying) {
        var texture = this._getDestinationTexture(_targetTexture); // Either a texture or refAttribute must be provided


        (0, _assert.default)(texture);
        this.targetTextures[0] = texture;
        this.targetTextures[1] = null;
      }
    }
  }, {
    key: "_getDestinationTexture",
    value: function _getDestinationTexture(textureOrAttribute) {
      var _parameters;

      if (textureOrAttribute instanceof _texture2d.default) {
        return textureOrAttribute;
      }

      var refTexture = this.sourceTextures[0][textureOrAttribute];

      if (!refTexture) {
        return null;
      }

      return (0, _webglUtils.cloneTextureFrom)(refTexture, {
        parameters: (_parameters = {}, (0, _defineProperty2.default)(_parameters, 10241, 9728), (0, _defineProperty2.default)(_parameters, 10240, 9728), (0, _defineProperty2.default)(_parameters, 10242, 33071), (0, _defineProperty2.default)(_parameters, 10243, 33071), _parameters),
        pixelStore: (0, _defineProperty2.default)({}, 37440, false)
      });
    } // auto create any feedback buffers

  }, {
    key: "_createFeedbackBuffers",
    value: function _createFeedbackBuffers(_ref3) {
      var feedbackBuffers = _ref3.feedbackBuffers;

      if (!this.feedbackMap) {
        // feedbackMap required to auto create buffers.
        return;
      }

      var current = this.currentIndex;

      for (var sourceBufferName in this.feedbackMap) {
        var feedbackBufferName = this.feedbackMap[sourceBufferName];

        if (feedbackBufferName !== this.targetTextureVarying && (!feedbackBuffers || !feedbackBuffers[feedbackBufferName])) {
          // Create new buffer with same layout and settings as source buffer
          var sourceBuffer = this.sourceBuffers[current][sourceBufferName];
          var bytes = sourceBuffer.bytes,
              type = sourceBuffer.type,
              usage = sourceBuffer.usage,
              accessor = sourceBuffer.accessor;
          var buffer = new _buffer.default(this.gl, {
            bytes: bytes,
            type: type,
            usage: usage,
            accessor: accessor
          });

          if (this._createdBuffers[feedbackBufferName]) {
            this._createdBuffers[feedbackBufferName].delete();
          }

          this._createdBuffers[feedbackBufferName] = buffer;
          this.feedbackBuffers[current][feedbackBufferName] = buffer;
        }
      }
    } // Create a buffer and add to list of buffers to be deleted.

  }, {
    key: "_createNewBuffer",
    value: function _createNewBuffer(name, opts) {
      var buffer = new _buffer.default(this.gl, opts);

      if (this._createdBuffers[name]) {
        this._createdBuffers[name].delete();

        this._createdBuffers[name] = buffer;
      }

      return buffer;
    } // setup buffers for swapping.
    // Second set of source and feedback objects are setup to point
    // to corresponding feedback and source buffers.

  }, {
    key: "_setupSwapBuffers",
    value: function _setupSwapBuffers() {
      if (!this.feedbackMap) {
        // feedbackMap required set up swap buffers.
        return;
      }

      var current = this.currentIndex;
      var next = (current + 1) % 2; // Copy all buffers/textures so un-mapped sources will remain same

      Object.assign(this.sourceBuffers[next], this.sourceBuffers[current]);
      Object.assign(this.feedbackBuffers[next], this.feedbackBuffers[current]);

      for (var srcName in this.feedbackMap) {
        var dstName = this.feedbackMap[srcName]; // TODO: add textureMap and remove this if loop

        if (dstName !== this.targetTextureVarying) {
          this.sourceBuffers[next][srcName] = this.feedbackBuffers[current][dstName];
          this.feedbackBuffers[next][dstName] = this.sourceBuffers[current][srcName]; // make sure the new destination buffer is a Buffer object

          (0, _assert.default)(this.feedbackBuffers[next][dstName] instanceof _buffer.default);
        }
      } // When triggered by `update()` TranformFeedback objects are already set up,
      // if so update buffers


      if (this.transformFeedbacks[next]) {
        this.transformFeedbacks[next].setBuffers(this.feedbackBuffers[next]);
      } // TODO: add swap support for targetTexture and framebuffers

    } // setup textures for swapping.

  }, {
    key: "_setupSwapTextures",
    value: function _setupSwapTextures() {
      if (!this._swapTexture || !this.targetTextureVarying) {
        // Must be rendering to a texture and _swapTexture is provided
        return;
      }

      var current = this.currentIndex;
      var next = (current + 1) % 2;
      Object.assign(this.sourceTextures[next], this.sourceTextures[current]);
      this.sourceTextures[next][this._swapTexture] = this.targetTextures[current];
      this.targetTextures[next] = this.sourceTextures[current][this._swapTexture]; // When triggered by `update()` Framebuffer objects are already set up,
      // if so update buffers

      if (this.framebuffers[next]) {
        this.framebuffers[next].update((0, _defineProperty2.default)({}, 36064, this.targetTextures[next]));
      }
    } // build Model and TransformFeedback objects

  }, {
    key: "_buildModel",
    value: function _buildModel() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _this$_getShaders = this._getShaders(props),
          vs = _this$_getShaders.vs,
          fs = _this$_getShaders.fs,
          modules = _this$_getShaders.modules,
          uniforms = _this$_getShaders.uniforms,
          inject = _this$_getShaders.inject,
          samplerTextureMap = _this$_getShaders.samplerTextureMap;

      this.model = new _model.default(this.gl, Object.assign({}, props, {
        vs: vs,
        fs: fs,
        vertexCount: props.elementCount,
        modules: modules,
        uniforms: uniforms,
        inject: inject
      }));
      this.samplerTextureMap = samplerTextureMap; // setup TF to capture varyings.

      this._setupTransformFeedback(); // setup Framebuffer object for rendering to Texture.


      this._setupFramebuffers(); // create buffer to access source texture pixesl.


      this._setElementCount(props.elementCount);
    } // setup TransformFeedback objects to capture the results

  }, {
    key: "_setupTransformFeedback",
    value: function _setupTransformFeedback() {
      if ((0, _utils.isObjectEmpty)(this.feedbackBuffers[0])) {
        return;
      }

      this.transformFeedbacks[0] = new _transformFeedback.default(this.gl, {
        program: this.model.program,
        buffers: this.feedbackBuffers[0]
      }); // If buffers are swappable setup second transform feedback object.

      if (this.feedbackMap) {
        this.transformFeedbacks[1] = new _transformFeedback.default(this.gl, {
          program: this.model.program,
          buffers: this.feedbackBuffers[1]
        });
      }
    } // setup framebuffers with texture attachments, to which results are rendered

  }, {
    key: "_setupFramebuffers",
    value: function _setupFramebuffers() {
      if (!this.renderingToTexture) {
        return;
      }

      var _this$targetTextures$ = this.targetTextures[0],
          width = _this$targetTextures$.width,
          height = _this$targetTextures$.height;
      this.framebuffers[0] = new _framebuffer.default(this.gl, {
        id: "".concat(this.id || 'transform', "-framebuffer-0"),
        width: width,
        height: height,
        attachments: (0, _defineProperty2.default)({}, 36064, this.targetTextures[0])
      });

      if (this._swapTexture) {
        var _this$targetTextures$2 = this.targetTextures[1];
        width = _this$targetTextures$2.width;
        height = _this$targetTextures$2.height;
        this.framebuffers[1] = new _framebuffer.default(this.gl, {
          id: "".concat(this.id || 'transform', "-framebuffer-1"),
          width: width,
          height: height,
          attachments: (0, _defineProperty2.default)({}, 36064, this.targetTextures[1])
        });
      }
    } // create/update buffer to access source texture's individual pixels.

  }, {
    key: "_updateElementIDBuffer",
    value: function _updateElementIDBuffer(elementCount) {
      if (!this.hasSourceTextures && !this.targetTextureVarying) {
        return;
      } // NOTE: using float so this will work with GLSL 1.0 shaders.


      var elementIds = new Float32Array(elementCount);
      elementIds.forEach(function (_, index, array) {
        array[index] = index;
      });

      if (!this.elementIDBuffer) {
        this.elementIDBuffer = new _buffer.default(this.gl, {
          data: elementIds,
          size: 1
        });
      } else {
        this.elementIDBuffer.setData({
          data: elementIds
        });
      }
    } // build and return shader releated parameters

  }, {
    key: "_getShaders",
    value: function _getShaders() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _this$_processVertexS = this._processVertexShader(props.vs),
          vs = _this$_processVertexS.vs,
          uniforms = _this$_processVertexS.uniforms,
          targetTextureType = _this$_processVertexS.targetTextureType,
          inject = _this$_processVertexS.inject,
          samplerTextureMap = _this$_processVertexS.samplerTextureMap;

      this.targetTextureType = targetTextureType;
      var fs = (0, _src.getPassthroughFS)({
        version: (0, _webglUtils.getShaderVersion)(vs),
        input: this.targetTextureVarying,
        inputType: targetTextureType,
        output: FS_OUTPUT_VARIABLE
      });
      var modules = this.hasSourceTextures || this.targetTextureVarying ? [_src._transform].concat(props.modules || []) : props.modules;
      return {
        vs: vs,
        fs: fs,
        modules: modules,
        uniforms: uniforms,
        inject: inject,
        samplerTextureMap: samplerTextureMap
      };
    } // scan and update vertex shader for texture atrributes.

  }, {
    key: "_processVertexShader",
    value: function _processVertexShader(vs) {
      return (0, _transformShaderUtils.updateForTextures)({
        vs: vs,
        sourceTextureMap: this.sourceTextures[this.currentIndex],
        targetTextureVarying: this.targetTextureVarying,
        targetTexture: this.targetTextures[this.currentIndex]
      });
    }
  }]);
  return Transform;
}();

exports.default = Transform;
//# sourceMappingURL=transform.js.map