"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = pickModels;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _webgl = require("../webgl");

var _group = _interopRequireDefault(require("./group"));

var _assert = _interopRequireDefault(require("../utils/assert"));

/* global window */
function getDevicePixelRatio() {
  return typeof window !== 'undefined' ? window.devicePixelRatio : 1;
}

function pickModels(gl, props) {
  var models = props.models,
      position = props.position,
      _props$uniforms = props.uniforms,
      uniforms = _props$uniforms === void 0 ? {} : _props$uniforms,
      _props$parameters = props.parameters,
      parameters = _props$parameters === void 0 ? {} : _props$parameters,
      settings = props.settings,
      _props$useDevicePixel = props.useDevicePixels,
      useDevicePixels = _props$useDevicePixel === void 0 ? true : _props$useDevicePixel,
      framebuffer = props.framebuffer,
      context = props.context;
  (0, _assert.default)((0, _webgl.isWebGL)(gl) && framebuffer && position);

  var _position = (0, _slicedToArray2.default)(position, 2),
      x = _position[0],
      y = _position[1]; // Match our picking framebuffer with the size of the canvas drawing buffer


  framebuffer.resize({
    width: gl.canvas.width,
    height: gl.canvas.height
  }); // Compensate for devicePixelRatio
  // Note: this assumes the canvas framebuffer has been matched

  var dpr = useDevicePixels ? getDevicePixelRatio() : 1; // Reverse the y coordinate

  var deviceX = x * dpr;
  var deviceY = gl.canvas.height - y * dpr; // return withParameters(gl, {
  //   // framebuffer,
  //   // // We are only interested in one pixel, no need to render anything else
  //   // scissorTest: {x: deviceX, y: deviceY, w: 1, h: 1}
  // }, () => {

  var group = new _group.default({
    children: models
  });
  return group.traverseReverse(function (model) {
    if (model.pickable) {
      // Clear the frame buffer
      (0, _webgl.clear)(gl, {
        framebuffer: framebuffer,
        color: true,
        depth: true
      }); // Render picking colors

      /* eslint-disable camelcase */

      model.setUniforms({
        picking_uActive: 1
      });
      model.draw(Object.assign({}, props, {
        uniforms: uniforms,
        parameters: parameters,
        settings: settings,
        framebuffer: framebuffer,
        context: context
      }));
      model.setUniforms({
        picking_uActive: 0
      }); // Sample Read color in the central pixel, to be mapped as a picking color

      var color = framebuffer.readPixels({
        x: deviceX,
        y: deviceY,
        width: 1,
        height: 1,
        format: 6408,
        type: 5121
      });
      var isPicked = color[0] !== 0 || color[1] !== 0 || color[2] !== 0; // Add the information to the stack

      if (isPicked) {
        return {
          model: model,
          color: color,
          x: x,
          y: y,
          deviceX: deviceX,
          deviceY: deviceY
        };
      }
    }

    return null;
  }); // });
}
//# sourceMappingURL=pick-models.js.map