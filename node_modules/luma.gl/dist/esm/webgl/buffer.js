import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import Resource from './resource';
import Accessor from './accessor';
import { assertWebGL2Context } from '../webgl-utils';
import { getGLTypeFromTypedArray, getTypedArrayFromGLType } from '../webgl-utils/typed-array-utils';
import { log } from '../utils';
import assert from '../utils/assert';
var DEBUG_DATA_LENGTH = 10;

var Buffer =
/*#__PURE__*/
function (_Resource) {
  _inherits(Buffer, _Resource);

  function Buffer(gl) {
    var _this;

    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Buffer);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Buffer).call(this, gl, props));

    _this.stubRemovedMethods('Buffer', 'v6.0', ['layout', 'setLayout', 'getIndexedParameter']); // In WebGL1, need to make sure we use GL.ELEMENT_ARRAY_BUFFER when initializing element buffers
    // otherwise buffer type will lock to generic (non-element) buffer
    // In WebGL2, we can use GL.COPY_READ_BUFFER which avoids locking the type here


    _this.target = props.target || (_this.gl.webgl2 ? 36662 : 34962);

    _this._initialize(props);

    Object.seal(_assertThisInitialized(_assertThisInitialized(_this)));
    return _this;
  } // returns number of elements in the buffer (assuming that the full buffer is used)


  _createClass(Buffer, [{
    key: "getElementCount",
    value: function getElementCount() {
      var accessor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.accessor;
      return Math.round(this.byteLength / Accessor.getBytesPerElement(accessor));
    } // returns number of vertices in the buffer (assuming that the full buffer is used)

  }, {
    key: "getVertexCount",
    value: function getVertexCount() {
      var accessor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.accessor;
      return Math.round(this.byteLength / Accessor.getBytesPerVertex(accessor));
    } // Creates and initializes the buffer object's data store.

  }, {
    key: "initialize",
    value: function initialize(props) {
      return this._initialize(props);
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      if ('data' in props) {
        this.setData(props);
      }

      return this;
    } // Stores the accessor of data with the buffer, makes it easy to e.g. set it as an attribute later
    // {accessor,type,size = 1,offset = 0,stride = 0,normalized = false,integer = false,divisor = 0}

  }, {
    key: "setAccessor",
    value: function setAccessor(opts) {
      this.accessor = opts;
      return this;
    } // Allocate a bigger GPU buffer (if the current buffer is not big enough).
    // If a reallocation is triggered it clears the buffer
    // Returns:
    //  `true`: buffer was reallocated, data was cleared
    //  `false`: buffer was big enough, data is intact

  }, {
    key: "reallocate",
    value: function reallocate(byteLength) {
      if (byteLength > this.byteLength) {
        this._setByteLength(byteLength);

        return true;
      }

      this.bytesUsed = byteLength;
      return false;
    } // Update with new data

  }, {
    key: "setData",
    value: function setData(opts) {
      return this.initialize(opts);
    } // Updates a subset of a buffer object's data store.
    // Data (Typed Array or ArrayBuffer), length is inferred unless provided
    // Offset into buffer
    // WebGL2 only: Offset into srcData
    // WebGL2 only: Number of bytes to be copied

  }, {
    key: "subData",
    value: function subData(props) {
      // Signature: buffer.subData(new Float32Array([...]))
      if (ArrayBuffer.isView(props)) {
        props = {
          data: props
        };
      }

      var _props = props,
          data = _props.data,
          _props$offset = _props.offset,
          offset = _props$offset === void 0 ? 0 : _props$offset,
          _props$srcOffset = _props.srcOffset,
          srcOffset = _props$srcOffset === void 0 ? 0 : _props$srcOffset;
      var byteLength = props.byteLength || props.length; // if (byteLength > this.byteLength) {
      //   byteLength = this.byteLength;
      // }

      assert(data); // Create the buffer - binding it here for the first time locks the type
      // In WebGL2, use GL.COPY_WRITE_BUFFER to avoid locking the type

      var target = this.gl.webgl2 ? 36663 : this.target;
      this.gl.bindBuffer(target, this.handle); // WebGL2: subData supports additional srcOffset and length parameters

      if (srcOffset !== 0 || byteLength !== undefined) {
        assertWebGL2Context(this.gl);
        this.gl.bufferSubData(this.target, offset, data, srcOffset, byteLength);
      } else {
        this.gl.bufferSubData(target, offset, data);
      }

      this.gl.bindBuffer(target, null); // TODO - update local `data` if offsets are right

      this.debugData = null;

      if (!this.accessor.type) {
        this.setAccessor(new Accessor(this.accessor, {
          type: getGLTypeFromTypedArray(data)
        }));
      }

      return this;
    } // WEBGL2 ONLY: Copies part of the data of another buffer into this buffer

  }, {
    key: "copyData",
    value: function copyData(_ref) {
      var sourceBuffer = _ref.sourceBuffer,
          _ref$readOffset = _ref.readOffset,
          readOffset = _ref$readOffset === void 0 ? 0 : _ref$readOffset,
          _ref$writeOffset = _ref.writeOffset,
          writeOffset = _ref$writeOffset === void 0 ? 0 : _ref$writeOffset,
          size = _ref.size;
      var gl = this.gl;
      assertWebGL2Context(gl); // Use GL.COPY_READ_BUFFER+GL.COPY_WRITE_BUFFER avoid disturbing other targets and locking type

      gl.bindBuffer(36662, sourceBuffer.handle);
      gl.bindBuffer(36663, this.handle);
      gl.copyBufferSubData(36662, 36663, readOffset, writeOffset, size);
      gl.bindBuffer(36662, null);
      gl.bindBuffer(36663, null); // TODO - update local `data` if offsets are 0

      this.debugData = null;
      return this;
    } // WEBGL2 ONLY: Reads data from buffer into an ArrayBufferView or SharedArrayBuffer.

  }, {
    key: "getData",
    value: function getData() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$dstData = _ref2.dstData,
          dstData = _ref2$dstData === void 0 ? null : _ref2$dstData,
          _ref2$srcByteOffset = _ref2.srcByteOffset,
          srcByteOffset = _ref2$srcByteOffset === void 0 ? 0 : _ref2$srcByteOffset,
          _ref2$dstOffset = _ref2.dstOffset,
          dstOffset = _ref2$dstOffset === void 0 ? 0 : _ref2$dstOffset,
          _ref2$length = _ref2.length,
          length = _ref2$length === void 0 ? 0 : _ref2$length;

      assertWebGL2Context(this.gl);
      var ArrayType = getTypedArrayFromGLType(this.accessor.type || 5126, {
        clamped: false
      });

      var sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);

      var dstElementOffset = dstOffset;
      var dstAvailableElementCount;
      var dstElementCount;

      if (dstData) {
        dstElementCount = dstData.length;
        dstAvailableElementCount = dstElementCount - dstElementOffset;
      } else {
        // Allocate ArrayBufferView with enough size to copy all eligible data.
        dstAvailableElementCount = Math.min(sourceAvailableElementCount, length || sourceAvailableElementCount);
        dstElementCount = dstElementOffset + dstAvailableElementCount;
      }

      var copyElementCount = Math.min(sourceAvailableElementCount, dstAvailableElementCount);
      length = length || copyElementCount;
      assert(length <= copyElementCount);
      dstData = dstData || new ArrayType(dstElementCount); // Use GL.COPY_READ_BUFFER to avoid disturbing other targets and locking type

      this.gl.bindBuffer(36662, this.handle);
      this.gl.getBufferSubData(36662, srcByteOffset, dstData, dstOffset, length);
      this.gl.bindBuffer(36662, null); // TODO - update local `data` if offsets are 0

      return dstData;
    }
    /**
     * Binds a buffer to a given binding point (target).
     *   GL.TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER take an index, and optionally a range.
     * @param {Glenum} target - target for the bind operation.
     * @param {GLuint} index= - the index of the target.
     *   - GL.TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER need an index to affect state
     * @param {GLuint} offset=0 - the index of the target.
     *   - GL.UNIFORM_BUFFER: `offset` must be aligned to GL.UNIFORM_BUFFER_OFFSET_ALIGNMENT.
     * @param {GLuint} size= - the index of the target.
     *   - GL.UNIFORM_BUFFER: `size` must be a minimum of GL.UNIFORM_BLOCK_SIZE_DATA.
     * @returns {Buffer} - Returns itself for chaining.
     */

  }, {
    key: "bind",
    value: function bind() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref3$target = _ref3.target,
          target = _ref3$target === void 0 ? this.target : _ref3$target,
          _ref3$index = _ref3.index,
          index = _ref3$index === void 0 ? this.accessor && this.accessor.index : _ref3$index,
          _ref3$offset = _ref3.offset,
          offset = _ref3$offset === void 0 ? 0 : _ref3$offset,
          size = _ref3.size;

      // NOTE: While GL.TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER could
      // be used as direct binding points, they will not affect transform feedback or
      // uniform buffer state. Instead indexed bindings need to be made.
      if (target === 35345 || target === 35982) {
        if (size !== undefined) {
          this.gl.bindBufferRange(target, index, this.handle, offset, size);
        } else {
          assert(offset === 0); // Make sure offset wasn't supplied

          this.gl.bindBufferBase(target, index, this.handle);
        }
      } else {
        this.gl.bindBuffer(target, this.handle);
      }

      return this;
    }
  }, {
    key: "unbind",
    value: function unbind() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref4$target = _ref4.target,
          target = _ref4$target === void 0 ? this.target : _ref4$target,
          _ref4$index = _ref4.index,
          index = _ref4$index === void 0 ? this.accessor && this.accessor.index : _ref4$index;

      var isIndexedBuffer = target === 35345 || target === 35982;

      if (isIndexedBuffer) {
        this.gl.bindBufferBase(target, index, null);
      } else {
        this.gl.bindBuffer(target, null);
      }

      return this;
    } // DEPRECATED/REMOVED METHODS

  }, {
    key: "getDebugData",
    // PROTECTED METHODS (INTENDED FOR USE BY OTHER FRAMEWORK CODE ONLY)
    // Returns a short initial data array
    value: function getDebugData() {
      if (!this.debugData) {
        this.debugData = this.getData({
          length: DEBUG_DATA_LENGTH
        });
        return {
          data: this.debugData,
          changed: true
        };
      }

      return {
        data: this.debugData,
        changed: false
      };
    }
  }, {
    key: "invalidateDebugData",
    value: function invalidateDebugData() {
      this.debugData = null;
    } // PRIVATE METHODS
    // Signature: `new Buffer(gl, {data: new Float32Array(...)})`
    // Signature: `new Buffer(gl, new Float32Array(...))`
    // Signature: `new Buffer(gl, 100)`

  }, {
    key: "_initialize",
    value: function _initialize() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      // Signature `new Buffer(gl, new Float32Array(...)`
      if (ArrayBuffer.isView(props)) {
        props = {
          data: props
        };
      } // Signature: `new Buffer(gl, 100)`


      if (Number.isFinite(props)) {
        props = {
          byteLength: props
        };
      }

      if (props.bytes) {
        log.deprecated('bytes', 'byteLength');
      }

      var byteLength = props.byteLength || props.bytes || 0; // assert(props.data || byteLength);

      this.usage = props.usage || 35044; // DEPRECATE - remove `props` from this list in next major release

      this.setAccessor(new Accessor(props, props.accessor));
      return props.data ? this._setData(props.data) : this._setByteLength(byteLength);
    } // Allocate a new buffer and initialize to contents of typed array

  }, {
    key: "_setData",
    value: function _setData(data) {
      var usage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.usage;
      assert(ArrayBuffer.isView(data));

      var target = this._getTarget();

      this.gl.bindBuffer(target, this.handle);
      this.gl.bufferData(target, data, usage);
      this.gl.bindBuffer(target, null);
      this.usage = usage;
      this.debugData = data.slice(0, DEBUG_DATA_LENGTH);
      this.byteLength = data.byteLength;
      this.bytesUsed = data.byteLength; // infer GL type from supplied typed array

      var type = getGLTypeFromTypedArray(data);
      assert(type);
      this.setAccessor(new Accessor(this.accessor, {
        type: type
      }));
      return this;
    } // Allocate a GPU buffer of specified size.

  }, {
    key: "_setByteLength",
    value: function _setByteLength(byteLength) {
      var usage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.usage;
      assert(byteLength >= 0); // Workaround needed for Safari (#291):
      // gl.bufferData with size equal to 0 crashes. Instead create zero sized array.

      var data = byteLength;

      if (byteLength === 0) {
        data = new Float32Array(0);
      }

      var target = this._getTarget();

      this.gl.bindBuffer(target, this.handle);
      this.gl.bufferData(target, data, usage);
      this.gl.bindBuffer(target, null);
      this.usage = usage;
      this.debugData = null;
      this.byteLength = byteLength;
      this.bytesUsed = byteLength;
      return this;
    } // Binding a buffer for the first time locks the type
    // In WebGL2, use GL.COPY_WRITE_BUFFER to avoid locking the type

  }, {
    key: "_getTarget",
    value: function _getTarget() {
      return this.gl.webgl2 ? 36663 : this.target;
    }
  }, {
    key: "_getAvailableElementCount",
    value: function _getAvailableElementCount(srcByteOffset) {
      var ArrayType = getTypedArrayFromGLType(this.accessor.type || 5126, {
        clamped: false
      });
      var sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;
      return this.getElementCount() - sourceElementOffset;
    } // RESOURCE METHODS

  }, {
    key: "_createHandle",
    value: function _createHandle() {
      return this.gl.createBuffer();
    }
  }, {
    key: "_deleteHandle",
    value: function _deleteHandle() {
      this.gl.deleteBuffer(this.handle);
    }
  }, {
    key: "_getParameter",
    value: function _getParameter(pname) {
      this.gl.bindBuffer(this.target, this.handle);
      var value = this.gl.getBufferParameter(this.target, pname);
      this.gl.bindBuffer(this.target, null);
      return value;
    } // DEPRECATED

  }, {
    key: "updateAccessor",
    value: function updateAccessor(opts) {
      log.deprecated('updateAccessor(...)', 'setAccessor(new Accessor(buffer.accessor, ...)');
      this.accessor = new Accessor(this.accessor, opts);
      return this;
    }
  }, {
    key: "setByteLength",
    value: function setByteLength(byteLength) {
      log.deprecated('setByteLength', 'reallocate');
      return this.reallocate(byteLength);
    }
  }, {
    key: "data",
    get: function get() {
      log.removed('Buffer.data', 'N/A', 'v6.0');
    }
  }, {
    key: "bytes",
    get: function get() {
      log.deprecated('Buffer.bytes', 'Buffer.byteLength', 'v6.1');
      return this.byteLength;
    }
  }]);

  return Buffer;
}(Resource);

export { Buffer as default };
//# sourceMappingURL=buffer.js.map