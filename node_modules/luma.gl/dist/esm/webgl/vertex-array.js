import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
// VertexArray class
import Accessor from './accessor';
import Buffer from './buffer';
import VertexArrayObject from './vertex-array-object';
import { log, assert } from '../utils';
import { stubRemovedMethods } from '../utils';
var ERR_ATTRIBUTE_TYPE = 'VertexArray: attributes must be Buffers or constants (i.e. typed array)';

var VertexArray =
/*#__PURE__*/
function () {
  function VertexArray(gl) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, VertexArray);

    // Use program's id if program is supplied but no id is supplied
    var id = opts.id || opts.program && opts.program.id; // super(gl, Object.assign({}, opts, {id}));

    this.id = id;
    this.gl = gl;
    this.configuration = null; // Extracted information

    this.elements = null;
    this.values = null;
    this.accessors = null;
    this.unused = null;
    this.drawParams = null;
    this.buffer = null; // For attribute 0 on desktops, and created when unbinding buffers

    this.vertexArrayObject = VertexArrayObject.isSupported(gl) ? new VertexArrayObject(gl) : VertexArrayObject.getDefaultArray(gl); // Issue errors when using removed methods

    stubRemovedMethods(this, 'VertexArray', 'v6.0', ['setBuffers', 'setGeneric', 'clearBindings', 'setLocations', 'setGenericValues', 'setDivisor', 'enable', 'disable']);
    this.initialize(opts);
    Object.seal(this);
  }

  _createClass(VertexArray, [{
    key: "delete",
    value: function _delete() {
      if (this.buffer) {
        this.buffer.delete();
      }
    }
  }, {
    key: "initialize",
    value: function initialize() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.reset();
      this.configuration = null;
      this.bindOnUse = false;
      return this.setProps(props);
    } // Resets all attributes (to default valued constants)

  }, {
    key: "reset",
    value: function reset() {
      // this.vertexArrayObject.reset();
      this.elements = null;
      var MAX_ATTRIBUTES = this.vertexArrayObject.MAX_ATTRIBUTES;
      this.values = new Array(MAX_ATTRIBUTES).fill(null);
      this.accessors = new Array(MAX_ATTRIBUTES).fill(null);
      this.unused = {}; // Auto detects draw params

      this.drawParams = null;
      return this;
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      if ('program' in props) {
        this.configuration = props.program && props.program.configuration;
      }

      if ('configuration' in props) {
        this.configuration = props.configuration;
      }

      if ('attributes' in props) {
        this.setAttributes(props.attributes);
      }

      if ('elements' in props) {
        this.setElementBuffer(props.elements);
      }

      if ('bindOnUse' in props) {
        props = props.bindOnUse;
      }

      return this;
    } // Automatically called if buffers changed through VertexArray API

  }, {
    key: "clearDrawParams",
    value: function clearDrawParams() {
      this.drawParams = null;
    }
  }, {
    key: "getDrawParams",
    value: function getDrawParams(appParameters) {
      // Auto deduced draw parameters
      this.drawParams = this.drawParams || this._updateDrawParams(); // Override with any application supplied draw parameters

      return Object.assign({}, this.drawParams, appParameters);
    } // Set (bind) an array or map of vertex array buffers, either in numbered or named locations.
    // For names that are not present in `location`, the supplied buffers will be ignored.
    // if a single buffer of type GL.ELEMENT_ARRAY_BUFFER is present, it will be set as elements
    //   Signatures:
    //     {attributeName: buffer}
    //     {attributeName: [buffer, accessor]}
    //     {attributeName: (typed) array} => constant

  }, {
    key: "setAttributes",
    value: function setAttributes(attributes) {
      var _this = this;

      this.vertexArrayObject.bind(function () {
        for (var locationOrName in attributes) {
          var value = attributes[locationOrName];

          if (value instanceof Buffer) {
            //  Signature: attributeName: buffer
            _this.setBuffer(locationOrName, value);
          } else if (Array.isArray(value) && value.length && value[0] instanceof Buffer) {
            // Signature: attributeName: [buffer, accessor]
            var buffer = value[0];
            var accessor = value[1];

            _this.setBuffer(locationOrName, buffer, accessor);
          } else if (ArrayBuffer.isView(value) || Array.isArray(value)) {
            //  Signature: attributeName: (short) (typed) array => constant
            _this.setConstant(locationOrName, value);
          } else {
            throw new Error(ERR_ATTRIBUTE_TYPE);
          }
        } // Make sure we don't leave any bindings


        _this.gl.bindBuffer(34962, null);
      });
      return this;
    } // Set (bind) an elements buffer, for indexed rendering.
    // Must be a Buffer bound to GL.ELEMENT_ARRAY_BUFFER. Constants not supported

  }, {
    key: "setElementBuffer",
    value: function setElementBuffer() {
      var elementBuffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var accessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.elements = elementBuffer; // Save value for debugging

      this.clearDrawParams(); // Update vertexArray immediately if we have our own array

      if (!this.vertexArrayObject.isDefaultArray) {
        this.vertexArrayObject.setElementBuffer(elementBuffer, accessor);
      }

      return this;
    } // Set a location in vertex attributes array to a buffer

  }, {
    key: "setBuffer",
    value: function setBuffer(locationOrName, buffer) {
      var appAccessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      // Check target
      if (buffer.target === 34963) {
        return this.setElementBuffer(buffer);
      }

      var _this$_resolveLocatio = this._resolveLocationAndAccessor(locationOrName, buffer, buffer.accessor, appAccessor),
          location = _this$_resolveLocatio.location,
          accessor = _this$_resolveLocatio.accessor;

      if (location >= 0) {
        this.values[location] = buffer;
        this.accessors[location] = accessor;
        this.clearDrawParams(); // Update vertexArray immediately if we have our own array

        if (!this.vertexArrayObject.isDefaultArray) {
          this.vertexArrayObject.setBuffer(location, buffer, accessor);
        }
      }

      return this;
    } // Set attribute to constant value (small typed array corresponding to one vertex' worth of data)

  }, {
    key: "setConstant",
    value: function setConstant(locationOrName, arrayValue) {
      var appAccessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var _this$_resolveLocatio2 = this._resolveLocationAndAccessor(locationOrName, arrayValue, appAccessor),
          location = _this$_resolveLocatio2.location,
          accessor = _this$_resolveLocatio2.accessor;

      if (location >= 0) {
        arrayValue = this.vertexArrayObject._normalizeConstantArrayValue(arrayValue, accessor);
        this.values[location] = arrayValue;
        this.accessors[location] = accessor;
        this.clearDrawParams(); // Update vertexArray immediately if we have our own array
        // NOTE: We set the actual constant value later on bind. We can't set the value now since
        // constants are global and affect all other VertexArrays that have disabled attributes
        // in the same location.
        // We do disable the attribute which makes it use the global constant value at that location

        if (!this.vertexArrayObject.isDefaultArray) {
          this.vertexArrayObject.enable(location, false);
        }
      }

      return this;
    } // Workaround for Chrome TransformFeedback binding issue
    // If required, unbind temporarily to avoid conflicting with TransformFeedback

  }, {
    key: "unbindBuffers",
    value: function unbindBuffers() {
      var _this2 = this;

      this.vertexArrayObject.bind(function () {
        if (_this2.elements) {
          _this2.setElementBuffer(null);
        } // Chrome does not like buffers that are bound to several binding points,
        // so we need to offer and unbind facility
        // WebGL offers disabling, but no clear way to set a VertexArray buffer to `null`
        // So we just bind all the attributes to the dummy "attribute zero" buffer


        _this2.buffer = _this2.buffer || new Buffer(_this2.gl, {
          size: 4
        });

        for (var location = 0; location < _this2.vertexArrayObject.MAX_ATTRIBUTES; location++) {
          if (_this2.values[location] instanceof Buffer) {
            _this2.gl.disableVertexAttribArray(location);

            _this2.gl.bindBuffer(34962, _this2.buffer.handle);

            _this2.gl.vertexAttribPointer(location, 1, 5126, false, 0, 0);
          }
        }
      });
      return this;
    } // Workaround for Chrome TransformFeedback binding issue
    // If required, rebind rebind after temporary unbind

  }, {
    key: "bindBuffers",
    value: function bindBuffers() {
      var _this3 = this;

      this.vertexArrayObject.bind(function () {
        if (_this3.elements) {
          _this3.setElementBuffer(_this3.elements);
        }

        for (var location = 0; location < _this3.vertexArrayObject.MAX_ATTRIBUTES; location++) {
          var buffer = _this3.values[location];

          if (buffer instanceof Buffer) {
            _this3.setBuffer(location, buffer);
          }
        }
      });
      return this;
    } // Bind for use
    // When a vertex array is about to be used, we must:
    // - Set constant attributes (since these are stored on the context and reset on bind)
    // - Check if we need to initialize the buffer

  }, {
    key: "bindForDraw",
    value: function bindForDraw(vertexCount, instanceCount, func) {
      var _this4 = this;

      var value;
      this.vertexArrayObject.bind(function () {
        // Make sure that any constant attributes are updated (stored on the context, not the VAO)
        // Also handles attribute 0
        _this4._setConstantAttributes(vertexCount, instanceCount);

        if (!_this4.vertexArrayObject.hasVertexArrays) {
          _this4.bindBuffers();
        }

        value = func();

        if (!_this4.vertexArrayObject.hasVertexArrays) {
          _this4.unbindBuffers();
        }
      });
      return value;
    } // PRIVATE
    // Resolve locations and accessors

  }, {
    key: "_resolveLocationAndAccessor",
    value: function _resolveLocationAndAccessor(locationOrName, value, valueAccessor, appAccessor) {
      var _this5 = this;

      var location = this._getAttributeIndex(locationOrName);

      if (!Number.isFinite(location) || location < 0) {
        this.unused[locationOrName] = value;
        log.once(3, function () {
          return "unused value ".concat(locationOrName, " in ").concat(_this5.id);
        })();
        return this;
      }

      var accessInfo = this._getAttributeInfo(locationOrName); // Resolve the partial accessors into a final accessor


      var accessor = Accessor.resolve(accessInfo.accessor, valueAccessor, appAccessor);
      var size = accessor.size,
          type = accessor.type;
      assert(Number.isFinite(size) && Number.isFinite(type));
      return {
        location: location,
        accessor: accessor
      };
    }
  }, {
    key: "_getAttributeInfo",
    value: function _getAttributeInfo(attributeName) {
      return this.configuration && this.configuration.getAttributeInfo(attributeName);
    }
  }, {
    key: "_getAttributeIndex",
    value: function _getAttributeIndex(locationOrName) {
      if (this.configuration) {
        return this.configuration.getAttributeLocation(locationOrName);
      }

      var location = Number(locationOrName);

      if (Number.isFinite(location)) {
        return location;
      }

      return -1;
    } // Updates all constant attribute values (constants are used when vertex attributes are disabled).
    // This needs to be done repeatedly since in contrast to buffer bindings,
    // constants are stored on the WebGL context, not the VAO

  }, {
    key: "_setConstantAttributes",
    value: function _setConstantAttributes(vertexCount, instanceCount) {
      // TODO - use accessor to determine what length to use
      var elementCount = Math.max(vertexCount | 0, instanceCount | 0);
      var constant = this.values[0];

      if (ArrayBuffer.isView(constant)) {
        this._setConstantAttributeZero(constant, elementCount);
      }

      for (var location = 1; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
        constant = this.values[location];

        if (ArrayBuffer.isView(constant)) {
          this._setConstantAttribute(location, constant);
        }
      }
    }
  }, {
    key: "_setConstantAttributeZero",
    value: function _setConstantAttributeZero(constant, elementCount) {
      if (VertexArrayObject.isSupported(this.gl, {
        constantAttributeZero: true
      })) {
        this._setConstantAttribute(0, constant);

        return;
      } // Get a dummy buffer populated with repeated constants


      var buffer = this.vertexArrayObject.getConstantBuffer(elementCount, constant); // Set the buffer on location 0

      this.vertexArrayObject.setBuffer(0, buffer, this.accessors[0]);
    }
  }, {
    key: "_setConstantAttribute",
    value: function _setConstantAttribute(location, constant) {
      VertexArrayObject.setConstant(this.gl, location, constant); // If we are using the global VertexArrayObject, we need to disable the attribute now

      if (this.vertexArrayObject.isDefault) {
        this.vertexArrayObject.enable(location, false);
      }
    } // Walks the buffers and updates draw parameters

  }, {
    key: "_updateDrawParams",
    value: function _updateDrawParams() {
      var drawParams = {
        isIndexed: false,
        isInstanced: false,
        indexCount: Infinity,
        vertexCount: Infinity,
        instanceCount: Infinity
      };

      for (var location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
        this._updateDrawParamsForLocation(drawParams, location);
      }

      if (this.elements) {
        // indexing is autodetected - buffer with target GL.ELEMENT_ARRAY_BUFFER
        // index type is saved for drawElement calls
        drawParams.elementCount = this.elements.getElementCount(this.elements.accessor);
        drawParams.isIndexed = true;
        drawParams.indexType = this.elements.accessor.type;
      } // Post-calculation checks


      if (drawParams.indexCount === Infinity) {
        drawParams.indexCount = 0;
      }

      if (drawParams.vertexCount === Infinity) {
        drawParams.vertexCount = 0;
      }

      if (drawParams.instanceCount === Infinity) {
        drawParams.instanceCount = 0;
      }

      return drawParams;
    }
  }, {
    key: "_updateDrawParamsForLocation",
    value: function _updateDrawParamsForLocation(drawParams, location) {
      var value = this.values[location];
      var accessor = this.accessors[location];

      if (!value) {
        return;
      } // Check if instanced (whether buffer or constant)


      var divisor = accessor.divisor;
      var isInstanced = divisor > 0;
      drawParams.isInstanced = drawParams.isInstanced || isInstanced;

      if (value instanceof Buffer) {
        var buffer = value;

        if (isInstanced) {
          // instance attribute
          var instanceCount = buffer.getVertexCount(accessor);
          drawParams.instanceCount = Math.min(drawParams.instanceCount, instanceCount);
        } else {
          // normal attribute
          var vertexCount = buffer.getVertexCount(accessor);
          drawParams.vertexCount = Math.min(drawParams.vertexCount, vertexCount);
        }
      }
    } // DEPRECATED

  }, {
    key: "setElements",
    value: function setElements() {
      var elementBuffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var accessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      log.deprecated('setElements', 'setElementBuffer');
      return this.setElementBuffer(elementBuffer, accessor);
    }
  }]);

  return VertexArray;
}();

export { VertexArray as default };
//# sourceMappingURL=vertex-array.js.map