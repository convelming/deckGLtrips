import _construct from "@babel/runtime/helpers/esm/construct";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import { getTypedArrayFromGLType } from '../webgl-utils/typed-array-utils';
import log from '../utils/log';
import assert from '../utils/assert';
var DEFAULT_ACCESSOR_VALUES = {
  offset: 0,
  stride: 0,
  type: 5126,
  size: 1,
  divisor: 0,
  normalized: false,
  integer: false
};

var Accessor =
/*#__PURE__*/
function () {
  _createClass(Accessor, null, [{
    key: "getBytesPerElement",
    value: function getBytesPerElement(accessor) {
      // TODO: using `FLOAT` when type is not specified,
      // ensure this assumption is valid or force API to specify type.
      var ArrayType = getTypedArrayFromGLType(accessor.type || 5126);
      return ArrayType.BYTES_PER_ELEMENT;
    }
  }, {
    key: "getBytesPerVertex",
    value: function getBytesPerVertex(accessor) {
      assert(accessor.size); // TODO: using `FLOAT` when type is not specified,
      // ensure this assumption is valid or force API to specify type.

      var ArrayType = getTypedArrayFromGLType(accessor.type || 5126);
      return ArrayType.BYTES_PER_ELEMENT * accessor.size;
    } // Combines (merges) a list of accessors. On top of default values
    // Usually [programAccessor, bufferAccessor, appAccessor]
    // All props will be set in the returned object.
    // TODO check for conflicts between values in the supplied accessors

  }, {
    key: "resolve",
    value: function resolve() {
      for (var _len = arguments.length, accessors = new Array(_len), _key = 0; _key < _len; _key++) {
        accessors[_key] = arguments[_key];
      }

      return _construct(Accessor, [DEFAULT_ACCESSOR_VALUES].concat(accessors)); // Default values
    }
  }]);

  function Accessor() {
    var _this = this;

    _classCallCheck(this, Accessor);

    for (var _len2 = arguments.length, accessors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      accessors[_key2] = arguments[_key2];
    }

    accessors.forEach(function (accessor) {
      return _this._assign(accessor);
    }); // Merge in sequence

    Object.freeze(this);
  }

  _createClass(Accessor, [{
    key: "toString",
    value: function toString() {
      return JSON.stringify(this);
    } // ACCESSORS
    // TODO - remove>

  }, {
    key: "_assign",
    // PRIVATE

    /* eslint-disable complexity, max-statements */
    value: function _assign() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      // TYPE - not expected to be overridden
      if (props.type !== undefined) {
        if (this.type !== props.type) {
          log.warn('accessor type mismatch');
        }

        this.type = props.type; // Auto-deduce integer type?

        if (props.type === 5124 || props.type === 5125) {
          this.integer = true;
        }
      } // SIZE - not expected to be overridden


      if (props.size !== undefined) {
        if (this.size !== props.size) {
          log.warn('accessor size mismatch');
        }

        this.size = props.size;
      } // INSTANCE DIVISOR


      if (props.divisor !== undefined) {
        this.divisor = props.divisor;
      }

      if (props.offset !== undefined) {
        this.offset = props.offset;
      }

      if (props.stride !== undefined) {
        this.stride = props.stride;
      }

      if (props.normalized !== undefined) {
        this.normalized = props.normalized;
      }

      if (props.integer !== undefined) {
        this.integer = props.integer;
      } // Backwards compatibility


      if (props.instanced !== undefined) {
        log.deprecated('Accessor.instanced', 'Accessor.divisor');
        this.divisor = props.instanced ? 1 : 0;
      }

      if (props.isInstanced !== undefined) {
        log.deprecated('Accessor.isInstanced', 'Accessor.divisor');
        this.divisor = props.isInstanced ? 1 : 0;
      } // TODO - should this be supported?


      if (props.index !== undefined) {
        this.index = props.index ? 1 : 0;
      }

      return this;
    }
    /* eslint-enable complexity, max-statements */

  }, {
    key: "BYTES_PER_ELEMENT",
    get: function get() {
      return Accessor.getBytesPerElement(this);
    }
  }, {
    key: "BYTES_PER_VERTEX",
    get: function get() {
      return Accessor.getBytesPerVertex(this);
    }
  }]);

  return Accessor;
}(); // TEST EXPORTS


export { Accessor as default };
export { DEFAULT_ACCESSOR_VALUES };
//# sourceMappingURL=accessor.js.map