{"version":3,"sources":["../../../../../src/shadertools/src/lib/inject-shader.js"],"names":["MODULE_INJECTORS_VS","MODULE_INJECTORS_FS","VERTEX_SHADER","FRAGMENT_SHADER","assert","MODULE_INJECTORS","REGEX_DECLARATIONS","REGEX_START_OF_MAIN","REGEX_END_OF_MAIN","injectShader","source","type","inject","injectStandardStubs","isVertex","key","fragment","replace","match","combineInjects","injects","result","Array","isArray","length","forEach"],"mappings":"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","sourcesContent":["import {MODULE_INJECTORS_VS, MODULE_INJECTORS_FS} from '../modules/module-injectors';\nimport {VERTEX_SHADER, FRAGMENT_SHADER} from './constants';\nimport assert from 'assert';\n\n// TODO - experimental\nconst MODULE_INJECTORS = {\n  [VERTEX_SHADER]: MODULE_INJECTORS_VS,\n  [FRAGMENT_SHADER]: MODULE_INJECTORS_FS\n};\n\nconst REGEX_DECLARATIONS = /^(#version[^\\n]*\\n)?/; // Beginning of file\nconst REGEX_START_OF_MAIN = /main\\s*\\([^\\)]*\\)\\s*\\{\\n?/; // Beginning of main\nconst REGEX_END_OF_MAIN = /}\\n?[^{}]*$/; // End of main, assumes main is last function\n\n// A minimal shader injection/templating system.\n// RFC: https://github.com/uber/luma.gl/blob/master/dev-docs/RFCs/v6.0/shader-injection-rfc.md\n/* eslint-disable complexity */\nexport default function injectShader(source, type, inject, injectStandardStubs) {\n  const isVertex = type === VERTEX_SHADER;\n\n  for (const key in inject) {\n    const fragment = inject[key];\n    switch (key) {\n    // declarations are injected at beginning of shader\n    case 'vs:#decl':\n      if (isVertex) {\n        source = source.replace(REGEX_DECLARATIONS, match => match + fragment);\n      }\n      break;\n    // main code is injected at the end of main function\n    case 'vs:#main-start':\n      if (isVertex) {\n        source = source.replace(REGEX_START_OF_MAIN, match => match + fragment);\n      }\n      break;\n    case 'vs:#main-end':\n      if (isVertex) {\n        source = source.replace(REGEX_END_OF_MAIN, match => fragment + match);\n      }\n      break;\n    case 'fs:#decl':\n      if (!isVertex) {\n        source = source.replace(REGEX_DECLARATIONS, match => match + fragment);\n      }\n      break;\n    case 'fs:#main-start':\n      if (!isVertex) {\n        source = source.replace(REGEX_START_OF_MAIN, match => match + fragment);\n      }\n      break;\n    case 'fs:#main-end':\n      if (!isVertex) {\n        source = source.replace(REGEX_END_OF_MAIN, match => fragment + match);\n      }\n      break;\n    default:\n      // inject code after key, leaving key in place\n      source = source.replace(key, match => match + fragment);\n    }\n  }\n\n  // Finally, if requested, insert an automatic module injector chunk\n  if (injectStandardStubs) {\n    source = source.replace('}\\s*$', match => match + MODULE_INJECTORS[type]);\n  }\n\n  return source;\n}\n/* eslint-enable complexity */\n\n// Takes an array of inject objects and combines them into one\nexport function combineInjects(injects) {\n  const result = {};\n  assert(Array.isArray(injects) && injects.length > 1);\n  injects.forEach(inject => {\n    for (const key in inject) {\n      result[key] = result[key] ? `${result[key]}\\n${inject[key]}` : inject[key];\n    }\n  });\n  return result;\n}\n"],"file":"inject-shader.js"}